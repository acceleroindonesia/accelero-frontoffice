
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model blogs
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 * This model contains an expression index which requires additional setup for migrations. Visit https://pris.ly/d/expression-indexes for more info.
 */
export type blogs = $Result.DefaultSelection<Prisma.$blogsPayload>
/**
 * Model cache
 * 
 */
export type cache = $Result.DefaultSelection<Prisma.$cachePayload>
/**
 * Model cache_locks
 * 
 */
export type cache_locks = $Result.DefaultSelection<Prisma.$cache_locksPayload>
/**
 * Model contacts
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type contacts = $Result.DefaultSelection<Prisma.$contactsPayload>
/**
 * Model donations
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type donations = $Result.DefaultSelection<Prisma.$donationsPayload>
/**
 * Model migrations
 * 
 */
export type migrations = $Result.DefaultSelection<Prisma.$migrationsPayload>
/**
 * Model model_has_permissions
 * 
 */
export type model_has_permissions = $Result.DefaultSelection<Prisma.$model_has_permissionsPayload>
/**
 * Model model_has_roles
 * 
 */
export type model_has_roles = $Result.DefaultSelection<Prisma.$model_has_rolesPayload>
/**
 * Model password_reset_tokens
 * 
 */
export type password_reset_tokens = $Result.DefaultSelection<Prisma.$password_reset_tokensPayload>
/**
 * Model permissions
 * 
 */
export type permissions = $Result.DefaultSelection<Prisma.$permissionsPayload>
/**
 * Model personal_access_tokens
 * 
 */
export type personal_access_tokens = $Result.DefaultSelection<Prisma.$personal_access_tokensPayload>
/**
 * Model role_has_permissions
 * 
 */
export type role_has_permissions = $Result.DefaultSelection<Prisma.$role_has_permissionsPayload>
/**
 * Model roles
 * 
 */
export type roles = $Result.DefaultSelection<Prisma.$rolesPayload>
/**
 * Model socialite_users
 * 
 */
export type socialite_users = $Result.DefaultSelection<Prisma.$socialite_usersPayload>
/**
 * Model volunteers
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type volunteers = $Result.DefaultSelection<Prisma.$volunteersPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blogs`: Exposes CRUD operations for the **blogs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blogs
    * const blogs = await prisma.blogs.findMany()
    * ```
    */
  get blogs(): Prisma.blogsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cache`: Exposes CRUD operations for the **cache** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Caches
    * const caches = await prisma.cache.findMany()
    * ```
    */
  get cache(): Prisma.cacheDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cache_locks`: Exposes CRUD operations for the **cache_locks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cache_locks
    * const cache_locks = await prisma.cache_locks.findMany()
    * ```
    */
  get cache_locks(): Prisma.cache_locksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contacts`: Exposes CRUD operations for the **contacts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contacts.findMany()
    * ```
    */
  get contacts(): Prisma.contactsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.donations`: Exposes CRUD operations for the **donations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Donations
    * const donations = await prisma.donations.findMany()
    * ```
    */
  get donations(): Prisma.donationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.migrations`: Exposes CRUD operations for the **migrations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Migrations
    * const migrations = await prisma.migrations.findMany()
    * ```
    */
  get migrations(): Prisma.migrationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.model_has_permissions`: Exposes CRUD operations for the **model_has_permissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Model_has_permissions
    * const model_has_permissions = await prisma.model_has_permissions.findMany()
    * ```
    */
  get model_has_permissions(): Prisma.model_has_permissionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.model_has_roles`: Exposes CRUD operations for the **model_has_roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Model_has_roles
    * const model_has_roles = await prisma.model_has_roles.findMany()
    * ```
    */
  get model_has_roles(): Prisma.model_has_rolesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.password_reset_tokens`: Exposes CRUD operations for the **password_reset_tokens** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Password_reset_tokens
    * const password_reset_tokens = await prisma.password_reset_tokens.findMany()
    * ```
    */
  get password_reset_tokens(): Prisma.password_reset_tokensDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permissions`: Exposes CRUD operations for the **permissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permissions.findMany()
    * ```
    */
  get permissions(): Prisma.permissionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.personal_access_tokens`: Exposes CRUD operations for the **personal_access_tokens** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Personal_access_tokens
    * const personal_access_tokens = await prisma.personal_access_tokens.findMany()
    * ```
    */
  get personal_access_tokens(): Prisma.personal_access_tokensDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role_has_permissions`: Exposes CRUD operations for the **role_has_permissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Role_has_permissions
    * const role_has_permissions = await prisma.role_has_permissions.findMany()
    * ```
    */
  get role_has_permissions(): Prisma.role_has_permissionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roles`: Exposes CRUD operations for the **roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.roles.findMany()
    * ```
    */
  get roles(): Prisma.rolesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.socialite_users`: Exposes CRUD operations for the **socialite_users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Socialite_users
    * const socialite_users = await prisma.socialite_users.findMany()
    * ```
    */
  get socialite_users(): Prisma.socialite_usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.volunteers`: Exposes CRUD operations for the **volunteers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Volunteers
    * const volunteers = await prisma.volunteers.findMany()
    * ```
    */
  get volunteers(): Prisma.volunteersDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Session: 'Session',
    Project: 'Project',
    blogs: 'blogs',
    cache: 'cache',
    cache_locks: 'cache_locks',
    contacts: 'contacts',
    donations: 'donations',
    migrations: 'migrations',
    model_has_permissions: 'model_has_permissions',
    model_has_roles: 'model_has_roles',
    password_reset_tokens: 'password_reset_tokens',
    permissions: 'permissions',
    personal_access_tokens: 'personal_access_tokens',
    role_has_permissions: 'role_has_permissions',
    roles: 'roles',
    socialite_users: 'socialite_users',
    volunteers: 'volunteers'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "session" | "project" | "blogs" | "cache" | "cache_locks" | "contacts" | "donations" | "migrations" | "model_has_permissions" | "model_has_roles" | "password_reset_tokens" | "permissions" | "personal_access_tokens" | "role_has_permissions" | "roles" | "socialite_users" | "volunteers"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      blogs: {
        payload: Prisma.$blogsPayload<ExtArgs>
        fields: Prisma.blogsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.blogsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blogsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.blogsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blogsPayload>
          }
          findFirst: {
            args: Prisma.blogsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blogsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.blogsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blogsPayload>
          }
          findMany: {
            args: Prisma.blogsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blogsPayload>[]
          }
          create: {
            args: Prisma.blogsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blogsPayload>
          }
          createMany: {
            args: Prisma.blogsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.blogsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blogsPayload>[]
          }
          delete: {
            args: Prisma.blogsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blogsPayload>
          }
          update: {
            args: Prisma.blogsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blogsPayload>
          }
          deleteMany: {
            args: Prisma.blogsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.blogsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.blogsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blogsPayload>[]
          }
          upsert: {
            args: Prisma.blogsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blogsPayload>
          }
          aggregate: {
            args: Prisma.BlogsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlogs>
          }
          groupBy: {
            args: Prisma.blogsGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogsGroupByOutputType>[]
          }
          count: {
            args: Prisma.blogsCountArgs<ExtArgs>
            result: $Utils.Optional<BlogsCountAggregateOutputType> | number
          }
        }
      }
      cache: {
        payload: Prisma.$cachePayload<ExtArgs>
        fields: Prisma.cacheFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cacheFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cachePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cacheFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cachePayload>
          }
          findFirst: {
            args: Prisma.cacheFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cachePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cacheFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cachePayload>
          }
          findMany: {
            args: Prisma.cacheFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cachePayload>[]
          }
          create: {
            args: Prisma.cacheCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cachePayload>
          }
          createMany: {
            args: Prisma.cacheCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.cacheCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cachePayload>[]
          }
          delete: {
            args: Prisma.cacheDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cachePayload>
          }
          update: {
            args: Prisma.cacheUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cachePayload>
          }
          deleteMany: {
            args: Prisma.cacheDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cacheUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.cacheUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cachePayload>[]
          }
          upsert: {
            args: Prisma.cacheUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cachePayload>
          }
          aggregate: {
            args: Prisma.CacheAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCache>
          }
          groupBy: {
            args: Prisma.cacheGroupByArgs<ExtArgs>
            result: $Utils.Optional<CacheGroupByOutputType>[]
          }
          count: {
            args: Prisma.cacheCountArgs<ExtArgs>
            result: $Utils.Optional<CacheCountAggregateOutputType> | number
          }
        }
      }
      cache_locks: {
        payload: Prisma.$cache_locksPayload<ExtArgs>
        fields: Prisma.cache_locksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cache_locksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_locksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cache_locksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_locksPayload>
          }
          findFirst: {
            args: Prisma.cache_locksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_locksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cache_locksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_locksPayload>
          }
          findMany: {
            args: Prisma.cache_locksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_locksPayload>[]
          }
          create: {
            args: Prisma.cache_locksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_locksPayload>
          }
          createMany: {
            args: Prisma.cache_locksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.cache_locksCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_locksPayload>[]
          }
          delete: {
            args: Prisma.cache_locksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_locksPayload>
          }
          update: {
            args: Prisma.cache_locksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_locksPayload>
          }
          deleteMany: {
            args: Prisma.cache_locksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cache_locksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.cache_locksUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_locksPayload>[]
          }
          upsert: {
            args: Prisma.cache_locksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_locksPayload>
          }
          aggregate: {
            args: Prisma.Cache_locksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCache_locks>
          }
          groupBy: {
            args: Prisma.cache_locksGroupByArgs<ExtArgs>
            result: $Utils.Optional<Cache_locksGroupByOutputType>[]
          }
          count: {
            args: Prisma.cache_locksCountArgs<ExtArgs>
            result: $Utils.Optional<Cache_locksCountAggregateOutputType> | number
          }
        }
      }
      contacts: {
        payload: Prisma.$contactsPayload<ExtArgs>
        fields: Prisma.contactsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.contactsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.contactsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactsPayload>
          }
          findFirst: {
            args: Prisma.contactsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.contactsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactsPayload>
          }
          findMany: {
            args: Prisma.contactsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactsPayload>[]
          }
          create: {
            args: Prisma.contactsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactsPayload>
          }
          createMany: {
            args: Prisma.contactsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.contactsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactsPayload>[]
          }
          delete: {
            args: Prisma.contactsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactsPayload>
          }
          update: {
            args: Prisma.contactsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactsPayload>
          }
          deleteMany: {
            args: Prisma.contactsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.contactsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.contactsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactsPayload>[]
          }
          upsert: {
            args: Prisma.contactsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactsPayload>
          }
          aggregate: {
            args: Prisma.ContactsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContacts>
          }
          groupBy: {
            args: Prisma.contactsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactsGroupByOutputType>[]
          }
          count: {
            args: Prisma.contactsCountArgs<ExtArgs>
            result: $Utils.Optional<ContactsCountAggregateOutputType> | number
          }
        }
      }
      donations: {
        payload: Prisma.$donationsPayload<ExtArgs>
        fields: Prisma.donationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.donationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$donationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.donationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$donationsPayload>
          }
          findFirst: {
            args: Prisma.donationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$donationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.donationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$donationsPayload>
          }
          findMany: {
            args: Prisma.donationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$donationsPayload>[]
          }
          create: {
            args: Prisma.donationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$donationsPayload>
          }
          createMany: {
            args: Prisma.donationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.donationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$donationsPayload>[]
          }
          delete: {
            args: Prisma.donationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$donationsPayload>
          }
          update: {
            args: Prisma.donationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$donationsPayload>
          }
          deleteMany: {
            args: Prisma.donationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.donationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.donationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$donationsPayload>[]
          }
          upsert: {
            args: Prisma.donationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$donationsPayload>
          }
          aggregate: {
            args: Prisma.DonationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDonations>
          }
          groupBy: {
            args: Prisma.donationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DonationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.donationsCountArgs<ExtArgs>
            result: $Utils.Optional<DonationsCountAggregateOutputType> | number
          }
        }
      }
      migrations: {
        payload: Prisma.$migrationsPayload<ExtArgs>
        fields: Prisma.migrationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.migrationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.migrationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          findFirst: {
            args: Prisma.migrationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.migrationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          findMany: {
            args: Prisma.migrationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>[]
          }
          create: {
            args: Prisma.migrationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          createMany: {
            args: Prisma.migrationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.migrationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>[]
          }
          delete: {
            args: Prisma.migrationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          update: {
            args: Prisma.migrationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          deleteMany: {
            args: Prisma.migrationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.migrationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.migrationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>[]
          }
          upsert: {
            args: Prisma.migrationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          aggregate: {
            args: Prisma.MigrationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMigrations>
          }
          groupBy: {
            args: Prisma.migrationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<MigrationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.migrationsCountArgs<ExtArgs>
            result: $Utils.Optional<MigrationsCountAggregateOutputType> | number
          }
        }
      }
      model_has_permissions: {
        payload: Prisma.$model_has_permissionsPayload<ExtArgs>
        fields: Prisma.model_has_permissionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.model_has_permissionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$model_has_permissionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.model_has_permissionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$model_has_permissionsPayload>
          }
          findFirst: {
            args: Prisma.model_has_permissionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$model_has_permissionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.model_has_permissionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$model_has_permissionsPayload>
          }
          findMany: {
            args: Prisma.model_has_permissionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$model_has_permissionsPayload>[]
          }
          create: {
            args: Prisma.model_has_permissionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$model_has_permissionsPayload>
          }
          createMany: {
            args: Prisma.model_has_permissionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.model_has_permissionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$model_has_permissionsPayload>[]
          }
          delete: {
            args: Prisma.model_has_permissionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$model_has_permissionsPayload>
          }
          update: {
            args: Prisma.model_has_permissionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$model_has_permissionsPayload>
          }
          deleteMany: {
            args: Prisma.model_has_permissionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.model_has_permissionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.model_has_permissionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$model_has_permissionsPayload>[]
          }
          upsert: {
            args: Prisma.model_has_permissionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$model_has_permissionsPayload>
          }
          aggregate: {
            args: Prisma.Model_has_permissionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModel_has_permissions>
          }
          groupBy: {
            args: Prisma.model_has_permissionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Model_has_permissionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.model_has_permissionsCountArgs<ExtArgs>
            result: $Utils.Optional<Model_has_permissionsCountAggregateOutputType> | number
          }
        }
      }
      model_has_roles: {
        payload: Prisma.$model_has_rolesPayload<ExtArgs>
        fields: Prisma.model_has_rolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.model_has_rolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$model_has_rolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.model_has_rolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$model_has_rolesPayload>
          }
          findFirst: {
            args: Prisma.model_has_rolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$model_has_rolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.model_has_rolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$model_has_rolesPayload>
          }
          findMany: {
            args: Prisma.model_has_rolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$model_has_rolesPayload>[]
          }
          create: {
            args: Prisma.model_has_rolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$model_has_rolesPayload>
          }
          createMany: {
            args: Prisma.model_has_rolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.model_has_rolesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$model_has_rolesPayload>[]
          }
          delete: {
            args: Prisma.model_has_rolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$model_has_rolesPayload>
          }
          update: {
            args: Prisma.model_has_rolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$model_has_rolesPayload>
          }
          deleteMany: {
            args: Prisma.model_has_rolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.model_has_rolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.model_has_rolesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$model_has_rolesPayload>[]
          }
          upsert: {
            args: Prisma.model_has_rolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$model_has_rolesPayload>
          }
          aggregate: {
            args: Prisma.Model_has_rolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModel_has_roles>
          }
          groupBy: {
            args: Prisma.model_has_rolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Model_has_rolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.model_has_rolesCountArgs<ExtArgs>
            result: $Utils.Optional<Model_has_rolesCountAggregateOutputType> | number
          }
        }
      }
      password_reset_tokens: {
        payload: Prisma.$password_reset_tokensPayload<ExtArgs>
        fields: Prisma.password_reset_tokensFieldRefs
        operations: {
          findUnique: {
            args: Prisma.password_reset_tokensFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.password_reset_tokensFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload>
          }
          findFirst: {
            args: Prisma.password_reset_tokensFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.password_reset_tokensFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload>
          }
          findMany: {
            args: Prisma.password_reset_tokensFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload>[]
          }
          create: {
            args: Prisma.password_reset_tokensCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload>
          }
          createMany: {
            args: Prisma.password_reset_tokensCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.password_reset_tokensCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload>[]
          }
          delete: {
            args: Prisma.password_reset_tokensDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload>
          }
          update: {
            args: Prisma.password_reset_tokensUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload>
          }
          deleteMany: {
            args: Prisma.password_reset_tokensDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.password_reset_tokensUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.password_reset_tokensUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload>[]
          }
          upsert: {
            args: Prisma.password_reset_tokensUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload>
          }
          aggregate: {
            args: Prisma.Password_reset_tokensAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePassword_reset_tokens>
          }
          groupBy: {
            args: Prisma.password_reset_tokensGroupByArgs<ExtArgs>
            result: $Utils.Optional<Password_reset_tokensGroupByOutputType>[]
          }
          count: {
            args: Prisma.password_reset_tokensCountArgs<ExtArgs>
            result: $Utils.Optional<Password_reset_tokensCountAggregateOutputType> | number
          }
        }
      }
      permissions: {
        payload: Prisma.$permissionsPayload<ExtArgs>
        fields: Prisma.permissionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.permissionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.permissionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>
          }
          findFirst: {
            args: Prisma.permissionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.permissionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>
          }
          findMany: {
            args: Prisma.permissionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>[]
          }
          create: {
            args: Prisma.permissionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>
          }
          createMany: {
            args: Prisma.permissionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.permissionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>[]
          }
          delete: {
            args: Prisma.permissionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>
          }
          update: {
            args: Prisma.permissionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>
          }
          deleteMany: {
            args: Prisma.permissionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.permissionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.permissionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>[]
          }
          upsert: {
            args: Prisma.permissionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>
          }
          aggregate: {
            args: Prisma.PermissionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermissions>
          }
          groupBy: {
            args: Prisma.permissionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.permissionsCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionsCountAggregateOutputType> | number
          }
        }
      }
      personal_access_tokens: {
        payload: Prisma.$personal_access_tokensPayload<ExtArgs>
        fields: Prisma.personal_access_tokensFieldRefs
        operations: {
          findUnique: {
            args: Prisma.personal_access_tokensFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$personal_access_tokensPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.personal_access_tokensFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$personal_access_tokensPayload>
          }
          findFirst: {
            args: Prisma.personal_access_tokensFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$personal_access_tokensPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.personal_access_tokensFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$personal_access_tokensPayload>
          }
          findMany: {
            args: Prisma.personal_access_tokensFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$personal_access_tokensPayload>[]
          }
          create: {
            args: Prisma.personal_access_tokensCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$personal_access_tokensPayload>
          }
          createMany: {
            args: Prisma.personal_access_tokensCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.personal_access_tokensCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$personal_access_tokensPayload>[]
          }
          delete: {
            args: Prisma.personal_access_tokensDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$personal_access_tokensPayload>
          }
          update: {
            args: Prisma.personal_access_tokensUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$personal_access_tokensPayload>
          }
          deleteMany: {
            args: Prisma.personal_access_tokensDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.personal_access_tokensUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.personal_access_tokensUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$personal_access_tokensPayload>[]
          }
          upsert: {
            args: Prisma.personal_access_tokensUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$personal_access_tokensPayload>
          }
          aggregate: {
            args: Prisma.Personal_access_tokensAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersonal_access_tokens>
          }
          groupBy: {
            args: Prisma.personal_access_tokensGroupByArgs<ExtArgs>
            result: $Utils.Optional<Personal_access_tokensGroupByOutputType>[]
          }
          count: {
            args: Prisma.personal_access_tokensCountArgs<ExtArgs>
            result: $Utils.Optional<Personal_access_tokensCountAggregateOutputType> | number
          }
        }
      }
      role_has_permissions: {
        payload: Prisma.$role_has_permissionsPayload<ExtArgs>
        fields: Prisma.role_has_permissionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.role_has_permissionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_has_permissionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.role_has_permissionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_has_permissionsPayload>
          }
          findFirst: {
            args: Prisma.role_has_permissionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_has_permissionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.role_has_permissionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_has_permissionsPayload>
          }
          findMany: {
            args: Prisma.role_has_permissionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_has_permissionsPayload>[]
          }
          create: {
            args: Prisma.role_has_permissionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_has_permissionsPayload>
          }
          createMany: {
            args: Prisma.role_has_permissionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.role_has_permissionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_has_permissionsPayload>[]
          }
          delete: {
            args: Prisma.role_has_permissionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_has_permissionsPayload>
          }
          update: {
            args: Prisma.role_has_permissionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_has_permissionsPayload>
          }
          deleteMany: {
            args: Prisma.role_has_permissionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.role_has_permissionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.role_has_permissionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_has_permissionsPayload>[]
          }
          upsert: {
            args: Prisma.role_has_permissionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_has_permissionsPayload>
          }
          aggregate: {
            args: Prisma.Role_has_permissionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole_has_permissions>
          }
          groupBy: {
            args: Prisma.role_has_permissionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Role_has_permissionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.role_has_permissionsCountArgs<ExtArgs>
            result: $Utils.Optional<Role_has_permissionsCountAggregateOutputType> | number
          }
        }
      }
      roles: {
        payload: Prisma.$rolesPayload<ExtArgs>
        fields: Prisma.rolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          findFirst: {
            args: Prisma.rolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          findMany: {
            args: Prisma.rolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>[]
          }
          create: {
            args: Prisma.rolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          createMany: {
            args: Prisma.rolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.rolesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>[]
          }
          delete: {
            args: Prisma.rolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          update: {
            args: Prisma.rolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          deleteMany: {
            args: Prisma.rolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.rolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.rolesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>[]
          }
          upsert: {
            args: Prisma.rolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          aggregate: {
            args: Prisma.RolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoles>
          }
          groupBy: {
            args: Prisma.rolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.rolesCountArgs<ExtArgs>
            result: $Utils.Optional<RolesCountAggregateOutputType> | number
          }
        }
      }
      socialite_users: {
        payload: Prisma.$socialite_usersPayload<ExtArgs>
        fields: Prisma.socialite_usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.socialite_usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$socialite_usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.socialite_usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$socialite_usersPayload>
          }
          findFirst: {
            args: Prisma.socialite_usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$socialite_usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.socialite_usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$socialite_usersPayload>
          }
          findMany: {
            args: Prisma.socialite_usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$socialite_usersPayload>[]
          }
          create: {
            args: Prisma.socialite_usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$socialite_usersPayload>
          }
          createMany: {
            args: Prisma.socialite_usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.socialite_usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$socialite_usersPayload>[]
          }
          delete: {
            args: Prisma.socialite_usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$socialite_usersPayload>
          }
          update: {
            args: Prisma.socialite_usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$socialite_usersPayload>
          }
          deleteMany: {
            args: Prisma.socialite_usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.socialite_usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.socialite_usersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$socialite_usersPayload>[]
          }
          upsert: {
            args: Prisma.socialite_usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$socialite_usersPayload>
          }
          aggregate: {
            args: Prisma.Socialite_usersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSocialite_users>
          }
          groupBy: {
            args: Prisma.socialite_usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Socialite_usersGroupByOutputType>[]
          }
          count: {
            args: Prisma.socialite_usersCountArgs<ExtArgs>
            result: $Utils.Optional<Socialite_usersCountAggregateOutputType> | number
          }
        }
      }
      volunteers: {
        payload: Prisma.$volunteersPayload<ExtArgs>
        fields: Prisma.volunteersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.volunteersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$volunteersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.volunteersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$volunteersPayload>
          }
          findFirst: {
            args: Prisma.volunteersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$volunteersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.volunteersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$volunteersPayload>
          }
          findMany: {
            args: Prisma.volunteersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$volunteersPayload>[]
          }
          create: {
            args: Prisma.volunteersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$volunteersPayload>
          }
          createMany: {
            args: Prisma.volunteersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.volunteersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$volunteersPayload>[]
          }
          delete: {
            args: Prisma.volunteersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$volunteersPayload>
          }
          update: {
            args: Prisma.volunteersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$volunteersPayload>
          }
          deleteMany: {
            args: Prisma.volunteersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.volunteersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.volunteersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$volunteersPayload>[]
          }
          upsert: {
            args: Prisma.volunteersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$volunteersPayload>
          }
          aggregate: {
            args: Prisma.VolunteersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVolunteers>
          }
          groupBy: {
            args: Prisma.volunteersGroupByArgs<ExtArgs>
            result: $Utils.Optional<VolunteersGroupByOutputType>[]
          }
          count: {
            args: Prisma.volunteersCountArgs<ExtArgs>
            result: $Utils.Optional<VolunteersCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    session?: SessionOmit
    project?: ProjectOmit
    blogs?: blogsOmit
    cache?: cacheOmit
    cache_locks?: cache_locksOmit
    contacts?: contactsOmit
    donations?: donationsOmit
    migrations?: migrationsOmit
    model_has_permissions?: model_has_permissionsOmit
    model_has_roles?: model_has_rolesOmit
    password_reset_tokens?: password_reset_tokensOmit
    permissions?: permissionsOmit
    personal_access_tokens?: personal_access_tokensOmit
    role_has_permissions?: role_has_permissionsOmit
    roles?: rolesOmit
    socialite_users?: socialite_usersOmit
    volunteers?: volunteersOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    blogs: number
    contacts: number
    donations: number
    volunteers: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blogs?: boolean | UserCountOutputTypeCountBlogsArgs
    contacts?: boolean | UserCountOutputTypeCountContactsArgs
    donations?: boolean | UserCountOutputTypeCountDonationsArgs
    volunteers?: boolean | UserCountOutputTypeCountVolunteersArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBlogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: blogsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contactsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDonationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: donationsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVolunteersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: volunteersWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    donations: number
    volunteers: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    donations?: boolean | ProjectCountOutputTypeCountDonationsArgs
    volunteers?: boolean | ProjectCountOutputTypeCountVolunteersArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountDonationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: donationsWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountVolunteersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: volunteersWhereInput
  }


  /**
   * Count Type PermissionsCountOutputType
   */

  export type PermissionsCountOutputType = {
    model_has_permissions: number
    role_has_permissions: number
  }

  export type PermissionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    model_has_permissions?: boolean | PermissionsCountOutputTypeCountModel_has_permissionsArgs
    role_has_permissions?: boolean | PermissionsCountOutputTypeCountRole_has_permissionsArgs
  }

  // Custom InputTypes
  /**
   * PermissionsCountOutputType without action
   */
  export type PermissionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionsCountOutputType
     */
    select?: PermissionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionsCountOutputType without action
   */
  export type PermissionsCountOutputTypeCountModel_has_permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: model_has_permissionsWhereInput
  }

  /**
   * PermissionsCountOutputType without action
   */
  export type PermissionsCountOutputTypeCountRole_has_permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: role_has_permissionsWhereInput
  }


  /**
   * Count Type RolesCountOutputType
   */

  export type RolesCountOutputType = {
    model_has_roles: number
    role_has_permissions: number
  }

  export type RolesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    model_has_roles?: boolean | RolesCountOutputTypeCountModel_has_rolesArgs
    role_has_permissions?: boolean | RolesCountOutputTypeCountRole_has_permissionsArgs
  }

  // Custom InputTypes
  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesCountOutputType
     */
    select?: RolesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeCountModel_has_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: model_has_rolesWhereInput
  }

  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeCountRole_has_permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: role_has_permissionsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: bigint | null
  }

  export type UserMinAggregateOutputType = {
    id: bigint | null
    name: string | null
    email: string | null
    email_verified_at: Date | null
    password: string | null
    remember_token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    must_change_password: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
    email: string | null
    email_verified_at: Date | null
    password: string | null
    remember_token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    must_change_password: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    email_verified_at: number
    password: number
    remember_token: number
    createdAt: number
    updatedAt: number
    accesses: number
    must_change_password: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    email_verified_at?: true
    password?: true
    remember_token?: true
    createdAt?: true
    updatedAt?: true
    must_change_password?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    email_verified_at?: true
    password?: true
    remember_token?: true
    createdAt?: true
    updatedAt?: true
    must_change_password?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    email_verified_at?: true
    password?: true
    remember_token?: true
    createdAt?: true
    updatedAt?: true
    accesses?: true
    must_change_password?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: bigint
    name: string
    email: string
    email_verified_at: Date | null
    password: string
    remember_token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    accesses: JsonValue | null
    must_change_password: boolean
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    email_verified_at?: boolean
    password?: boolean
    remember_token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accesses?: boolean
    must_change_password?: boolean
    blogs?: boolean | User$blogsArgs<ExtArgs>
    contacts?: boolean | User$contactsArgs<ExtArgs>
    donations?: boolean | User$donationsArgs<ExtArgs>
    volunteers?: boolean | User$volunteersArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    email_verified_at?: boolean
    password?: boolean
    remember_token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accesses?: boolean
    must_change_password?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    email_verified_at?: boolean
    password?: boolean
    remember_token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accesses?: boolean
    must_change_password?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    email_verified_at?: boolean
    password?: boolean
    remember_token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accesses?: boolean
    must_change_password?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "email_verified_at" | "password" | "remember_token" | "createdAt" | "updatedAt" | "accesses" | "must_change_password", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blogs?: boolean | User$blogsArgs<ExtArgs>
    contacts?: boolean | User$contactsArgs<ExtArgs>
    donations?: boolean | User$donationsArgs<ExtArgs>
    volunteers?: boolean | User$volunteersArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      blogs: Prisma.$blogsPayload<ExtArgs>[]
      contacts: Prisma.$contactsPayload<ExtArgs>[]
      donations: Prisma.$donationsPayload<ExtArgs>[]
      volunteers: Prisma.$volunteersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
      email: string
      email_verified_at: Date | null
      password: string
      remember_token: string | null
      createdAt: Date | null
      updatedAt: Date | null
      accesses: Prisma.JsonValue | null
      must_change_password: boolean
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    blogs<T extends User$blogsArgs<ExtArgs> = {}>(args?: Subset<T, User$blogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blogsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contacts<T extends User$contactsArgs<ExtArgs> = {}>(args?: Subset<T, User$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    donations<T extends User$donationsArgs<ExtArgs> = {}>(args?: Subset<T, User$donationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$donationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    volunteers<T extends User$volunteersArgs<ExtArgs> = {}>(args?: Subset<T, User$volunteersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$volunteersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'BigInt'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly email_verified_at: FieldRef<"User", 'DateTime'>
    readonly password: FieldRef<"User", 'String'>
    readonly remember_token: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly accesses: FieldRef<"User", 'Json'>
    readonly must_change_password: FieldRef<"User", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.blogs
   */
  export type User$blogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blogs
     */
    omit?: blogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blogsInclude<ExtArgs> | null
    where?: blogsWhereInput
    orderBy?: blogsOrderByWithRelationInput | blogsOrderByWithRelationInput[]
    cursor?: blogsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogsScalarFieldEnum | BlogsScalarFieldEnum[]
  }

  /**
   * User.contacts
   */
  export type User$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contacts
     */
    omit?: contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactsInclude<ExtArgs> | null
    where?: contactsWhereInput
    orderBy?: contactsOrderByWithRelationInput | contactsOrderByWithRelationInput[]
    cursor?: contactsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactsScalarFieldEnum | ContactsScalarFieldEnum[]
  }

  /**
   * User.donations
   */
  export type User$donationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donations
     */
    select?: donationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the donations
     */
    omit?: donationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: donationsInclude<ExtArgs> | null
    where?: donationsWhereInput
    orderBy?: donationsOrderByWithRelationInput | donationsOrderByWithRelationInput[]
    cursor?: donationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DonationsScalarFieldEnum | DonationsScalarFieldEnum[]
  }

  /**
   * User.volunteers
   */
  export type User$volunteersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the volunteers
     */
    select?: volunteersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the volunteers
     */
    omit?: volunteersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: volunteersInclude<ExtArgs> | null
    where?: volunteersWhereInput
    orderBy?: volunteersOrderByWithRelationInput | volunteersOrderByWithRelationInput[]
    cursor?: volunteersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VolunteersScalarFieldEnum | VolunteersScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionAvgAggregateOutputType = {
    userId: number | null
    last_activity: number | null
  }

  export type SessionSumAggregateOutputType = {
    userId: bigint | null
    last_activity: number | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: bigint | null
    ip_address: string | null
    user_agent: string | null
    payload: string | null
    last_activity: number | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: bigint | null
    ip_address: string | null
    user_agent: string | null
    payload: string | null
    last_activity: number | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    ip_address: number
    user_agent: number
    payload: number
    last_activity: number
    _all: number
  }


  export type SessionAvgAggregateInputType = {
    userId?: true
    last_activity?: true
  }

  export type SessionSumAggregateInputType = {
    userId?: true
    last_activity?: true
  }

  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    ip_address?: true
    user_agent?: true
    payload?: true
    last_activity?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    ip_address?: true
    user_agent?: true
    payload?: true
    last_activity?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    ip_address?: true
    user_agent?: true
    payload?: true
    last_activity?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _avg?: SessionAvgAggregateInputType
    _sum?: SessionSumAggregateInputType
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: bigint | null
    ip_address: string | null
    user_agent: string | null
    payload: string
    last_activity: number
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    ip_address?: boolean
    user_agent?: boolean
    payload?: boolean
    last_activity?: boolean
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    ip_address?: boolean
    user_agent?: boolean
    payload?: boolean
    last_activity?: boolean
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    ip_address?: boolean
    user_agent?: boolean
    payload?: boolean
    last_activity?: boolean
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    ip_address?: boolean
    user_agent?: boolean
    payload?: boolean
    last_activity?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "ip_address" | "user_agent" | "payload" | "last_activity", ExtArgs["result"]["session"]>

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: bigint | null
      ip_address: string | null
      user_agent: string | null
      payload: string
      last_activity: number
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'BigInt'>
    readonly ip_address: FieldRef<"Session", 'String'>
    readonly user_agent: FieldRef<"Session", 'String'>
    readonly payload: FieldRef<"Session", 'String'>
    readonly last_activity: FieldRef<"Session", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    id: number | null
    goalAmount: number | null
    raisedAmount: number | null
    studentsImpacted: number | null
    donorCount: number | null
    volunteerCount: number | null
  }

  export type ProjectSumAggregateOutputType = {
    id: bigint | null
    goalAmount: bigint | null
    raisedAmount: bigint | null
    studentsImpacted: number | null
    donorCount: number | null
    volunteerCount: number | null
  }

  export type ProjectMinAggregateOutputType = {
    id: bigint | null
    projectId: string | null
    url: string | null
    titleId: string | null
    titleEn: string | null
    descriptionId: string | null
    descriptionEn: string | null
    location: string | null
    goalAmount: bigint | null
    raisedAmount: bigint | null
    studentsImpacted: number | null
    image: string | null
    status: string | null
    featured: boolean | null
    category: string | null
    startDate: Date | null
    endDate: Date | null
    donorCount: number | null
    volunteerCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: bigint | null
    projectId: string | null
    url: string | null
    titleId: string | null
    titleEn: string | null
    descriptionId: string | null
    descriptionEn: string | null
    location: string | null
    goalAmount: bigint | null
    raisedAmount: bigint | null
    studentsImpacted: number | null
    image: string | null
    status: string | null
    featured: boolean | null
    category: string | null
    startDate: Date | null
    endDate: Date | null
    donorCount: number | null
    volunteerCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    projectId: number
    url: number
    titleId: number
    titleEn: number
    descriptionId: number
    descriptionEn: number
    location: number
    goalAmount: number
    raisedAmount: number
    studentsImpacted: number
    image: number
    status: number
    featured: number
    category: number
    startDate: number
    endDate: number
    school: number
    donorCount: number
    volunteerCount: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    id?: true
    goalAmount?: true
    raisedAmount?: true
    studentsImpacted?: true
    donorCount?: true
    volunteerCount?: true
  }

  export type ProjectSumAggregateInputType = {
    id?: true
    goalAmount?: true
    raisedAmount?: true
    studentsImpacted?: true
    donorCount?: true
    volunteerCount?: true
  }

  export type ProjectMinAggregateInputType = {
    id?: true
    projectId?: true
    url?: true
    titleId?: true
    titleEn?: true
    descriptionId?: true
    descriptionEn?: true
    location?: true
    goalAmount?: true
    raisedAmount?: true
    studentsImpacted?: true
    image?: true
    status?: true
    featured?: true
    category?: true
    startDate?: true
    endDate?: true
    donorCount?: true
    volunteerCount?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    projectId?: true
    url?: true
    titleId?: true
    titleEn?: true
    descriptionId?: true
    descriptionEn?: true
    location?: true
    goalAmount?: true
    raisedAmount?: true
    studentsImpacted?: true
    image?: true
    status?: true
    featured?: true
    category?: true
    startDate?: true
    endDate?: true
    donorCount?: true
    volunteerCount?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    projectId?: true
    url?: true
    titleId?: true
    titleEn?: true
    descriptionId?: true
    descriptionEn?: true
    location?: true
    goalAmount?: true
    raisedAmount?: true
    studentsImpacted?: true
    image?: true
    status?: true
    featured?: true
    category?: true
    startDate?: true
    endDate?: true
    school?: true
    donorCount?: true
    volunteerCount?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: bigint
    projectId: string
    url: string
    titleId: string
    titleEn: string
    descriptionId: string
    descriptionEn: string
    location: string
    goalAmount: bigint
    raisedAmount: bigint
    studentsImpacted: number
    image: string | null
    status: string
    featured: boolean
    category: string
    startDate: Date
    endDate: Date
    school: JsonValue
    donorCount: number
    volunteerCount: number
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    url?: boolean
    titleId?: boolean
    titleEn?: boolean
    descriptionId?: boolean
    descriptionEn?: boolean
    location?: boolean
    goalAmount?: boolean
    raisedAmount?: boolean
    studentsImpacted?: boolean
    image?: boolean
    status?: boolean
    featured?: boolean
    category?: boolean
    startDate?: boolean
    endDate?: boolean
    school?: boolean
    donorCount?: boolean
    volunteerCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    donations?: boolean | Project$donationsArgs<ExtArgs>
    volunteers?: boolean | Project$volunteersArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    url?: boolean
    titleId?: boolean
    titleEn?: boolean
    descriptionId?: boolean
    descriptionEn?: boolean
    location?: boolean
    goalAmount?: boolean
    raisedAmount?: boolean
    studentsImpacted?: boolean
    image?: boolean
    status?: boolean
    featured?: boolean
    category?: boolean
    startDate?: boolean
    endDate?: boolean
    school?: boolean
    donorCount?: boolean
    volunteerCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    url?: boolean
    titleId?: boolean
    titleEn?: boolean
    descriptionId?: boolean
    descriptionEn?: boolean
    location?: boolean
    goalAmount?: boolean
    raisedAmount?: boolean
    studentsImpacted?: boolean
    image?: boolean
    status?: boolean
    featured?: boolean
    category?: boolean
    startDate?: boolean
    endDate?: boolean
    school?: boolean
    donorCount?: boolean
    volunteerCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    projectId?: boolean
    url?: boolean
    titleId?: boolean
    titleEn?: boolean
    descriptionId?: boolean
    descriptionEn?: boolean
    location?: boolean
    goalAmount?: boolean
    raisedAmount?: boolean
    studentsImpacted?: boolean
    image?: boolean
    status?: boolean
    featured?: boolean
    category?: boolean
    startDate?: boolean
    endDate?: boolean
    school?: boolean
    donorCount?: boolean
    volunteerCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "url" | "titleId" | "titleEn" | "descriptionId" | "descriptionEn" | "location" | "goalAmount" | "raisedAmount" | "studentsImpacted" | "image" | "status" | "featured" | "category" | "startDate" | "endDate" | "school" | "donorCount" | "volunteerCount" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["project"]>
  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    donations?: boolean | Project$donationsArgs<ExtArgs>
    volunteers?: boolean | Project$volunteersArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      donations: Prisma.$donationsPayload<ExtArgs>[]
      volunteers: Prisma.$volunteersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      projectId: string
      url: string
      titleId: string
      titleEn: string
      descriptionId: string
      descriptionEn: string
      location: string
      goalAmount: bigint
      raisedAmount: bigint
      studentsImpacted: number
      image: string | null
      status: string
      featured: boolean
      category: string
      startDate: Date
      endDate: Date
      school: Prisma.JsonValue
      donorCount: number
      volunteerCount: number
      createdAt: Date | null
      updatedAt: Date | null
      deletedAt: Date | null
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects and returns the data updated in the database.
     * @param {ProjectUpdateManyAndReturnArgs} args - Arguments to update many Projects.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    donations<T extends Project$donationsArgs<ExtArgs> = {}>(args?: Subset<T, Project$donationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$donationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    volunteers<T extends Project$volunteersArgs<ExtArgs> = {}>(args?: Subset<T, Project$volunteersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$volunteersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'BigInt'>
    readonly projectId: FieldRef<"Project", 'String'>
    readonly url: FieldRef<"Project", 'String'>
    readonly titleId: FieldRef<"Project", 'String'>
    readonly titleEn: FieldRef<"Project", 'String'>
    readonly descriptionId: FieldRef<"Project", 'String'>
    readonly descriptionEn: FieldRef<"Project", 'String'>
    readonly location: FieldRef<"Project", 'String'>
    readonly goalAmount: FieldRef<"Project", 'BigInt'>
    readonly raisedAmount: FieldRef<"Project", 'BigInt'>
    readonly studentsImpacted: FieldRef<"Project", 'Int'>
    readonly image: FieldRef<"Project", 'String'>
    readonly status: FieldRef<"Project", 'String'>
    readonly featured: FieldRef<"Project", 'Boolean'>
    readonly category: FieldRef<"Project", 'String'>
    readonly startDate: FieldRef<"Project", 'DateTime'>
    readonly endDate: FieldRef<"Project", 'DateTime'>
    readonly school: FieldRef<"Project", 'Json'>
    readonly donorCount: FieldRef<"Project", 'Int'>
    readonly volunteerCount: FieldRef<"Project", 'Int'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
    readonly deletedAt: FieldRef<"Project", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Project updateManyAndReturn
   */
  export type ProjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to delete.
     */
    limit?: number
  }

  /**
   * Project.donations
   */
  export type Project$donationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donations
     */
    select?: donationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the donations
     */
    omit?: donationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: donationsInclude<ExtArgs> | null
    where?: donationsWhereInput
    orderBy?: donationsOrderByWithRelationInput | donationsOrderByWithRelationInput[]
    cursor?: donationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DonationsScalarFieldEnum | DonationsScalarFieldEnum[]
  }

  /**
   * Project.volunteers
   */
  export type Project$volunteersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the volunteers
     */
    select?: volunteersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the volunteers
     */
    omit?: volunteersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: volunteersInclude<ExtArgs> | null
    where?: volunteersWhereInput
    orderBy?: volunteersOrderByWithRelationInput | volunteersOrderByWithRelationInput[]
    cursor?: volunteersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VolunteersScalarFieldEnum | VolunteersScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model blogs
   */

  export type AggregateBlogs = {
    _count: BlogsCountAggregateOutputType | null
    _avg: BlogsAvgAggregateOutputType | null
    _sum: BlogsSumAggregateOutputType | null
    _min: BlogsMinAggregateOutputType | null
    _max: BlogsMaxAggregateOutputType | null
  }

  export type BlogsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    read_time: number | null
    views_count: number | null
  }

  export type BlogsSumAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    read_time: number | null
    views_count: bigint | null
  }

  export type BlogsMinAggregateOutputType = {
    id: bigint | null
    slug: string | null
    user_id: bigint | null
    title_id: string | null
    excerpt_id: string | null
    content_id: string | null
    title_en: string | null
    excerpt_en: string | null
    content_en: string | null
    author_name: string | null
    author_role: string | null
    author_avatar: string | null
    category: string | null
    image: string | null
    image_alt: string | null
    meta_title_id: string | null
    meta_description_id: string | null
    meta_title_en: string | null
    meta_description_en: string | null
    read_time: number | null
    views_count: bigint | null
    status: string | null
    featured: boolean | null
    published_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type BlogsMaxAggregateOutputType = {
    id: bigint | null
    slug: string | null
    user_id: bigint | null
    title_id: string | null
    excerpt_id: string | null
    content_id: string | null
    title_en: string | null
    excerpt_en: string | null
    content_en: string | null
    author_name: string | null
    author_role: string | null
    author_avatar: string | null
    category: string | null
    image: string | null
    image_alt: string | null
    meta_title_id: string | null
    meta_description_id: string | null
    meta_title_en: string | null
    meta_description_en: string | null
    read_time: number | null
    views_count: bigint | null
    status: string | null
    featured: boolean | null
    published_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type BlogsCountAggregateOutputType = {
    id: number
    slug: number
    user_id: number
    title_id: number
    excerpt_id: number
    content_id: number
    title_en: number
    excerpt_en: number
    content_en: number
    author_name: number
    author_role: number
    author_avatar: number
    category: number
    tags: number
    image: number
    image_alt: number
    meta_title_id: number
    meta_description_id: number
    meta_title_en: number
    meta_description_en: number
    read_time: number
    views_count: number
    status: number
    featured: number
    published_at: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type BlogsAvgAggregateInputType = {
    id?: true
    user_id?: true
    read_time?: true
    views_count?: true
  }

  export type BlogsSumAggregateInputType = {
    id?: true
    user_id?: true
    read_time?: true
    views_count?: true
  }

  export type BlogsMinAggregateInputType = {
    id?: true
    slug?: true
    user_id?: true
    title_id?: true
    excerpt_id?: true
    content_id?: true
    title_en?: true
    excerpt_en?: true
    content_en?: true
    author_name?: true
    author_role?: true
    author_avatar?: true
    category?: true
    image?: true
    image_alt?: true
    meta_title_id?: true
    meta_description_id?: true
    meta_title_en?: true
    meta_description_en?: true
    read_time?: true
    views_count?: true
    status?: true
    featured?: true
    published_at?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type BlogsMaxAggregateInputType = {
    id?: true
    slug?: true
    user_id?: true
    title_id?: true
    excerpt_id?: true
    content_id?: true
    title_en?: true
    excerpt_en?: true
    content_en?: true
    author_name?: true
    author_role?: true
    author_avatar?: true
    category?: true
    image?: true
    image_alt?: true
    meta_title_id?: true
    meta_description_id?: true
    meta_title_en?: true
    meta_description_en?: true
    read_time?: true
    views_count?: true
    status?: true
    featured?: true
    published_at?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type BlogsCountAggregateInputType = {
    id?: true
    slug?: true
    user_id?: true
    title_id?: true
    excerpt_id?: true
    content_id?: true
    title_en?: true
    excerpt_en?: true
    content_en?: true
    author_name?: true
    author_role?: true
    author_avatar?: true
    category?: true
    tags?: true
    image?: true
    image_alt?: true
    meta_title_id?: true
    meta_description_id?: true
    meta_title_en?: true
    meta_description_en?: true
    read_time?: true
    views_count?: true
    status?: true
    featured?: true
    published_at?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type BlogsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which blogs to aggregate.
     */
    where?: blogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blogs to fetch.
     */
    orderBy?: blogsOrderByWithRelationInput | blogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: blogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned blogs
    **/
    _count?: true | BlogsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlogsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlogsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogsMaxAggregateInputType
  }

  export type GetBlogsAggregateType<T extends BlogsAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogs[P]>
      : GetScalarType<T[P], AggregateBlogs[P]>
  }




  export type blogsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: blogsWhereInput
    orderBy?: blogsOrderByWithAggregationInput | blogsOrderByWithAggregationInput[]
    by: BlogsScalarFieldEnum[] | BlogsScalarFieldEnum
    having?: blogsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogsCountAggregateInputType | true
    _avg?: BlogsAvgAggregateInputType
    _sum?: BlogsSumAggregateInputType
    _min?: BlogsMinAggregateInputType
    _max?: BlogsMaxAggregateInputType
  }

  export type BlogsGroupByOutputType = {
    id: bigint
    slug: string
    user_id: bigint | null
    title_id: string
    excerpt_id: string
    content_id: string
    title_en: string
    excerpt_en: string
    content_en: string
    author_name: string
    author_role: string | null
    author_avatar: string | null
    category: string
    tags: JsonValue | null
    image: string | null
    image_alt: string | null
    meta_title_id: string | null
    meta_description_id: string | null
    meta_title_en: string | null
    meta_description_en: string | null
    read_time: number
    views_count: bigint
    status: string
    featured: boolean
    published_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    _count: BlogsCountAggregateOutputType | null
    _avg: BlogsAvgAggregateOutputType | null
    _sum: BlogsSumAggregateOutputType | null
    _min: BlogsMinAggregateOutputType | null
    _max: BlogsMaxAggregateOutputType | null
  }

  type GetBlogsGroupByPayload<T extends blogsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogsGroupByOutputType[P]>
            : GetScalarType<T[P], BlogsGroupByOutputType[P]>
        }
      >
    >


  export type blogsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    user_id?: boolean
    title_id?: boolean
    excerpt_id?: boolean
    content_id?: boolean
    title_en?: boolean
    excerpt_en?: boolean
    content_en?: boolean
    author_name?: boolean
    author_role?: boolean
    author_avatar?: boolean
    category?: boolean
    tags?: boolean
    image?: boolean
    image_alt?: boolean
    meta_title_id?: boolean
    meta_description_id?: boolean
    meta_title_en?: boolean
    meta_description_en?: boolean
    read_time?: boolean
    views_count?: boolean
    status?: boolean
    featured?: boolean
    published_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    users?: boolean | blogs$usersArgs<ExtArgs>
  }, ExtArgs["result"]["blogs"]>

  export type blogsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    user_id?: boolean
    title_id?: boolean
    excerpt_id?: boolean
    content_id?: boolean
    title_en?: boolean
    excerpt_en?: boolean
    content_en?: boolean
    author_name?: boolean
    author_role?: boolean
    author_avatar?: boolean
    category?: boolean
    tags?: boolean
    image?: boolean
    image_alt?: boolean
    meta_title_id?: boolean
    meta_description_id?: boolean
    meta_title_en?: boolean
    meta_description_en?: boolean
    read_time?: boolean
    views_count?: boolean
    status?: boolean
    featured?: boolean
    published_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    users?: boolean | blogs$usersArgs<ExtArgs>
  }, ExtArgs["result"]["blogs"]>

  export type blogsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    user_id?: boolean
    title_id?: boolean
    excerpt_id?: boolean
    content_id?: boolean
    title_en?: boolean
    excerpt_en?: boolean
    content_en?: boolean
    author_name?: boolean
    author_role?: boolean
    author_avatar?: boolean
    category?: boolean
    tags?: boolean
    image?: boolean
    image_alt?: boolean
    meta_title_id?: boolean
    meta_description_id?: boolean
    meta_title_en?: boolean
    meta_description_en?: boolean
    read_time?: boolean
    views_count?: boolean
    status?: boolean
    featured?: boolean
    published_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    users?: boolean | blogs$usersArgs<ExtArgs>
  }, ExtArgs["result"]["blogs"]>

  export type blogsSelectScalar = {
    id?: boolean
    slug?: boolean
    user_id?: boolean
    title_id?: boolean
    excerpt_id?: boolean
    content_id?: boolean
    title_en?: boolean
    excerpt_en?: boolean
    content_en?: boolean
    author_name?: boolean
    author_role?: boolean
    author_avatar?: boolean
    category?: boolean
    tags?: boolean
    image?: boolean
    image_alt?: boolean
    meta_title_id?: boolean
    meta_description_id?: boolean
    meta_title_en?: boolean
    meta_description_en?: boolean
    read_time?: boolean
    views_count?: boolean
    status?: boolean
    featured?: boolean
    published_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type blogsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "user_id" | "title_id" | "excerpt_id" | "content_id" | "title_en" | "excerpt_en" | "content_en" | "author_name" | "author_role" | "author_avatar" | "category" | "tags" | "image" | "image_alt" | "meta_title_id" | "meta_description_id" | "meta_title_en" | "meta_description_en" | "read_time" | "views_count" | "status" | "featured" | "published_at" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["blogs"]>
  export type blogsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | blogs$usersArgs<ExtArgs>
  }
  export type blogsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | blogs$usersArgs<ExtArgs>
  }
  export type blogsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | blogs$usersArgs<ExtArgs>
  }

  export type $blogsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "blogs"
    objects: {
      users: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      slug: string
      user_id: bigint | null
      title_id: string
      excerpt_id: string
      content_id: string
      title_en: string
      excerpt_en: string
      content_en: string
      author_name: string
      author_role: string | null
      author_avatar: string | null
      category: string
      tags: Prisma.JsonValue | null
      image: string | null
      image_alt: string | null
      meta_title_id: string | null
      meta_description_id: string | null
      meta_title_en: string | null
      meta_description_en: string | null
      read_time: number
      views_count: bigint
      status: string
      featured: boolean
      published_at: Date | null
      created_at: Date | null
      updated_at: Date | null
      deleted_at: Date | null
    }, ExtArgs["result"]["blogs"]>
    composites: {}
  }

  type blogsGetPayload<S extends boolean | null | undefined | blogsDefaultArgs> = $Result.GetResult<Prisma.$blogsPayload, S>

  type blogsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<blogsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlogsCountAggregateInputType | true
    }

  export interface blogsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['blogs'], meta: { name: 'blogs' } }
    /**
     * Find zero or one Blogs that matches the filter.
     * @param {blogsFindUniqueArgs} args - Arguments to find a Blogs
     * @example
     * // Get one Blogs
     * const blogs = await prisma.blogs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends blogsFindUniqueArgs>(args: SelectSubset<T, blogsFindUniqueArgs<ExtArgs>>): Prisma__blogsClient<$Result.GetResult<Prisma.$blogsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Blogs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {blogsFindUniqueOrThrowArgs} args - Arguments to find a Blogs
     * @example
     * // Get one Blogs
     * const blogs = await prisma.blogs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends blogsFindUniqueOrThrowArgs>(args: SelectSubset<T, blogsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__blogsClient<$Result.GetResult<Prisma.$blogsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blogsFindFirstArgs} args - Arguments to find a Blogs
     * @example
     * // Get one Blogs
     * const blogs = await prisma.blogs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends blogsFindFirstArgs>(args?: SelectSubset<T, blogsFindFirstArgs<ExtArgs>>): Prisma__blogsClient<$Result.GetResult<Prisma.$blogsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blogs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blogsFindFirstOrThrowArgs} args - Arguments to find a Blogs
     * @example
     * // Get one Blogs
     * const blogs = await prisma.blogs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends blogsFindFirstOrThrowArgs>(args?: SelectSubset<T, blogsFindFirstOrThrowArgs<ExtArgs>>): Prisma__blogsClient<$Result.GetResult<Prisma.$blogsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Blogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blogsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blogs
     * const blogs = await prisma.blogs.findMany()
     * 
     * // Get first 10 Blogs
     * const blogs = await prisma.blogs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogsWithIdOnly = await prisma.blogs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends blogsFindManyArgs>(args?: SelectSubset<T, blogsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blogsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Blogs.
     * @param {blogsCreateArgs} args - Arguments to create a Blogs.
     * @example
     * // Create one Blogs
     * const Blogs = await prisma.blogs.create({
     *   data: {
     *     // ... data to create a Blogs
     *   }
     * })
     * 
     */
    create<T extends blogsCreateArgs>(args: SelectSubset<T, blogsCreateArgs<ExtArgs>>): Prisma__blogsClient<$Result.GetResult<Prisma.$blogsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Blogs.
     * @param {blogsCreateManyArgs} args - Arguments to create many Blogs.
     * @example
     * // Create many Blogs
     * const blogs = await prisma.blogs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends blogsCreateManyArgs>(args?: SelectSubset<T, blogsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Blogs and returns the data saved in the database.
     * @param {blogsCreateManyAndReturnArgs} args - Arguments to create many Blogs.
     * @example
     * // Create many Blogs
     * const blogs = await prisma.blogs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Blogs and only return the `id`
     * const blogsWithIdOnly = await prisma.blogs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends blogsCreateManyAndReturnArgs>(args?: SelectSubset<T, blogsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blogsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Blogs.
     * @param {blogsDeleteArgs} args - Arguments to delete one Blogs.
     * @example
     * // Delete one Blogs
     * const Blogs = await prisma.blogs.delete({
     *   where: {
     *     // ... filter to delete one Blogs
     *   }
     * })
     * 
     */
    delete<T extends blogsDeleteArgs>(args: SelectSubset<T, blogsDeleteArgs<ExtArgs>>): Prisma__blogsClient<$Result.GetResult<Prisma.$blogsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Blogs.
     * @param {blogsUpdateArgs} args - Arguments to update one Blogs.
     * @example
     * // Update one Blogs
     * const blogs = await prisma.blogs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends blogsUpdateArgs>(args: SelectSubset<T, blogsUpdateArgs<ExtArgs>>): Prisma__blogsClient<$Result.GetResult<Prisma.$blogsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Blogs.
     * @param {blogsDeleteManyArgs} args - Arguments to filter Blogs to delete.
     * @example
     * // Delete a few Blogs
     * const { count } = await prisma.blogs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends blogsDeleteManyArgs>(args?: SelectSubset<T, blogsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blogsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blogs
     * const blogs = await prisma.blogs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends blogsUpdateManyArgs>(args: SelectSubset<T, blogsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blogs and returns the data updated in the database.
     * @param {blogsUpdateManyAndReturnArgs} args - Arguments to update many Blogs.
     * @example
     * // Update many Blogs
     * const blogs = await prisma.blogs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Blogs and only return the `id`
     * const blogsWithIdOnly = await prisma.blogs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends blogsUpdateManyAndReturnArgs>(args: SelectSubset<T, blogsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blogsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Blogs.
     * @param {blogsUpsertArgs} args - Arguments to update or create a Blogs.
     * @example
     * // Update or create a Blogs
     * const blogs = await prisma.blogs.upsert({
     *   create: {
     *     // ... data to create a Blogs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Blogs we want to update
     *   }
     * })
     */
    upsert<T extends blogsUpsertArgs>(args: SelectSubset<T, blogsUpsertArgs<ExtArgs>>): Prisma__blogsClient<$Result.GetResult<Prisma.$blogsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blogsCountArgs} args - Arguments to filter Blogs to count.
     * @example
     * // Count the number of Blogs
     * const count = await prisma.blogs.count({
     *   where: {
     *     // ... the filter for the Blogs we want to count
     *   }
     * })
    **/
    count<T extends blogsCountArgs>(
      args?: Subset<T, blogsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogsAggregateArgs>(args: Subset<T, BlogsAggregateArgs>): Prisma.PrismaPromise<GetBlogsAggregateType<T>>

    /**
     * Group by Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blogsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends blogsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: blogsGroupByArgs['orderBy'] }
        : { orderBy?: blogsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, blogsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the blogs model
   */
  readonly fields: blogsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for blogs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__blogsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends blogs$usersArgs<ExtArgs> = {}>(args?: Subset<T, blogs$usersArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the blogs model
   */
  interface blogsFieldRefs {
    readonly id: FieldRef<"blogs", 'BigInt'>
    readonly slug: FieldRef<"blogs", 'String'>
    readonly user_id: FieldRef<"blogs", 'BigInt'>
    readonly title_id: FieldRef<"blogs", 'String'>
    readonly excerpt_id: FieldRef<"blogs", 'String'>
    readonly content_id: FieldRef<"blogs", 'String'>
    readonly title_en: FieldRef<"blogs", 'String'>
    readonly excerpt_en: FieldRef<"blogs", 'String'>
    readonly content_en: FieldRef<"blogs", 'String'>
    readonly author_name: FieldRef<"blogs", 'String'>
    readonly author_role: FieldRef<"blogs", 'String'>
    readonly author_avatar: FieldRef<"blogs", 'String'>
    readonly category: FieldRef<"blogs", 'String'>
    readonly tags: FieldRef<"blogs", 'Json'>
    readonly image: FieldRef<"blogs", 'String'>
    readonly image_alt: FieldRef<"blogs", 'String'>
    readonly meta_title_id: FieldRef<"blogs", 'String'>
    readonly meta_description_id: FieldRef<"blogs", 'String'>
    readonly meta_title_en: FieldRef<"blogs", 'String'>
    readonly meta_description_en: FieldRef<"blogs", 'String'>
    readonly read_time: FieldRef<"blogs", 'Int'>
    readonly views_count: FieldRef<"blogs", 'BigInt'>
    readonly status: FieldRef<"blogs", 'String'>
    readonly featured: FieldRef<"blogs", 'Boolean'>
    readonly published_at: FieldRef<"blogs", 'DateTime'>
    readonly created_at: FieldRef<"blogs", 'DateTime'>
    readonly updated_at: FieldRef<"blogs", 'DateTime'>
    readonly deleted_at: FieldRef<"blogs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * blogs findUnique
   */
  export type blogsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blogs
     */
    omit?: blogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blogsInclude<ExtArgs> | null
    /**
     * Filter, which blogs to fetch.
     */
    where: blogsWhereUniqueInput
  }

  /**
   * blogs findUniqueOrThrow
   */
  export type blogsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blogs
     */
    omit?: blogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blogsInclude<ExtArgs> | null
    /**
     * Filter, which blogs to fetch.
     */
    where: blogsWhereUniqueInput
  }

  /**
   * blogs findFirst
   */
  export type blogsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blogs
     */
    omit?: blogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blogsInclude<ExtArgs> | null
    /**
     * Filter, which blogs to fetch.
     */
    where?: blogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blogs to fetch.
     */
    orderBy?: blogsOrderByWithRelationInput | blogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blogs.
     */
    cursor?: blogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blogs.
     */
    distinct?: BlogsScalarFieldEnum | BlogsScalarFieldEnum[]
  }

  /**
   * blogs findFirstOrThrow
   */
  export type blogsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blogs
     */
    omit?: blogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blogsInclude<ExtArgs> | null
    /**
     * Filter, which blogs to fetch.
     */
    where?: blogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blogs to fetch.
     */
    orderBy?: blogsOrderByWithRelationInput | blogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blogs.
     */
    cursor?: blogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blogs.
     */
    distinct?: BlogsScalarFieldEnum | BlogsScalarFieldEnum[]
  }

  /**
   * blogs findMany
   */
  export type blogsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blogs
     */
    omit?: blogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blogsInclude<ExtArgs> | null
    /**
     * Filter, which blogs to fetch.
     */
    where?: blogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blogs to fetch.
     */
    orderBy?: blogsOrderByWithRelationInput | blogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing blogs.
     */
    cursor?: blogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blogs.
     */
    skip?: number
    distinct?: BlogsScalarFieldEnum | BlogsScalarFieldEnum[]
  }

  /**
   * blogs create
   */
  export type blogsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blogs
     */
    omit?: blogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blogsInclude<ExtArgs> | null
    /**
     * The data needed to create a blogs.
     */
    data: XOR<blogsCreateInput, blogsUncheckedCreateInput>
  }

  /**
   * blogs createMany
   */
  export type blogsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many blogs.
     */
    data: blogsCreateManyInput | blogsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * blogs createManyAndReturn
   */
  export type blogsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the blogs
     */
    omit?: blogsOmit<ExtArgs> | null
    /**
     * The data used to create many blogs.
     */
    data: blogsCreateManyInput | blogsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blogsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * blogs update
   */
  export type blogsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blogs
     */
    omit?: blogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blogsInclude<ExtArgs> | null
    /**
     * The data needed to update a blogs.
     */
    data: XOR<blogsUpdateInput, blogsUncheckedUpdateInput>
    /**
     * Choose, which blogs to update.
     */
    where: blogsWhereUniqueInput
  }

  /**
   * blogs updateMany
   */
  export type blogsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update blogs.
     */
    data: XOR<blogsUpdateManyMutationInput, blogsUncheckedUpdateManyInput>
    /**
     * Filter which blogs to update
     */
    where?: blogsWhereInput
    /**
     * Limit how many blogs to update.
     */
    limit?: number
  }

  /**
   * blogs updateManyAndReturn
   */
  export type blogsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the blogs
     */
    omit?: blogsOmit<ExtArgs> | null
    /**
     * The data used to update blogs.
     */
    data: XOR<blogsUpdateManyMutationInput, blogsUncheckedUpdateManyInput>
    /**
     * Filter which blogs to update
     */
    where?: blogsWhereInput
    /**
     * Limit how many blogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blogsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * blogs upsert
   */
  export type blogsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blogs
     */
    omit?: blogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blogsInclude<ExtArgs> | null
    /**
     * The filter to search for the blogs to update in case it exists.
     */
    where: blogsWhereUniqueInput
    /**
     * In case the blogs found by the `where` argument doesn't exist, create a new blogs with this data.
     */
    create: XOR<blogsCreateInput, blogsUncheckedCreateInput>
    /**
     * In case the blogs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<blogsUpdateInput, blogsUncheckedUpdateInput>
  }

  /**
   * blogs delete
   */
  export type blogsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blogs
     */
    omit?: blogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blogsInclude<ExtArgs> | null
    /**
     * Filter which blogs to delete.
     */
    where: blogsWhereUniqueInput
  }

  /**
   * blogs deleteMany
   */
  export type blogsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which blogs to delete
     */
    where?: blogsWhereInput
    /**
     * Limit how many blogs to delete.
     */
    limit?: number
  }

  /**
   * blogs.users
   */
  export type blogs$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * blogs without action
   */
  export type blogsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blogs
     */
    omit?: blogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blogsInclude<ExtArgs> | null
  }


  /**
   * Model cache
   */

  export type AggregateCache = {
    _count: CacheCountAggregateOutputType | null
    _avg: CacheAvgAggregateOutputType | null
    _sum: CacheSumAggregateOutputType | null
    _min: CacheMinAggregateOutputType | null
    _max: CacheMaxAggregateOutputType | null
  }

  export type CacheAvgAggregateOutputType = {
    expiration: number | null
  }

  export type CacheSumAggregateOutputType = {
    expiration: number | null
  }

  export type CacheMinAggregateOutputType = {
    key: string | null
    value: string | null
    expiration: number | null
  }

  export type CacheMaxAggregateOutputType = {
    key: string | null
    value: string | null
    expiration: number | null
  }

  export type CacheCountAggregateOutputType = {
    key: number
    value: number
    expiration: number
    _all: number
  }


  export type CacheAvgAggregateInputType = {
    expiration?: true
  }

  export type CacheSumAggregateInputType = {
    expiration?: true
  }

  export type CacheMinAggregateInputType = {
    key?: true
    value?: true
    expiration?: true
  }

  export type CacheMaxAggregateInputType = {
    key?: true
    value?: true
    expiration?: true
  }

  export type CacheCountAggregateInputType = {
    key?: true
    value?: true
    expiration?: true
    _all?: true
  }

  export type CacheAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cache to aggregate.
     */
    where?: cacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caches to fetch.
     */
    orderBy?: cacheOrderByWithRelationInput | cacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned caches
    **/
    _count?: true | CacheCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CacheAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CacheSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CacheMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CacheMaxAggregateInputType
  }

  export type GetCacheAggregateType<T extends CacheAggregateArgs> = {
        [P in keyof T & keyof AggregateCache]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCache[P]>
      : GetScalarType<T[P], AggregateCache[P]>
  }




  export type cacheGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cacheWhereInput
    orderBy?: cacheOrderByWithAggregationInput | cacheOrderByWithAggregationInput[]
    by: CacheScalarFieldEnum[] | CacheScalarFieldEnum
    having?: cacheScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CacheCountAggregateInputType | true
    _avg?: CacheAvgAggregateInputType
    _sum?: CacheSumAggregateInputType
    _min?: CacheMinAggregateInputType
    _max?: CacheMaxAggregateInputType
  }

  export type CacheGroupByOutputType = {
    key: string
    value: string
    expiration: number
    _count: CacheCountAggregateOutputType | null
    _avg: CacheAvgAggregateOutputType | null
    _sum: CacheSumAggregateOutputType | null
    _min: CacheMinAggregateOutputType | null
    _max: CacheMaxAggregateOutputType | null
  }

  type GetCacheGroupByPayload<T extends cacheGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CacheGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CacheGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CacheGroupByOutputType[P]>
            : GetScalarType<T[P], CacheGroupByOutputType[P]>
        }
      >
    >


  export type cacheSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
    expiration?: boolean
  }, ExtArgs["result"]["cache"]>

  export type cacheSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
    expiration?: boolean
  }, ExtArgs["result"]["cache"]>

  export type cacheSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
    expiration?: boolean
  }, ExtArgs["result"]["cache"]>

  export type cacheSelectScalar = {
    key?: boolean
    value?: boolean
    expiration?: boolean
  }

  export type cacheOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"key" | "value" | "expiration", ExtArgs["result"]["cache"]>

  export type $cachePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cache"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      key: string
      value: string
      expiration: number
    }, ExtArgs["result"]["cache"]>
    composites: {}
  }

  type cacheGetPayload<S extends boolean | null | undefined | cacheDefaultArgs> = $Result.GetResult<Prisma.$cachePayload, S>

  type cacheCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<cacheFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CacheCountAggregateInputType | true
    }

  export interface cacheDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cache'], meta: { name: 'cache' } }
    /**
     * Find zero or one Cache that matches the filter.
     * @param {cacheFindUniqueArgs} args - Arguments to find a Cache
     * @example
     * // Get one Cache
     * const cache = await prisma.cache.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cacheFindUniqueArgs>(args: SelectSubset<T, cacheFindUniqueArgs<ExtArgs>>): Prisma__cacheClient<$Result.GetResult<Prisma.$cachePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cache that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {cacheFindUniqueOrThrowArgs} args - Arguments to find a Cache
     * @example
     * // Get one Cache
     * const cache = await prisma.cache.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cacheFindUniqueOrThrowArgs>(args: SelectSubset<T, cacheFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cacheClient<$Result.GetResult<Prisma.$cachePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cache that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cacheFindFirstArgs} args - Arguments to find a Cache
     * @example
     * // Get one Cache
     * const cache = await prisma.cache.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cacheFindFirstArgs>(args?: SelectSubset<T, cacheFindFirstArgs<ExtArgs>>): Prisma__cacheClient<$Result.GetResult<Prisma.$cachePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cache that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cacheFindFirstOrThrowArgs} args - Arguments to find a Cache
     * @example
     * // Get one Cache
     * const cache = await prisma.cache.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cacheFindFirstOrThrowArgs>(args?: SelectSubset<T, cacheFindFirstOrThrowArgs<ExtArgs>>): Prisma__cacheClient<$Result.GetResult<Prisma.$cachePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Caches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cacheFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Caches
     * const caches = await prisma.cache.findMany()
     * 
     * // Get first 10 Caches
     * const caches = await prisma.cache.findMany({ take: 10 })
     * 
     * // Only select the `key`
     * const cacheWithKeyOnly = await prisma.cache.findMany({ select: { key: true } })
     * 
     */
    findMany<T extends cacheFindManyArgs>(args?: SelectSubset<T, cacheFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cachePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cache.
     * @param {cacheCreateArgs} args - Arguments to create a Cache.
     * @example
     * // Create one Cache
     * const Cache = await prisma.cache.create({
     *   data: {
     *     // ... data to create a Cache
     *   }
     * })
     * 
     */
    create<T extends cacheCreateArgs>(args: SelectSubset<T, cacheCreateArgs<ExtArgs>>): Prisma__cacheClient<$Result.GetResult<Prisma.$cachePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Caches.
     * @param {cacheCreateManyArgs} args - Arguments to create many Caches.
     * @example
     * // Create many Caches
     * const cache = await prisma.cache.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cacheCreateManyArgs>(args?: SelectSubset<T, cacheCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Caches and returns the data saved in the database.
     * @param {cacheCreateManyAndReturnArgs} args - Arguments to create many Caches.
     * @example
     * // Create many Caches
     * const cache = await prisma.cache.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Caches and only return the `key`
     * const cacheWithKeyOnly = await prisma.cache.createManyAndReturn({
     *   select: { key: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends cacheCreateManyAndReturnArgs>(args?: SelectSubset<T, cacheCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cachePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cache.
     * @param {cacheDeleteArgs} args - Arguments to delete one Cache.
     * @example
     * // Delete one Cache
     * const Cache = await prisma.cache.delete({
     *   where: {
     *     // ... filter to delete one Cache
     *   }
     * })
     * 
     */
    delete<T extends cacheDeleteArgs>(args: SelectSubset<T, cacheDeleteArgs<ExtArgs>>): Prisma__cacheClient<$Result.GetResult<Prisma.$cachePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cache.
     * @param {cacheUpdateArgs} args - Arguments to update one Cache.
     * @example
     * // Update one Cache
     * const cache = await prisma.cache.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cacheUpdateArgs>(args: SelectSubset<T, cacheUpdateArgs<ExtArgs>>): Prisma__cacheClient<$Result.GetResult<Prisma.$cachePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Caches.
     * @param {cacheDeleteManyArgs} args - Arguments to filter Caches to delete.
     * @example
     * // Delete a few Caches
     * const { count } = await prisma.cache.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cacheDeleteManyArgs>(args?: SelectSubset<T, cacheDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Caches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cacheUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Caches
     * const cache = await prisma.cache.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cacheUpdateManyArgs>(args: SelectSubset<T, cacheUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Caches and returns the data updated in the database.
     * @param {cacheUpdateManyAndReturnArgs} args - Arguments to update many Caches.
     * @example
     * // Update many Caches
     * const cache = await prisma.cache.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Caches and only return the `key`
     * const cacheWithKeyOnly = await prisma.cache.updateManyAndReturn({
     *   select: { key: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends cacheUpdateManyAndReturnArgs>(args: SelectSubset<T, cacheUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cachePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cache.
     * @param {cacheUpsertArgs} args - Arguments to update or create a Cache.
     * @example
     * // Update or create a Cache
     * const cache = await prisma.cache.upsert({
     *   create: {
     *     // ... data to create a Cache
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cache we want to update
     *   }
     * })
     */
    upsert<T extends cacheUpsertArgs>(args: SelectSubset<T, cacheUpsertArgs<ExtArgs>>): Prisma__cacheClient<$Result.GetResult<Prisma.$cachePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Caches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cacheCountArgs} args - Arguments to filter Caches to count.
     * @example
     * // Count the number of Caches
     * const count = await prisma.cache.count({
     *   where: {
     *     // ... the filter for the Caches we want to count
     *   }
     * })
    **/
    count<T extends cacheCountArgs>(
      args?: Subset<T, cacheCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CacheCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CacheAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CacheAggregateArgs>(args: Subset<T, CacheAggregateArgs>): Prisma.PrismaPromise<GetCacheAggregateType<T>>

    /**
     * Group by Cache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cacheGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cacheGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cacheGroupByArgs['orderBy'] }
        : { orderBy?: cacheGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cacheGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCacheGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cache model
   */
  readonly fields: cacheFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cache.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cacheClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cache model
   */
  interface cacheFieldRefs {
    readonly key: FieldRef<"cache", 'String'>
    readonly value: FieldRef<"cache", 'String'>
    readonly expiration: FieldRef<"cache", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * cache findUnique
   */
  export type cacheFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
    /**
     * Filter, which cache to fetch.
     */
    where: cacheWhereUniqueInput
  }

  /**
   * cache findUniqueOrThrow
   */
  export type cacheFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
    /**
     * Filter, which cache to fetch.
     */
    where: cacheWhereUniqueInput
  }

  /**
   * cache findFirst
   */
  export type cacheFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
    /**
     * Filter, which cache to fetch.
     */
    where?: cacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caches to fetch.
     */
    orderBy?: cacheOrderByWithRelationInput | cacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for caches.
     */
    cursor?: cacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of caches.
     */
    distinct?: CacheScalarFieldEnum | CacheScalarFieldEnum[]
  }

  /**
   * cache findFirstOrThrow
   */
  export type cacheFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
    /**
     * Filter, which cache to fetch.
     */
    where?: cacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caches to fetch.
     */
    orderBy?: cacheOrderByWithRelationInput | cacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for caches.
     */
    cursor?: cacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of caches.
     */
    distinct?: CacheScalarFieldEnum | CacheScalarFieldEnum[]
  }

  /**
   * cache findMany
   */
  export type cacheFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
    /**
     * Filter, which caches to fetch.
     */
    where?: cacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caches to fetch.
     */
    orderBy?: cacheOrderByWithRelationInput | cacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing caches.
     */
    cursor?: cacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caches.
     */
    skip?: number
    distinct?: CacheScalarFieldEnum | CacheScalarFieldEnum[]
  }

  /**
   * cache create
   */
  export type cacheCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
    /**
     * The data needed to create a cache.
     */
    data: XOR<cacheCreateInput, cacheUncheckedCreateInput>
  }

  /**
   * cache createMany
   */
  export type cacheCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many caches.
     */
    data: cacheCreateManyInput | cacheCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cache createManyAndReturn
   */
  export type cacheCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
    /**
     * The data used to create many caches.
     */
    data: cacheCreateManyInput | cacheCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cache update
   */
  export type cacheUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
    /**
     * The data needed to update a cache.
     */
    data: XOR<cacheUpdateInput, cacheUncheckedUpdateInput>
    /**
     * Choose, which cache to update.
     */
    where: cacheWhereUniqueInput
  }

  /**
   * cache updateMany
   */
  export type cacheUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update caches.
     */
    data: XOR<cacheUpdateManyMutationInput, cacheUncheckedUpdateManyInput>
    /**
     * Filter which caches to update
     */
    where?: cacheWhereInput
    /**
     * Limit how many caches to update.
     */
    limit?: number
  }

  /**
   * cache updateManyAndReturn
   */
  export type cacheUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
    /**
     * The data used to update caches.
     */
    data: XOR<cacheUpdateManyMutationInput, cacheUncheckedUpdateManyInput>
    /**
     * Filter which caches to update
     */
    where?: cacheWhereInput
    /**
     * Limit how many caches to update.
     */
    limit?: number
  }

  /**
   * cache upsert
   */
  export type cacheUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
    /**
     * The filter to search for the cache to update in case it exists.
     */
    where: cacheWhereUniqueInput
    /**
     * In case the cache found by the `where` argument doesn't exist, create a new cache with this data.
     */
    create: XOR<cacheCreateInput, cacheUncheckedCreateInput>
    /**
     * In case the cache was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cacheUpdateInput, cacheUncheckedUpdateInput>
  }

  /**
   * cache delete
   */
  export type cacheDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
    /**
     * Filter which cache to delete.
     */
    where: cacheWhereUniqueInput
  }

  /**
   * cache deleteMany
   */
  export type cacheDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which caches to delete
     */
    where?: cacheWhereInput
    /**
     * Limit how many caches to delete.
     */
    limit?: number
  }

  /**
   * cache without action
   */
  export type cacheDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
  }


  /**
   * Model cache_locks
   */

  export type AggregateCache_locks = {
    _count: Cache_locksCountAggregateOutputType | null
    _avg: Cache_locksAvgAggregateOutputType | null
    _sum: Cache_locksSumAggregateOutputType | null
    _min: Cache_locksMinAggregateOutputType | null
    _max: Cache_locksMaxAggregateOutputType | null
  }

  export type Cache_locksAvgAggregateOutputType = {
    expiration: number | null
  }

  export type Cache_locksSumAggregateOutputType = {
    expiration: number | null
  }

  export type Cache_locksMinAggregateOutputType = {
    key: string | null
    owner: string | null
    expiration: number | null
  }

  export type Cache_locksMaxAggregateOutputType = {
    key: string | null
    owner: string | null
    expiration: number | null
  }

  export type Cache_locksCountAggregateOutputType = {
    key: number
    owner: number
    expiration: number
    _all: number
  }


  export type Cache_locksAvgAggregateInputType = {
    expiration?: true
  }

  export type Cache_locksSumAggregateInputType = {
    expiration?: true
  }

  export type Cache_locksMinAggregateInputType = {
    key?: true
    owner?: true
    expiration?: true
  }

  export type Cache_locksMaxAggregateInputType = {
    key?: true
    owner?: true
    expiration?: true
  }

  export type Cache_locksCountAggregateInputType = {
    key?: true
    owner?: true
    expiration?: true
    _all?: true
  }

  export type Cache_locksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cache_locks to aggregate.
     */
    where?: cache_locksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cache_locks to fetch.
     */
    orderBy?: cache_locksOrderByWithRelationInput | cache_locksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cache_locksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cache_locks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cache_locks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cache_locks
    **/
    _count?: true | Cache_locksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Cache_locksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Cache_locksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Cache_locksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Cache_locksMaxAggregateInputType
  }

  export type GetCache_locksAggregateType<T extends Cache_locksAggregateArgs> = {
        [P in keyof T & keyof AggregateCache_locks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCache_locks[P]>
      : GetScalarType<T[P], AggregateCache_locks[P]>
  }




  export type cache_locksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cache_locksWhereInput
    orderBy?: cache_locksOrderByWithAggregationInput | cache_locksOrderByWithAggregationInput[]
    by: Cache_locksScalarFieldEnum[] | Cache_locksScalarFieldEnum
    having?: cache_locksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Cache_locksCountAggregateInputType | true
    _avg?: Cache_locksAvgAggregateInputType
    _sum?: Cache_locksSumAggregateInputType
    _min?: Cache_locksMinAggregateInputType
    _max?: Cache_locksMaxAggregateInputType
  }

  export type Cache_locksGroupByOutputType = {
    key: string
    owner: string
    expiration: number
    _count: Cache_locksCountAggregateOutputType | null
    _avg: Cache_locksAvgAggregateOutputType | null
    _sum: Cache_locksSumAggregateOutputType | null
    _min: Cache_locksMinAggregateOutputType | null
    _max: Cache_locksMaxAggregateOutputType | null
  }

  type GetCache_locksGroupByPayload<T extends cache_locksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Cache_locksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Cache_locksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Cache_locksGroupByOutputType[P]>
            : GetScalarType<T[P], Cache_locksGroupByOutputType[P]>
        }
      >
    >


  export type cache_locksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    owner?: boolean
    expiration?: boolean
  }, ExtArgs["result"]["cache_locks"]>

  export type cache_locksSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    owner?: boolean
    expiration?: boolean
  }, ExtArgs["result"]["cache_locks"]>

  export type cache_locksSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    owner?: boolean
    expiration?: boolean
  }, ExtArgs["result"]["cache_locks"]>

  export type cache_locksSelectScalar = {
    key?: boolean
    owner?: boolean
    expiration?: boolean
  }

  export type cache_locksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"key" | "owner" | "expiration", ExtArgs["result"]["cache_locks"]>

  export type $cache_locksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cache_locks"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      key: string
      owner: string
      expiration: number
    }, ExtArgs["result"]["cache_locks"]>
    composites: {}
  }

  type cache_locksGetPayload<S extends boolean | null | undefined | cache_locksDefaultArgs> = $Result.GetResult<Prisma.$cache_locksPayload, S>

  type cache_locksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<cache_locksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Cache_locksCountAggregateInputType | true
    }

  export interface cache_locksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cache_locks'], meta: { name: 'cache_locks' } }
    /**
     * Find zero or one Cache_locks that matches the filter.
     * @param {cache_locksFindUniqueArgs} args - Arguments to find a Cache_locks
     * @example
     * // Get one Cache_locks
     * const cache_locks = await prisma.cache_locks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cache_locksFindUniqueArgs>(args: SelectSubset<T, cache_locksFindUniqueArgs<ExtArgs>>): Prisma__cache_locksClient<$Result.GetResult<Prisma.$cache_locksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cache_locks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {cache_locksFindUniqueOrThrowArgs} args - Arguments to find a Cache_locks
     * @example
     * // Get one Cache_locks
     * const cache_locks = await prisma.cache_locks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cache_locksFindUniqueOrThrowArgs>(args: SelectSubset<T, cache_locksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cache_locksClient<$Result.GetResult<Prisma.$cache_locksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cache_locks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cache_locksFindFirstArgs} args - Arguments to find a Cache_locks
     * @example
     * // Get one Cache_locks
     * const cache_locks = await prisma.cache_locks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cache_locksFindFirstArgs>(args?: SelectSubset<T, cache_locksFindFirstArgs<ExtArgs>>): Prisma__cache_locksClient<$Result.GetResult<Prisma.$cache_locksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cache_locks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cache_locksFindFirstOrThrowArgs} args - Arguments to find a Cache_locks
     * @example
     * // Get one Cache_locks
     * const cache_locks = await prisma.cache_locks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cache_locksFindFirstOrThrowArgs>(args?: SelectSubset<T, cache_locksFindFirstOrThrowArgs<ExtArgs>>): Prisma__cache_locksClient<$Result.GetResult<Prisma.$cache_locksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cache_locks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cache_locksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cache_locks
     * const cache_locks = await prisma.cache_locks.findMany()
     * 
     * // Get first 10 Cache_locks
     * const cache_locks = await prisma.cache_locks.findMany({ take: 10 })
     * 
     * // Only select the `key`
     * const cache_locksWithKeyOnly = await prisma.cache_locks.findMany({ select: { key: true } })
     * 
     */
    findMany<T extends cache_locksFindManyArgs>(args?: SelectSubset<T, cache_locksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cache_locksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cache_locks.
     * @param {cache_locksCreateArgs} args - Arguments to create a Cache_locks.
     * @example
     * // Create one Cache_locks
     * const Cache_locks = await prisma.cache_locks.create({
     *   data: {
     *     // ... data to create a Cache_locks
     *   }
     * })
     * 
     */
    create<T extends cache_locksCreateArgs>(args: SelectSubset<T, cache_locksCreateArgs<ExtArgs>>): Prisma__cache_locksClient<$Result.GetResult<Prisma.$cache_locksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cache_locks.
     * @param {cache_locksCreateManyArgs} args - Arguments to create many Cache_locks.
     * @example
     * // Create many Cache_locks
     * const cache_locks = await prisma.cache_locks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cache_locksCreateManyArgs>(args?: SelectSubset<T, cache_locksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cache_locks and returns the data saved in the database.
     * @param {cache_locksCreateManyAndReturnArgs} args - Arguments to create many Cache_locks.
     * @example
     * // Create many Cache_locks
     * const cache_locks = await prisma.cache_locks.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cache_locks and only return the `key`
     * const cache_locksWithKeyOnly = await prisma.cache_locks.createManyAndReturn({
     *   select: { key: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends cache_locksCreateManyAndReturnArgs>(args?: SelectSubset<T, cache_locksCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cache_locksPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cache_locks.
     * @param {cache_locksDeleteArgs} args - Arguments to delete one Cache_locks.
     * @example
     * // Delete one Cache_locks
     * const Cache_locks = await prisma.cache_locks.delete({
     *   where: {
     *     // ... filter to delete one Cache_locks
     *   }
     * })
     * 
     */
    delete<T extends cache_locksDeleteArgs>(args: SelectSubset<T, cache_locksDeleteArgs<ExtArgs>>): Prisma__cache_locksClient<$Result.GetResult<Prisma.$cache_locksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cache_locks.
     * @param {cache_locksUpdateArgs} args - Arguments to update one Cache_locks.
     * @example
     * // Update one Cache_locks
     * const cache_locks = await prisma.cache_locks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cache_locksUpdateArgs>(args: SelectSubset<T, cache_locksUpdateArgs<ExtArgs>>): Prisma__cache_locksClient<$Result.GetResult<Prisma.$cache_locksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cache_locks.
     * @param {cache_locksDeleteManyArgs} args - Arguments to filter Cache_locks to delete.
     * @example
     * // Delete a few Cache_locks
     * const { count } = await prisma.cache_locks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cache_locksDeleteManyArgs>(args?: SelectSubset<T, cache_locksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cache_locks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cache_locksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cache_locks
     * const cache_locks = await prisma.cache_locks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cache_locksUpdateManyArgs>(args: SelectSubset<T, cache_locksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cache_locks and returns the data updated in the database.
     * @param {cache_locksUpdateManyAndReturnArgs} args - Arguments to update many Cache_locks.
     * @example
     * // Update many Cache_locks
     * const cache_locks = await prisma.cache_locks.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cache_locks and only return the `key`
     * const cache_locksWithKeyOnly = await prisma.cache_locks.updateManyAndReturn({
     *   select: { key: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends cache_locksUpdateManyAndReturnArgs>(args: SelectSubset<T, cache_locksUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cache_locksPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cache_locks.
     * @param {cache_locksUpsertArgs} args - Arguments to update or create a Cache_locks.
     * @example
     * // Update or create a Cache_locks
     * const cache_locks = await prisma.cache_locks.upsert({
     *   create: {
     *     // ... data to create a Cache_locks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cache_locks we want to update
     *   }
     * })
     */
    upsert<T extends cache_locksUpsertArgs>(args: SelectSubset<T, cache_locksUpsertArgs<ExtArgs>>): Prisma__cache_locksClient<$Result.GetResult<Prisma.$cache_locksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cache_locks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cache_locksCountArgs} args - Arguments to filter Cache_locks to count.
     * @example
     * // Count the number of Cache_locks
     * const count = await prisma.cache_locks.count({
     *   where: {
     *     // ... the filter for the Cache_locks we want to count
     *   }
     * })
    **/
    count<T extends cache_locksCountArgs>(
      args?: Subset<T, cache_locksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Cache_locksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cache_locks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cache_locksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Cache_locksAggregateArgs>(args: Subset<T, Cache_locksAggregateArgs>): Prisma.PrismaPromise<GetCache_locksAggregateType<T>>

    /**
     * Group by Cache_locks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cache_locksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cache_locksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cache_locksGroupByArgs['orderBy'] }
        : { orderBy?: cache_locksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cache_locksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCache_locksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cache_locks model
   */
  readonly fields: cache_locksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cache_locks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cache_locksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cache_locks model
   */
  interface cache_locksFieldRefs {
    readonly key: FieldRef<"cache_locks", 'String'>
    readonly owner: FieldRef<"cache_locks", 'String'>
    readonly expiration: FieldRef<"cache_locks", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * cache_locks findUnique
   */
  export type cache_locksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_locks
     */
    select?: cache_locksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_locks
     */
    omit?: cache_locksOmit<ExtArgs> | null
    /**
     * Filter, which cache_locks to fetch.
     */
    where: cache_locksWhereUniqueInput
  }

  /**
   * cache_locks findUniqueOrThrow
   */
  export type cache_locksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_locks
     */
    select?: cache_locksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_locks
     */
    omit?: cache_locksOmit<ExtArgs> | null
    /**
     * Filter, which cache_locks to fetch.
     */
    where: cache_locksWhereUniqueInput
  }

  /**
   * cache_locks findFirst
   */
  export type cache_locksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_locks
     */
    select?: cache_locksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_locks
     */
    omit?: cache_locksOmit<ExtArgs> | null
    /**
     * Filter, which cache_locks to fetch.
     */
    where?: cache_locksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cache_locks to fetch.
     */
    orderBy?: cache_locksOrderByWithRelationInput | cache_locksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cache_locks.
     */
    cursor?: cache_locksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cache_locks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cache_locks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cache_locks.
     */
    distinct?: Cache_locksScalarFieldEnum | Cache_locksScalarFieldEnum[]
  }

  /**
   * cache_locks findFirstOrThrow
   */
  export type cache_locksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_locks
     */
    select?: cache_locksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_locks
     */
    omit?: cache_locksOmit<ExtArgs> | null
    /**
     * Filter, which cache_locks to fetch.
     */
    where?: cache_locksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cache_locks to fetch.
     */
    orderBy?: cache_locksOrderByWithRelationInput | cache_locksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cache_locks.
     */
    cursor?: cache_locksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cache_locks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cache_locks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cache_locks.
     */
    distinct?: Cache_locksScalarFieldEnum | Cache_locksScalarFieldEnum[]
  }

  /**
   * cache_locks findMany
   */
  export type cache_locksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_locks
     */
    select?: cache_locksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_locks
     */
    omit?: cache_locksOmit<ExtArgs> | null
    /**
     * Filter, which cache_locks to fetch.
     */
    where?: cache_locksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cache_locks to fetch.
     */
    orderBy?: cache_locksOrderByWithRelationInput | cache_locksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cache_locks.
     */
    cursor?: cache_locksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cache_locks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cache_locks.
     */
    skip?: number
    distinct?: Cache_locksScalarFieldEnum | Cache_locksScalarFieldEnum[]
  }

  /**
   * cache_locks create
   */
  export type cache_locksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_locks
     */
    select?: cache_locksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_locks
     */
    omit?: cache_locksOmit<ExtArgs> | null
    /**
     * The data needed to create a cache_locks.
     */
    data: XOR<cache_locksCreateInput, cache_locksUncheckedCreateInput>
  }

  /**
   * cache_locks createMany
   */
  export type cache_locksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cache_locks.
     */
    data: cache_locksCreateManyInput | cache_locksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cache_locks createManyAndReturn
   */
  export type cache_locksCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_locks
     */
    select?: cache_locksSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cache_locks
     */
    omit?: cache_locksOmit<ExtArgs> | null
    /**
     * The data used to create many cache_locks.
     */
    data: cache_locksCreateManyInput | cache_locksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cache_locks update
   */
  export type cache_locksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_locks
     */
    select?: cache_locksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_locks
     */
    omit?: cache_locksOmit<ExtArgs> | null
    /**
     * The data needed to update a cache_locks.
     */
    data: XOR<cache_locksUpdateInput, cache_locksUncheckedUpdateInput>
    /**
     * Choose, which cache_locks to update.
     */
    where: cache_locksWhereUniqueInput
  }

  /**
   * cache_locks updateMany
   */
  export type cache_locksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cache_locks.
     */
    data: XOR<cache_locksUpdateManyMutationInput, cache_locksUncheckedUpdateManyInput>
    /**
     * Filter which cache_locks to update
     */
    where?: cache_locksWhereInput
    /**
     * Limit how many cache_locks to update.
     */
    limit?: number
  }

  /**
   * cache_locks updateManyAndReturn
   */
  export type cache_locksUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_locks
     */
    select?: cache_locksSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cache_locks
     */
    omit?: cache_locksOmit<ExtArgs> | null
    /**
     * The data used to update cache_locks.
     */
    data: XOR<cache_locksUpdateManyMutationInput, cache_locksUncheckedUpdateManyInput>
    /**
     * Filter which cache_locks to update
     */
    where?: cache_locksWhereInput
    /**
     * Limit how many cache_locks to update.
     */
    limit?: number
  }

  /**
   * cache_locks upsert
   */
  export type cache_locksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_locks
     */
    select?: cache_locksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_locks
     */
    omit?: cache_locksOmit<ExtArgs> | null
    /**
     * The filter to search for the cache_locks to update in case it exists.
     */
    where: cache_locksWhereUniqueInput
    /**
     * In case the cache_locks found by the `where` argument doesn't exist, create a new cache_locks with this data.
     */
    create: XOR<cache_locksCreateInput, cache_locksUncheckedCreateInput>
    /**
     * In case the cache_locks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cache_locksUpdateInput, cache_locksUncheckedUpdateInput>
  }

  /**
   * cache_locks delete
   */
  export type cache_locksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_locks
     */
    select?: cache_locksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_locks
     */
    omit?: cache_locksOmit<ExtArgs> | null
    /**
     * Filter which cache_locks to delete.
     */
    where: cache_locksWhereUniqueInput
  }

  /**
   * cache_locks deleteMany
   */
  export type cache_locksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cache_locks to delete
     */
    where?: cache_locksWhereInput
    /**
     * Limit how many cache_locks to delete.
     */
    limit?: number
  }

  /**
   * cache_locks without action
   */
  export type cache_locksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_locks
     */
    select?: cache_locksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_locks
     */
    omit?: cache_locksOmit<ExtArgs> | null
  }


  /**
   * Model contacts
   */

  export type AggregateContacts = {
    _count: ContactsCountAggregateOutputType | null
    _avg: ContactsAvgAggregateOutputType | null
    _sum: ContactsSumAggregateOutputType | null
    _min: ContactsMinAggregateOutputType | null
    _max: ContactsMaxAggregateOutputType | null
  }

  export type ContactsAvgAggregateOutputType = {
    id: number | null
    assigned_to: number | null
  }

  export type ContactsSumAggregateOutputType = {
    id: bigint | null
    assigned_to: bigint | null
  }

  export type ContactsMinAggregateOutputType = {
    id: bigint | null
    contact_id: string | null
    name: string | null
    email: string | null
    phone: string | null
    subject: string | null
    message: string | null
    ip_address: string | null
    user_agent: string | null
    status: string | null
    priority: string | null
    assigned_to: bigint | null
    responded_at: Date | null
    response: string | null
    internal_notes: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type ContactsMaxAggregateOutputType = {
    id: bigint | null
    contact_id: string | null
    name: string | null
    email: string | null
    phone: string | null
    subject: string | null
    message: string | null
    ip_address: string | null
    user_agent: string | null
    status: string | null
    priority: string | null
    assigned_to: bigint | null
    responded_at: Date | null
    response: string | null
    internal_notes: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type ContactsCountAggregateOutputType = {
    id: number
    contact_id: number
    name: number
    email: number
    phone: number
    subject: number
    message: number
    ip_address: number
    user_agent: number
    status: number
    priority: number
    assigned_to: number
    responded_at: number
    response: number
    internal_notes: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type ContactsAvgAggregateInputType = {
    id?: true
    assigned_to?: true
  }

  export type ContactsSumAggregateInputType = {
    id?: true
    assigned_to?: true
  }

  export type ContactsMinAggregateInputType = {
    id?: true
    contact_id?: true
    name?: true
    email?: true
    phone?: true
    subject?: true
    message?: true
    ip_address?: true
    user_agent?: true
    status?: true
    priority?: true
    assigned_to?: true
    responded_at?: true
    response?: true
    internal_notes?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type ContactsMaxAggregateInputType = {
    id?: true
    contact_id?: true
    name?: true
    email?: true
    phone?: true
    subject?: true
    message?: true
    ip_address?: true
    user_agent?: true
    status?: true
    priority?: true
    assigned_to?: true
    responded_at?: true
    response?: true
    internal_notes?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type ContactsCountAggregateInputType = {
    id?: true
    contact_id?: true
    name?: true
    email?: true
    phone?: true
    subject?: true
    message?: true
    ip_address?: true
    user_agent?: true
    status?: true
    priority?: true
    assigned_to?: true
    responded_at?: true
    response?: true
    internal_notes?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type ContactsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contacts to aggregate.
     */
    where?: contactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contacts to fetch.
     */
    orderBy?: contactsOrderByWithRelationInput | contactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: contactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned contacts
    **/
    _count?: true | ContactsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactsMaxAggregateInputType
  }

  export type GetContactsAggregateType<T extends ContactsAggregateArgs> = {
        [P in keyof T & keyof AggregateContacts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContacts[P]>
      : GetScalarType<T[P], AggregateContacts[P]>
  }




  export type contactsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contactsWhereInput
    orderBy?: contactsOrderByWithAggregationInput | contactsOrderByWithAggregationInput[]
    by: ContactsScalarFieldEnum[] | ContactsScalarFieldEnum
    having?: contactsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactsCountAggregateInputType | true
    _avg?: ContactsAvgAggregateInputType
    _sum?: ContactsSumAggregateInputType
    _min?: ContactsMinAggregateInputType
    _max?: ContactsMaxAggregateInputType
  }

  export type ContactsGroupByOutputType = {
    id: bigint
    contact_id: string
    name: string
    email: string
    phone: string | null
    subject: string
    message: string
    ip_address: string | null
    user_agent: string | null
    status: string
    priority: string
    assigned_to: bigint | null
    responded_at: Date | null
    response: string | null
    internal_notes: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    _count: ContactsCountAggregateOutputType | null
    _avg: ContactsAvgAggregateOutputType | null
    _sum: ContactsSumAggregateOutputType | null
    _min: ContactsMinAggregateOutputType | null
    _max: ContactsMaxAggregateOutputType | null
  }

  type GetContactsGroupByPayload<T extends contactsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactsGroupByOutputType[P]>
            : GetScalarType<T[P], ContactsGroupByOutputType[P]>
        }
      >
    >


  export type contactsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contact_id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    subject?: boolean
    message?: boolean
    ip_address?: boolean
    user_agent?: boolean
    status?: boolean
    priority?: boolean
    assigned_to?: boolean
    responded_at?: boolean
    response?: boolean
    internal_notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    users?: boolean | contacts$usersArgs<ExtArgs>
  }, ExtArgs["result"]["contacts"]>

  export type contactsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contact_id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    subject?: boolean
    message?: boolean
    ip_address?: boolean
    user_agent?: boolean
    status?: boolean
    priority?: boolean
    assigned_to?: boolean
    responded_at?: boolean
    response?: boolean
    internal_notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    users?: boolean | contacts$usersArgs<ExtArgs>
  }, ExtArgs["result"]["contacts"]>

  export type contactsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contact_id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    subject?: boolean
    message?: boolean
    ip_address?: boolean
    user_agent?: boolean
    status?: boolean
    priority?: boolean
    assigned_to?: boolean
    responded_at?: boolean
    response?: boolean
    internal_notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    users?: boolean | contacts$usersArgs<ExtArgs>
  }, ExtArgs["result"]["contacts"]>

  export type contactsSelectScalar = {
    id?: boolean
    contact_id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    subject?: boolean
    message?: boolean
    ip_address?: boolean
    user_agent?: boolean
    status?: boolean
    priority?: boolean
    assigned_to?: boolean
    responded_at?: boolean
    response?: boolean
    internal_notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type contactsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contact_id" | "name" | "email" | "phone" | "subject" | "message" | "ip_address" | "user_agent" | "status" | "priority" | "assigned_to" | "responded_at" | "response" | "internal_notes" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["contacts"]>
  export type contactsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | contacts$usersArgs<ExtArgs>
  }
  export type contactsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | contacts$usersArgs<ExtArgs>
  }
  export type contactsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | contacts$usersArgs<ExtArgs>
  }

  export type $contactsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "contacts"
    objects: {
      users: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      contact_id: string
      name: string
      email: string
      phone: string | null
      subject: string
      message: string
      ip_address: string | null
      user_agent: string | null
      status: string
      priority: string
      assigned_to: bigint | null
      responded_at: Date | null
      response: string | null
      internal_notes: string | null
      created_at: Date | null
      updated_at: Date | null
      deleted_at: Date | null
    }, ExtArgs["result"]["contacts"]>
    composites: {}
  }

  type contactsGetPayload<S extends boolean | null | undefined | contactsDefaultArgs> = $Result.GetResult<Prisma.$contactsPayload, S>

  type contactsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<contactsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactsCountAggregateInputType | true
    }

  export interface contactsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['contacts'], meta: { name: 'contacts' } }
    /**
     * Find zero or one Contacts that matches the filter.
     * @param {contactsFindUniqueArgs} args - Arguments to find a Contacts
     * @example
     * // Get one Contacts
     * const contacts = await prisma.contacts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends contactsFindUniqueArgs>(args: SelectSubset<T, contactsFindUniqueArgs<ExtArgs>>): Prisma__contactsClient<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contacts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {contactsFindUniqueOrThrowArgs} args - Arguments to find a Contacts
     * @example
     * // Get one Contacts
     * const contacts = await prisma.contacts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends contactsFindUniqueOrThrowArgs>(args: SelectSubset<T, contactsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__contactsClient<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactsFindFirstArgs} args - Arguments to find a Contacts
     * @example
     * // Get one Contacts
     * const contacts = await prisma.contacts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends contactsFindFirstArgs>(args?: SelectSubset<T, contactsFindFirstArgs<ExtArgs>>): Prisma__contactsClient<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contacts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactsFindFirstOrThrowArgs} args - Arguments to find a Contacts
     * @example
     * // Get one Contacts
     * const contacts = await prisma.contacts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends contactsFindFirstOrThrowArgs>(args?: SelectSubset<T, contactsFindFirstOrThrowArgs<ExtArgs>>): Prisma__contactsClient<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contacts.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contacts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactsWithIdOnly = await prisma.contacts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends contactsFindManyArgs>(args?: SelectSubset<T, contactsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contacts.
     * @param {contactsCreateArgs} args - Arguments to create a Contacts.
     * @example
     * // Create one Contacts
     * const Contacts = await prisma.contacts.create({
     *   data: {
     *     // ... data to create a Contacts
     *   }
     * })
     * 
     */
    create<T extends contactsCreateArgs>(args: SelectSubset<T, contactsCreateArgs<ExtArgs>>): Prisma__contactsClient<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contacts.
     * @param {contactsCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contacts = await prisma.contacts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends contactsCreateManyArgs>(args?: SelectSubset<T, contactsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contacts and returns the data saved in the database.
     * @param {contactsCreateManyAndReturnArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contacts = await prisma.contacts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contacts and only return the `id`
     * const contactsWithIdOnly = await prisma.contacts.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends contactsCreateManyAndReturnArgs>(args?: SelectSubset<T, contactsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Contacts.
     * @param {contactsDeleteArgs} args - Arguments to delete one Contacts.
     * @example
     * // Delete one Contacts
     * const Contacts = await prisma.contacts.delete({
     *   where: {
     *     // ... filter to delete one Contacts
     *   }
     * })
     * 
     */
    delete<T extends contactsDeleteArgs>(args: SelectSubset<T, contactsDeleteArgs<ExtArgs>>): Prisma__contactsClient<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contacts.
     * @param {contactsUpdateArgs} args - Arguments to update one Contacts.
     * @example
     * // Update one Contacts
     * const contacts = await prisma.contacts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends contactsUpdateArgs>(args: SelectSubset<T, contactsUpdateArgs<ExtArgs>>): Prisma__contactsClient<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contacts.
     * @param {contactsDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contacts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends contactsDeleteManyArgs>(args?: SelectSubset<T, contactsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contacts = await prisma.contacts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends contactsUpdateManyArgs>(args: SelectSubset<T, contactsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts and returns the data updated in the database.
     * @param {contactsUpdateManyAndReturnArgs} args - Arguments to update many Contacts.
     * @example
     * // Update many Contacts
     * const contacts = await prisma.contacts.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contacts and only return the `id`
     * const contactsWithIdOnly = await prisma.contacts.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends contactsUpdateManyAndReturnArgs>(args: SelectSubset<T, contactsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Contacts.
     * @param {contactsUpsertArgs} args - Arguments to update or create a Contacts.
     * @example
     * // Update or create a Contacts
     * const contacts = await prisma.contacts.upsert({
     *   create: {
     *     // ... data to create a Contacts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contacts we want to update
     *   }
     * })
     */
    upsert<T extends contactsUpsertArgs>(args: SelectSubset<T, contactsUpsertArgs<ExtArgs>>): Prisma__contactsClient<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactsCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contacts.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends contactsCountArgs>(
      args?: Subset<T, contactsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactsAggregateArgs>(args: Subset<T, ContactsAggregateArgs>): Prisma.PrismaPromise<GetContactsAggregateType<T>>

    /**
     * Group by Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends contactsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: contactsGroupByArgs['orderBy'] }
        : { orderBy?: contactsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, contactsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the contacts model
   */
  readonly fields: contactsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for contacts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__contactsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends contacts$usersArgs<ExtArgs> = {}>(args?: Subset<T, contacts$usersArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the contacts model
   */
  interface contactsFieldRefs {
    readonly id: FieldRef<"contacts", 'BigInt'>
    readonly contact_id: FieldRef<"contacts", 'String'>
    readonly name: FieldRef<"contacts", 'String'>
    readonly email: FieldRef<"contacts", 'String'>
    readonly phone: FieldRef<"contacts", 'String'>
    readonly subject: FieldRef<"contacts", 'String'>
    readonly message: FieldRef<"contacts", 'String'>
    readonly ip_address: FieldRef<"contacts", 'String'>
    readonly user_agent: FieldRef<"contacts", 'String'>
    readonly status: FieldRef<"contacts", 'String'>
    readonly priority: FieldRef<"contacts", 'String'>
    readonly assigned_to: FieldRef<"contacts", 'BigInt'>
    readonly responded_at: FieldRef<"contacts", 'DateTime'>
    readonly response: FieldRef<"contacts", 'String'>
    readonly internal_notes: FieldRef<"contacts", 'String'>
    readonly created_at: FieldRef<"contacts", 'DateTime'>
    readonly updated_at: FieldRef<"contacts", 'DateTime'>
    readonly deleted_at: FieldRef<"contacts", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * contacts findUnique
   */
  export type contactsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contacts
     */
    omit?: contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactsInclude<ExtArgs> | null
    /**
     * Filter, which contacts to fetch.
     */
    where: contactsWhereUniqueInput
  }

  /**
   * contacts findUniqueOrThrow
   */
  export type contactsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contacts
     */
    omit?: contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactsInclude<ExtArgs> | null
    /**
     * Filter, which contacts to fetch.
     */
    where: contactsWhereUniqueInput
  }

  /**
   * contacts findFirst
   */
  export type contactsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contacts
     */
    omit?: contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactsInclude<ExtArgs> | null
    /**
     * Filter, which contacts to fetch.
     */
    where?: contactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contacts to fetch.
     */
    orderBy?: contactsOrderByWithRelationInput | contactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contacts.
     */
    cursor?: contactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contacts.
     */
    distinct?: ContactsScalarFieldEnum | ContactsScalarFieldEnum[]
  }

  /**
   * contacts findFirstOrThrow
   */
  export type contactsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contacts
     */
    omit?: contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactsInclude<ExtArgs> | null
    /**
     * Filter, which contacts to fetch.
     */
    where?: contactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contacts to fetch.
     */
    orderBy?: contactsOrderByWithRelationInput | contactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contacts.
     */
    cursor?: contactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contacts.
     */
    distinct?: ContactsScalarFieldEnum | ContactsScalarFieldEnum[]
  }

  /**
   * contacts findMany
   */
  export type contactsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contacts
     */
    omit?: contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactsInclude<ExtArgs> | null
    /**
     * Filter, which contacts to fetch.
     */
    where?: contactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contacts to fetch.
     */
    orderBy?: contactsOrderByWithRelationInput | contactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing contacts.
     */
    cursor?: contactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contacts.
     */
    skip?: number
    distinct?: ContactsScalarFieldEnum | ContactsScalarFieldEnum[]
  }

  /**
   * contacts create
   */
  export type contactsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contacts
     */
    omit?: contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactsInclude<ExtArgs> | null
    /**
     * The data needed to create a contacts.
     */
    data: XOR<contactsCreateInput, contactsUncheckedCreateInput>
  }

  /**
   * contacts createMany
   */
  export type contactsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many contacts.
     */
    data: contactsCreateManyInput | contactsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * contacts createManyAndReturn
   */
  export type contactsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the contacts
     */
    omit?: contactsOmit<ExtArgs> | null
    /**
     * The data used to create many contacts.
     */
    data: contactsCreateManyInput | contactsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * contacts update
   */
  export type contactsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contacts
     */
    omit?: contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactsInclude<ExtArgs> | null
    /**
     * The data needed to update a contacts.
     */
    data: XOR<contactsUpdateInput, contactsUncheckedUpdateInput>
    /**
     * Choose, which contacts to update.
     */
    where: contactsWhereUniqueInput
  }

  /**
   * contacts updateMany
   */
  export type contactsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update contacts.
     */
    data: XOR<contactsUpdateManyMutationInput, contactsUncheckedUpdateManyInput>
    /**
     * Filter which contacts to update
     */
    where?: contactsWhereInput
    /**
     * Limit how many contacts to update.
     */
    limit?: number
  }

  /**
   * contacts updateManyAndReturn
   */
  export type contactsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the contacts
     */
    omit?: contactsOmit<ExtArgs> | null
    /**
     * The data used to update contacts.
     */
    data: XOR<contactsUpdateManyMutationInput, contactsUncheckedUpdateManyInput>
    /**
     * Filter which contacts to update
     */
    where?: contactsWhereInput
    /**
     * Limit how many contacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * contacts upsert
   */
  export type contactsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contacts
     */
    omit?: contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactsInclude<ExtArgs> | null
    /**
     * The filter to search for the contacts to update in case it exists.
     */
    where: contactsWhereUniqueInput
    /**
     * In case the contacts found by the `where` argument doesn't exist, create a new contacts with this data.
     */
    create: XOR<contactsCreateInput, contactsUncheckedCreateInput>
    /**
     * In case the contacts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<contactsUpdateInput, contactsUncheckedUpdateInput>
  }

  /**
   * contacts delete
   */
  export type contactsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contacts
     */
    omit?: contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactsInclude<ExtArgs> | null
    /**
     * Filter which contacts to delete.
     */
    where: contactsWhereUniqueInput
  }

  /**
   * contacts deleteMany
   */
  export type contactsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contacts to delete
     */
    where?: contactsWhereInput
    /**
     * Limit how many contacts to delete.
     */
    limit?: number
  }

  /**
   * contacts.users
   */
  export type contacts$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * contacts without action
   */
  export type contactsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contacts
     */
    omit?: contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactsInclude<ExtArgs> | null
  }


  /**
   * Model donations
   */

  export type AggregateDonations = {
    _count: DonationsCountAggregateOutputType | null
    _avg: DonationsAvgAggregateOutputType | null
    _sum: DonationsSumAggregateOutputType | null
    _min: DonationsMinAggregateOutputType | null
    _max: DonationsMaxAggregateOutputType | null
  }

  export type DonationsAvgAggregateOutputType = {
    id: number | null
    project_id: number | null
    user_id: number | null
    amount: number | null
  }

  export type DonationsSumAggregateOutputType = {
    id: bigint | null
    project_id: bigint | null
    user_id: bigint | null
    amount: bigint | null
  }

  export type DonationsMinAggregateOutputType = {
    id: bigint | null
    donation_id: string | null
    project_id: bigint | null
    user_id: bigint | null
    donor_name: string | null
    donor_email: string | null
    donor_phone: string | null
    amount: bigint | null
    frequency: string | null
    status: string | null
    payment_method: string | null
    payment_channel: string | null
    transaction_id: string | null
    paid_at: Date | null
    message: string | null
    is_anonymous: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type DonationsMaxAggregateOutputType = {
    id: bigint | null
    donation_id: string | null
    project_id: bigint | null
    user_id: bigint | null
    donor_name: string | null
    donor_email: string | null
    donor_phone: string | null
    amount: bigint | null
    frequency: string | null
    status: string | null
    payment_method: string | null
    payment_channel: string | null
    transaction_id: string | null
    paid_at: Date | null
    message: string | null
    is_anonymous: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type DonationsCountAggregateOutputType = {
    id: number
    donation_id: number
    project_id: number
    user_id: number
    donor_name: number
    donor_email: number
    donor_phone: number
    amount: number
    frequency: number
    status: number
    payment_method: number
    payment_channel: number
    transaction_id: number
    paid_at: number
    message: number
    is_anonymous: number
    metadata: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type DonationsAvgAggregateInputType = {
    id?: true
    project_id?: true
    user_id?: true
    amount?: true
  }

  export type DonationsSumAggregateInputType = {
    id?: true
    project_id?: true
    user_id?: true
    amount?: true
  }

  export type DonationsMinAggregateInputType = {
    id?: true
    donation_id?: true
    project_id?: true
    user_id?: true
    donor_name?: true
    donor_email?: true
    donor_phone?: true
    amount?: true
    frequency?: true
    status?: true
    payment_method?: true
    payment_channel?: true
    transaction_id?: true
    paid_at?: true
    message?: true
    is_anonymous?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type DonationsMaxAggregateInputType = {
    id?: true
    donation_id?: true
    project_id?: true
    user_id?: true
    donor_name?: true
    donor_email?: true
    donor_phone?: true
    amount?: true
    frequency?: true
    status?: true
    payment_method?: true
    payment_channel?: true
    transaction_id?: true
    paid_at?: true
    message?: true
    is_anonymous?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type DonationsCountAggregateInputType = {
    id?: true
    donation_id?: true
    project_id?: true
    user_id?: true
    donor_name?: true
    donor_email?: true
    donor_phone?: true
    amount?: true
    frequency?: true
    status?: true
    payment_method?: true
    payment_channel?: true
    transaction_id?: true
    paid_at?: true
    message?: true
    is_anonymous?: true
    metadata?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type DonationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which donations to aggregate.
     */
    where?: donationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of donations to fetch.
     */
    orderBy?: donationsOrderByWithRelationInput | donationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: donationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` donations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` donations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned donations
    **/
    _count?: true | DonationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DonationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DonationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DonationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DonationsMaxAggregateInputType
  }

  export type GetDonationsAggregateType<T extends DonationsAggregateArgs> = {
        [P in keyof T & keyof AggregateDonations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDonations[P]>
      : GetScalarType<T[P], AggregateDonations[P]>
  }




  export type donationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: donationsWhereInput
    orderBy?: donationsOrderByWithAggregationInput | donationsOrderByWithAggregationInput[]
    by: DonationsScalarFieldEnum[] | DonationsScalarFieldEnum
    having?: donationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DonationsCountAggregateInputType | true
    _avg?: DonationsAvgAggregateInputType
    _sum?: DonationsSumAggregateInputType
    _min?: DonationsMinAggregateInputType
    _max?: DonationsMaxAggregateInputType
  }

  export type DonationsGroupByOutputType = {
    id: bigint
    donation_id: string
    project_id: bigint
    user_id: bigint | null
    donor_name: string | null
    donor_email: string | null
    donor_phone: string | null
    amount: bigint
    frequency: string
    status: string
    payment_method: string | null
    payment_channel: string | null
    transaction_id: string | null
    paid_at: Date | null
    message: string | null
    is_anonymous: boolean
    metadata: JsonValue | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    _count: DonationsCountAggregateOutputType | null
    _avg: DonationsAvgAggregateOutputType | null
    _sum: DonationsSumAggregateOutputType | null
    _min: DonationsMinAggregateOutputType | null
    _max: DonationsMaxAggregateOutputType | null
  }

  type GetDonationsGroupByPayload<T extends donationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DonationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DonationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DonationsGroupByOutputType[P]>
            : GetScalarType<T[P], DonationsGroupByOutputType[P]>
        }
      >
    >


  export type donationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    donation_id?: boolean
    project_id?: boolean
    user_id?: boolean
    donor_name?: boolean
    donor_email?: boolean
    donor_phone?: boolean
    amount?: boolean
    frequency?: boolean
    status?: boolean
    payment_method?: boolean
    payment_channel?: boolean
    transaction_id?: boolean
    paid_at?: boolean
    message?: boolean
    is_anonymous?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    projects?: boolean | ProjectDefaultArgs<ExtArgs>
    users?: boolean | donations$usersArgs<ExtArgs>
  }, ExtArgs["result"]["donations"]>

  export type donationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    donation_id?: boolean
    project_id?: boolean
    user_id?: boolean
    donor_name?: boolean
    donor_email?: boolean
    donor_phone?: boolean
    amount?: boolean
    frequency?: boolean
    status?: boolean
    payment_method?: boolean
    payment_channel?: boolean
    transaction_id?: boolean
    paid_at?: boolean
    message?: boolean
    is_anonymous?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    projects?: boolean | ProjectDefaultArgs<ExtArgs>
    users?: boolean | donations$usersArgs<ExtArgs>
  }, ExtArgs["result"]["donations"]>

  export type donationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    donation_id?: boolean
    project_id?: boolean
    user_id?: boolean
    donor_name?: boolean
    donor_email?: boolean
    donor_phone?: boolean
    amount?: boolean
    frequency?: boolean
    status?: boolean
    payment_method?: boolean
    payment_channel?: boolean
    transaction_id?: boolean
    paid_at?: boolean
    message?: boolean
    is_anonymous?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    projects?: boolean | ProjectDefaultArgs<ExtArgs>
    users?: boolean | donations$usersArgs<ExtArgs>
  }, ExtArgs["result"]["donations"]>

  export type donationsSelectScalar = {
    id?: boolean
    donation_id?: boolean
    project_id?: boolean
    user_id?: boolean
    donor_name?: boolean
    donor_email?: boolean
    donor_phone?: boolean
    amount?: boolean
    frequency?: boolean
    status?: boolean
    payment_method?: boolean
    payment_channel?: boolean
    transaction_id?: boolean
    paid_at?: boolean
    message?: boolean
    is_anonymous?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type donationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "donation_id" | "project_id" | "user_id" | "donor_name" | "donor_email" | "donor_phone" | "amount" | "frequency" | "status" | "payment_method" | "payment_channel" | "transaction_id" | "paid_at" | "message" | "is_anonymous" | "metadata" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["donations"]>
  export type donationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | ProjectDefaultArgs<ExtArgs>
    users?: boolean | donations$usersArgs<ExtArgs>
  }
  export type donationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | ProjectDefaultArgs<ExtArgs>
    users?: boolean | donations$usersArgs<ExtArgs>
  }
  export type donationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | ProjectDefaultArgs<ExtArgs>
    users?: boolean | donations$usersArgs<ExtArgs>
  }

  export type $donationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "donations"
    objects: {
      projects: Prisma.$ProjectPayload<ExtArgs>
      users: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      donation_id: string
      project_id: bigint
      user_id: bigint | null
      donor_name: string | null
      donor_email: string | null
      donor_phone: string | null
      amount: bigint
      frequency: string
      status: string
      payment_method: string | null
      payment_channel: string | null
      transaction_id: string | null
      paid_at: Date | null
      message: string | null
      is_anonymous: boolean
      metadata: Prisma.JsonValue | null
      created_at: Date | null
      updated_at: Date | null
      deleted_at: Date | null
    }, ExtArgs["result"]["donations"]>
    composites: {}
  }

  type donationsGetPayload<S extends boolean | null | undefined | donationsDefaultArgs> = $Result.GetResult<Prisma.$donationsPayload, S>

  type donationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<donationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DonationsCountAggregateInputType | true
    }

  export interface donationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['donations'], meta: { name: 'donations' } }
    /**
     * Find zero or one Donations that matches the filter.
     * @param {donationsFindUniqueArgs} args - Arguments to find a Donations
     * @example
     * // Get one Donations
     * const donations = await prisma.donations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends donationsFindUniqueArgs>(args: SelectSubset<T, donationsFindUniqueArgs<ExtArgs>>): Prisma__donationsClient<$Result.GetResult<Prisma.$donationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Donations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {donationsFindUniqueOrThrowArgs} args - Arguments to find a Donations
     * @example
     * // Get one Donations
     * const donations = await prisma.donations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends donationsFindUniqueOrThrowArgs>(args: SelectSubset<T, donationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__donationsClient<$Result.GetResult<Prisma.$donationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Donations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {donationsFindFirstArgs} args - Arguments to find a Donations
     * @example
     * // Get one Donations
     * const donations = await prisma.donations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends donationsFindFirstArgs>(args?: SelectSubset<T, donationsFindFirstArgs<ExtArgs>>): Prisma__donationsClient<$Result.GetResult<Prisma.$donationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Donations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {donationsFindFirstOrThrowArgs} args - Arguments to find a Donations
     * @example
     * // Get one Donations
     * const donations = await prisma.donations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends donationsFindFirstOrThrowArgs>(args?: SelectSubset<T, donationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__donationsClient<$Result.GetResult<Prisma.$donationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Donations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {donationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Donations
     * const donations = await prisma.donations.findMany()
     * 
     * // Get first 10 Donations
     * const donations = await prisma.donations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const donationsWithIdOnly = await prisma.donations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends donationsFindManyArgs>(args?: SelectSubset<T, donationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$donationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Donations.
     * @param {donationsCreateArgs} args - Arguments to create a Donations.
     * @example
     * // Create one Donations
     * const Donations = await prisma.donations.create({
     *   data: {
     *     // ... data to create a Donations
     *   }
     * })
     * 
     */
    create<T extends donationsCreateArgs>(args: SelectSubset<T, donationsCreateArgs<ExtArgs>>): Prisma__donationsClient<$Result.GetResult<Prisma.$donationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Donations.
     * @param {donationsCreateManyArgs} args - Arguments to create many Donations.
     * @example
     * // Create many Donations
     * const donations = await prisma.donations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends donationsCreateManyArgs>(args?: SelectSubset<T, donationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Donations and returns the data saved in the database.
     * @param {donationsCreateManyAndReturnArgs} args - Arguments to create many Donations.
     * @example
     * // Create many Donations
     * const donations = await prisma.donations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Donations and only return the `id`
     * const donationsWithIdOnly = await prisma.donations.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends donationsCreateManyAndReturnArgs>(args?: SelectSubset<T, donationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$donationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Donations.
     * @param {donationsDeleteArgs} args - Arguments to delete one Donations.
     * @example
     * // Delete one Donations
     * const Donations = await prisma.donations.delete({
     *   where: {
     *     // ... filter to delete one Donations
     *   }
     * })
     * 
     */
    delete<T extends donationsDeleteArgs>(args: SelectSubset<T, donationsDeleteArgs<ExtArgs>>): Prisma__donationsClient<$Result.GetResult<Prisma.$donationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Donations.
     * @param {donationsUpdateArgs} args - Arguments to update one Donations.
     * @example
     * // Update one Donations
     * const donations = await prisma.donations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends donationsUpdateArgs>(args: SelectSubset<T, donationsUpdateArgs<ExtArgs>>): Prisma__donationsClient<$Result.GetResult<Prisma.$donationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Donations.
     * @param {donationsDeleteManyArgs} args - Arguments to filter Donations to delete.
     * @example
     * // Delete a few Donations
     * const { count } = await prisma.donations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends donationsDeleteManyArgs>(args?: SelectSubset<T, donationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Donations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {donationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Donations
     * const donations = await prisma.donations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends donationsUpdateManyArgs>(args: SelectSubset<T, donationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Donations and returns the data updated in the database.
     * @param {donationsUpdateManyAndReturnArgs} args - Arguments to update many Donations.
     * @example
     * // Update many Donations
     * const donations = await prisma.donations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Donations and only return the `id`
     * const donationsWithIdOnly = await prisma.donations.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends donationsUpdateManyAndReturnArgs>(args: SelectSubset<T, donationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$donationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Donations.
     * @param {donationsUpsertArgs} args - Arguments to update or create a Donations.
     * @example
     * // Update or create a Donations
     * const donations = await prisma.donations.upsert({
     *   create: {
     *     // ... data to create a Donations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Donations we want to update
     *   }
     * })
     */
    upsert<T extends donationsUpsertArgs>(args: SelectSubset<T, donationsUpsertArgs<ExtArgs>>): Prisma__donationsClient<$Result.GetResult<Prisma.$donationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Donations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {donationsCountArgs} args - Arguments to filter Donations to count.
     * @example
     * // Count the number of Donations
     * const count = await prisma.donations.count({
     *   where: {
     *     // ... the filter for the Donations we want to count
     *   }
     * })
    **/
    count<T extends donationsCountArgs>(
      args?: Subset<T, donationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DonationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Donations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DonationsAggregateArgs>(args: Subset<T, DonationsAggregateArgs>): Prisma.PrismaPromise<GetDonationsAggregateType<T>>

    /**
     * Group by Donations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {donationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends donationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: donationsGroupByArgs['orderBy'] }
        : { orderBy?: donationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, donationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDonationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the donations model
   */
  readonly fields: donationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for donations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__donationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projects<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends donations$usersArgs<ExtArgs> = {}>(args?: Subset<T, donations$usersArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the donations model
   */
  interface donationsFieldRefs {
    readonly id: FieldRef<"donations", 'BigInt'>
    readonly donation_id: FieldRef<"donations", 'String'>
    readonly project_id: FieldRef<"donations", 'BigInt'>
    readonly user_id: FieldRef<"donations", 'BigInt'>
    readonly donor_name: FieldRef<"donations", 'String'>
    readonly donor_email: FieldRef<"donations", 'String'>
    readonly donor_phone: FieldRef<"donations", 'String'>
    readonly amount: FieldRef<"donations", 'BigInt'>
    readonly frequency: FieldRef<"donations", 'String'>
    readonly status: FieldRef<"donations", 'String'>
    readonly payment_method: FieldRef<"donations", 'String'>
    readonly payment_channel: FieldRef<"donations", 'String'>
    readonly transaction_id: FieldRef<"donations", 'String'>
    readonly paid_at: FieldRef<"donations", 'DateTime'>
    readonly message: FieldRef<"donations", 'String'>
    readonly is_anonymous: FieldRef<"donations", 'Boolean'>
    readonly metadata: FieldRef<"donations", 'Json'>
    readonly created_at: FieldRef<"donations", 'DateTime'>
    readonly updated_at: FieldRef<"donations", 'DateTime'>
    readonly deleted_at: FieldRef<"donations", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * donations findUnique
   */
  export type donationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donations
     */
    select?: donationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the donations
     */
    omit?: donationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: donationsInclude<ExtArgs> | null
    /**
     * Filter, which donations to fetch.
     */
    where: donationsWhereUniqueInput
  }

  /**
   * donations findUniqueOrThrow
   */
  export type donationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donations
     */
    select?: donationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the donations
     */
    omit?: donationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: donationsInclude<ExtArgs> | null
    /**
     * Filter, which donations to fetch.
     */
    where: donationsWhereUniqueInput
  }

  /**
   * donations findFirst
   */
  export type donationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donations
     */
    select?: donationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the donations
     */
    omit?: donationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: donationsInclude<ExtArgs> | null
    /**
     * Filter, which donations to fetch.
     */
    where?: donationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of donations to fetch.
     */
    orderBy?: donationsOrderByWithRelationInput | donationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for donations.
     */
    cursor?: donationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` donations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` donations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of donations.
     */
    distinct?: DonationsScalarFieldEnum | DonationsScalarFieldEnum[]
  }

  /**
   * donations findFirstOrThrow
   */
  export type donationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donations
     */
    select?: donationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the donations
     */
    omit?: donationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: donationsInclude<ExtArgs> | null
    /**
     * Filter, which donations to fetch.
     */
    where?: donationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of donations to fetch.
     */
    orderBy?: donationsOrderByWithRelationInput | donationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for donations.
     */
    cursor?: donationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` donations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` donations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of donations.
     */
    distinct?: DonationsScalarFieldEnum | DonationsScalarFieldEnum[]
  }

  /**
   * donations findMany
   */
  export type donationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donations
     */
    select?: donationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the donations
     */
    omit?: donationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: donationsInclude<ExtArgs> | null
    /**
     * Filter, which donations to fetch.
     */
    where?: donationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of donations to fetch.
     */
    orderBy?: donationsOrderByWithRelationInput | donationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing donations.
     */
    cursor?: donationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` donations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` donations.
     */
    skip?: number
    distinct?: DonationsScalarFieldEnum | DonationsScalarFieldEnum[]
  }

  /**
   * donations create
   */
  export type donationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donations
     */
    select?: donationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the donations
     */
    omit?: donationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: donationsInclude<ExtArgs> | null
    /**
     * The data needed to create a donations.
     */
    data: XOR<donationsCreateInput, donationsUncheckedCreateInput>
  }

  /**
   * donations createMany
   */
  export type donationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many donations.
     */
    data: donationsCreateManyInput | donationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * donations createManyAndReturn
   */
  export type donationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donations
     */
    select?: donationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the donations
     */
    omit?: donationsOmit<ExtArgs> | null
    /**
     * The data used to create many donations.
     */
    data: donationsCreateManyInput | donationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: donationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * donations update
   */
  export type donationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donations
     */
    select?: donationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the donations
     */
    omit?: donationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: donationsInclude<ExtArgs> | null
    /**
     * The data needed to update a donations.
     */
    data: XOR<donationsUpdateInput, donationsUncheckedUpdateInput>
    /**
     * Choose, which donations to update.
     */
    where: donationsWhereUniqueInput
  }

  /**
   * donations updateMany
   */
  export type donationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update donations.
     */
    data: XOR<donationsUpdateManyMutationInput, donationsUncheckedUpdateManyInput>
    /**
     * Filter which donations to update
     */
    where?: donationsWhereInput
    /**
     * Limit how many donations to update.
     */
    limit?: number
  }

  /**
   * donations updateManyAndReturn
   */
  export type donationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donations
     */
    select?: donationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the donations
     */
    omit?: donationsOmit<ExtArgs> | null
    /**
     * The data used to update donations.
     */
    data: XOR<donationsUpdateManyMutationInput, donationsUncheckedUpdateManyInput>
    /**
     * Filter which donations to update
     */
    where?: donationsWhereInput
    /**
     * Limit how many donations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: donationsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * donations upsert
   */
  export type donationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donations
     */
    select?: donationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the donations
     */
    omit?: donationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: donationsInclude<ExtArgs> | null
    /**
     * The filter to search for the donations to update in case it exists.
     */
    where: donationsWhereUniqueInput
    /**
     * In case the donations found by the `where` argument doesn't exist, create a new donations with this data.
     */
    create: XOR<donationsCreateInput, donationsUncheckedCreateInput>
    /**
     * In case the donations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<donationsUpdateInput, donationsUncheckedUpdateInput>
  }

  /**
   * donations delete
   */
  export type donationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donations
     */
    select?: donationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the donations
     */
    omit?: donationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: donationsInclude<ExtArgs> | null
    /**
     * Filter which donations to delete.
     */
    where: donationsWhereUniqueInput
  }

  /**
   * donations deleteMany
   */
  export type donationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which donations to delete
     */
    where?: donationsWhereInput
    /**
     * Limit how many donations to delete.
     */
    limit?: number
  }

  /**
   * donations.users
   */
  export type donations$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * donations without action
   */
  export type donationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donations
     */
    select?: donationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the donations
     */
    omit?: donationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: donationsInclude<ExtArgs> | null
  }


  /**
   * Model migrations
   */

  export type AggregateMigrations = {
    _count: MigrationsCountAggregateOutputType | null
    _avg: MigrationsAvgAggregateOutputType | null
    _sum: MigrationsSumAggregateOutputType | null
    _min: MigrationsMinAggregateOutputType | null
    _max: MigrationsMaxAggregateOutputType | null
  }

  export type MigrationsAvgAggregateOutputType = {
    id: number | null
    batch: number | null
  }

  export type MigrationsSumAggregateOutputType = {
    id: number | null
    batch: number | null
  }

  export type MigrationsMinAggregateOutputType = {
    id: number | null
    migration: string | null
    batch: number | null
  }

  export type MigrationsMaxAggregateOutputType = {
    id: number | null
    migration: string | null
    batch: number | null
  }

  export type MigrationsCountAggregateOutputType = {
    id: number
    migration: number
    batch: number
    _all: number
  }


  export type MigrationsAvgAggregateInputType = {
    id?: true
    batch?: true
  }

  export type MigrationsSumAggregateInputType = {
    id?: true
    batch?: true
  }

  export type MigrationsMinAggregateInputType = {
    id?: true
    migration?: true
    batch?: true
  }

  export type MigrationsMaxAggregateInputType = {
    id?: true
    migration?: true
    batch?: true
  }

  export type MigrationsCountAggregateInputType = {
    id?: true
    migration?: true
    batch?: true
    _all?: true
  }

  export type MigrationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which migrations to aggregate.
     */
    where?: migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationsOrderByWithRelationInput | migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned migrations
    **/
    _count?: true | MigrationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MigrationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MigrationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MigrationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MigrationsMaxAggregateInputType
  }

  export type GetMigrationsAggregateType<T extends MigrationsAggregateArgs> = {
        [P in keyof T & keyof AggregateMigrations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMigrations[P]>
      : GetScalarType<T[P], AggregateMigrations[P]>
  }




  export type migrationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: migrationsWhereInput
    orderBy?: migrationsOrderByWithAggregationInput | migrationsOrderByWithAggregationInput[]
    by: MigrationsScalarFieldEnum[] | MigrationsScalarFieldEnum
    having?: migrationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MigrationsCountAggregateInputType | true
    _avg?: MigrationsAvgAggregateInputType
    _sum?: MigrationsSumAggregateInputType
    _min?: MigrationsMinAggregateInputType
    _max?: MigrationsMaxAggregateInputType
  }

  export type MigrationsGroupByOutputType = {
    id: number
    migration: string
    batch: number
    _count: MigrationsCountAggregateOutputType | null
    _avg: MigrationsAvgAggregateOutputType | null
    _sum: MigrationsSumAggregateOutputType | null
    _min: MigrationsMinAggregateOutputType | null
    _max: MigrationsMaxAggregateOutputType | null
  }

  type GetMigrationsGroupByPayload<T extends migrationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MigrationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MigrationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MigrationsGroupByOutputType[P]>
            : GetScalarType<T[P], MigrationsGroupByOutputType[P]>
        }
      >
    >


  export type migrationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    migration?: boolean
    batch?: boolean
  }, ExtArgs["result"]["migrations"]>

  export type migrationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    migration?: boolean
    batch?: boolean
  }, ExtArgs["result"]["migrations"]>

  export type migrationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    migration?: boolean
    batch?: boolean
  }, ExtArgs["result"]["migrations"]>

  export type migrationsSelectScalar = {
    id?: boolean
    migration?: boolean
    batch?: boolean
  }

  export type migrationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "migration" | "batch", ExtArgs["result"]["migrations"]>

  export type $migrationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "migrations"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      migration: string
      batch: number
    }, ExtArgs["result"]["migrations"]>
    composites: {}
  }

  type migrationsGetPayload<S extends boolean | null | undefined | migrationsDefaultArgs> = $Result.GetResult<Prisma.$migrationsPayload, S>

  type migrationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<migrationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MigrationsCountAggregateInputType | true
    }

  export interface migrationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['migrations'], meta: { name: 'migrations' } }
    /**
     * Find zero or one Migrations that matches the filter.
     * @param {migrationsFindUniqueArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends migrationsFindUniqueArgs>(args: SelectSubset<T, migrationsFindUniqueArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Migrations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {migrationsFindUniqueOrThrowArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends migrationsFindUniqueOrThrowArgs>(args: SelectSubset<T, migrationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Migrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsFindFirstArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends migrationsFindFirstArgs>(args?: SelectSubset<T, migrationsFindFirstArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Migrations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsFindFirstOrThrowArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends migrationsFindFirstOrThrowArgs>(args?: SelectSubset<T, migrationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Migrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Migrations
     * const migrations = await prisma.migrations.findMany()
     * 
     * // Get first 10 Migrations
     * const migrations = await prisma.migrations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const migrationsWithIdOnly = await prisma.migrations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends migrationsFindManyArgs>(args?: SelectSubset<T, migrationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Migrations.
     * @param {migrationsCreateArgs} args - Arguments to create a Migrations.
     * @example
     * // Create one Migrations
     * const Migrations = await prisma.migrations.create({
     *   data: {
     *     // ... data to create a Migrations
     *   }
     * })
     * 
     */
    create<T extends migrationsCreateArgs>(args: SelectSubset<T, migrationsCreateArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Migrations.
     * @param {migrationsCreateManyArgs} args - Arguments to create many Migrations.
     * @example
     * // Create many Migrations
     * const migrations = await prisma.migrations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends migrationsCreateManyArgs>(args?: SelectSubset<T, migrationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Migrations and returns the data saved in the database.
     * @param {migrationsCreateManyAndReturnArgs} args - Arguments to create many Migrations.
     * @example
     * // Create many Migrations
     * const migrations = await prisma.migrations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Migrations and only return the `id`
     * const migrationsWithIdOnly = await prisma.migrations.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends migrationsCreateManyAndReturnArgs>(args?: SelectSubset<T, migrationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Migrations.
     * @param {migrationsDeleteArgs} args - Arguments to delete one Migrations.
     * @example
     * // Delete one Migrations
     * const Migrations = await prisma.migrations.delete({
     *   where: {
     *     // ... filter to delete one Migrations
     *   }
     * })
     * 
     */
    delete<T extends migrationsDeleteArgs>(args: SelectSubset<T, migrationsDeleteArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Migrations.
     * @param {migrationsUpdateArgs} args - Arguments to update one Migrations.
     * @example
     * // Update one Migrations
     * const migrations = await prisma.migrations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends migrationsUpdateArgs>(args: SelectSubset<T, migrationsUpdateArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Migrations.
     * @param {migrationsDeleteManyArgs} args - Arguments to filter Migrations to delete.
     * @example
     * // Delete a few Migrations
     * const { count } = await prisma.migrations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends migrationsDeleteManyArgs>(args?: SelectSubset<T, migrationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Migrations
     * const migrations = await prisma.migrations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends migrationsUpdateManyArgs>(args: SelectSubset<T, migrationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Migrations and returns the data updated in the database.
     * @param {migrationsUpdateManyAndReturnArgs} args - Arguments to update many Migrations.
     * @example
     * // Update many Migrations
     * const migrations = await prisma.migrations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Migrations and only return the `id`
     * const migrationsWithIdOnly = await prisma.migrations.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends migrationsUpdateManyAndReturnArgs>(args: SelectSubset<T, migrationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Migrations.
     * @param {migrationsUpsertArgs} args - Arguments to update or create a Migrations.
     * @example
     * // Update or create a Migrations
     * const migrations = await prisma.migrations.upsert({
     *   create: {
     *     // ... data to create a Migrations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Migrations we want to update
     *   }
     * })
     */
    upsert<T extends migrationsUpsertArgs>(args: SelectSubset<T, migrationsUpsertArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsCountArgs} args - Arguments to filter Migrations to count.
     * @example
     * // Count the number of Migrations
     * const count = await prisma.migrations.count({
     *   where: {
     *     // ... the filter for the Migrations we want to count
     *   }
     * })
    **/
    count<T extends migrationsCountArgs>(
      args?: Subset<T, migrationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MigrationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MigrationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MigrationsAggregateArgs>(args: Subset<T, MigrationsAggregateArgs>): Prisma.PrismaPromise<GetMigrationsAggregateType<T>>

    /**
     * Group by Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends migrationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: migrationsGroupByArgs['orderBy'] }
        : { orderBy?: migrationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, migrationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMigrationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the migrations model
   */
  readonly fields: migrationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for migrations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__migrationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the migrations model
   */
  interface migrationsFieldRefs {
    readonly id: FieldRef<"migrations", 'Int'>
    readonly migration: FieldRef<"migrations", 'String'>
    readonly batch: FieldRef<"migrations", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * migrations findUnique
   */
  export type migrationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where: migrationsWhereUniqueInput
  }

  /**
   * migrations findUniqueOrThrow
   */
  export type migrationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where: migrationsWhereUniqueInput
  }

  /**
   * migrations findFirst
   */
  export type migrationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where?: migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationsOrderByWithRelationInput | migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for migrations.
     */
    cursor?: migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of migrations.
     */
    distinct?: MigrationsScalarFieldEnum | MigrationsScalarFieldEnum[]
  }

  /**
   * migrations findFirstOrThrow
   */
  export type migrationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where?: migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationsOrderByWithRelationInput | migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for migrations.
     */
    cursor?: migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of migrations.
     */
    distinct?: MigrationsScalarFieldEnum | MigrationsScalarFieldEnum[]
  }

  /**
   * migrations findMany
   */
  export type migrationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where?: migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationsOrderByWithRelationInput | migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing migrations.
     */
    cursor?: migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    distinct?: MigrationsScalarFieldEnum | MigrationsScalarFieldEnum[]
  }

  /**
   * migrations create
   */
  export type migrationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * The data needed to create a migrations.
     */
    data: XOR<migrationsCreateInput, migrationsUncheckedCreateInput>
  }

  /**
   * migrations createMany
   */
  export type migrationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many migrations.
     */
    data: migrationsCreateManyInput | migrationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * migrations createManyAndReturn
   */
  export type migrationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * The data used to create many migrations.
     */
    data: migrationsCreateManyInput | migrationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * migrations update
   */
  export type migrationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * The data needed to update a migrations.
     */
    data: XOR<migrationsUpdateInput, migrationsUncheckedUpdateInput>
    /**
     * Choose, which migrations to update.
     */
    where: migrationsWhereUniqueInput
  }

  /**
   * migrations updateMany
   */
  export type migrationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update migrations.
     */
    data: XOR<migrationsUpdateManyMutationInput, migrationsUncheckedUpdateManyInput>
    /**
     * Filter which migrations to update
     */
    where?: migrationsWhereInput
    /**
     * Limit how many migrations to update.
     */
    limit?: number
  }

  /**
   * migrations updateManyAndReturn
   */
  export type migrationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * The data used to update migrations.
     */
    data: XOR<migrationsUpdateManyMutationInput, migrationsUncheckedUpdateManyInput>
    /**
     * Filter which migrations to update
     */
    where?: migrationsWhereInput
    /**
     * Limit how many migrations to update.
     */
    limit?: number
  }

  /**
   * migrations upsert
   */
  export type migrationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * The filter to search for the migrations to update in case it exists.
     */
    where: migrationsWhereUniqueInput
    /**
     * In case the migrations found by the `where` argument doesn't exist, create a new migrations with this data.
     */
    create: XOR<migrationsCreateInput, migrationsUncheckedCreateInput>
    /**
     * In case the migrations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<migrationsUpdateInput, migrationsUncheckedUpdateInput>
  }

  /**
   * migrations delete
   */
  export type migrationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter which migrations to delete.
     */
    where: migrationsWhereUniqueInput
  }

  /**
   * migrations deleteMany
   */
  export type migrationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which migrations to delete
     */
    where?: migrationsWhereInput
    /**
     * Limit how many migrations to delete.
     */
    limit?: number
  }

  /**
   * migrations without action
   */
  export type migrationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
  }


  /**
   * Model model_has_permissions
   */

  export type AggregateModel_has_permissions = {
    _count: Model_has_permissionsCountAggregateOutputType | null
    _avg: Model_has_permissionsAvgAggregateOutputType | null
    _sum: Model_has_permissionsSumAggregateOutputType | null
    _min: Model_has_permissionsMinAggregateOutputType | null
    _max: Model_has_permissionsMaxAggregateOutputType | null
  }

  export type Model_has_permissionsAvgAggregateOutputType = {
    permission_id: number | null
    model_id: number | null
  }

  export type Model_has_permissionsSumAggregateOutputType = {
    permission_id: bigint | null
    model_id: bigint | null
  }

  export type Model_has_permissionsMinAggregateOutputType = {
    permission_id: bigint | null
    model_type: string | null
    model_id: bigint | null
  }

  export type Model_has_permissionsMaxAggregateOutputType = {
    permission_id: bigint | null
    model_type: string | null
    model_id: bigint | null
  }

  export type Model_has_permissionsCountAggregateOutputType = {
    permission_id: number
    model_type: number
    model_id: number
    _all: number
  }


  export type Model_has_permissionsAvgAggregateInputType = {
    permission_id?: true
    model_id?: true
  }

  export type Model_has_permissionsSumAggregateInputType = {
    permission_id?: true
    model_id?: true
  }

  export type Model_has_permissionsMinAggregateInputType = {
    permission_id?: true
    model_type?: true
    model_id?: true
  }

  export type Model_has_permissionsMaxAggregateInputType = {
    permission_id?: true
    model_type?: true
    model_id?: true
  }

  export type Model_has_permissionsCountAggregateInputType = {
    permission_id?: true
    model_type?: true
    model_id?: true
    _all?: true
  }

  export type Model_has_permissionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which model_has_permissions to aggregate.
     */
    where?: model_has_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of model_has_permissions to fetch.
     */
    orderBy?: model_has_permissionsOrderByWithRelationInput | model_has_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: model_has_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` model_has_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` model_has_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned model_has_permissions
    **/
    _count?: true | Model_has_permissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Model_has_permissionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Model_has_permissionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Model_has_permissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Model_has_permissionsMaxAggregateInputType
  }

  export type GetModel_has_permissionsAggregateType<T extends Model_has_permissionsAggregateArgs> = {
        [P in keyof T & keyof AggregateModel_has_permissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModel_has_permissions[P]>
      : GetScalarType<T[P], AggregateModel_has_permissions[P]>
  }




  export type model_has_permissionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: model_has_permissionsWhereInput
    orderBy?: model_has_permissionsOrderByWithAggregationInput | model_has_permissionsOrderByWithAggregationInput[]
    by: Model_has_permissionsScalarFieldEnum[] | Model_has_permissionsScalarFieldEnum
    having?: model_has_permissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Model_has_permissionsCountAggregateInputType | true
    _avg?: Model_has_permissionsAvgAggregateInputType
    _sum?: Model_has_permissionsSumAggregateInputType
    _min?: Model_has_permissionsMinAggregateInputType
    _max?: Model_has_permissionsMaxAggregateInputType
  }

  export type Model_has_permissionsGroupByOutputType = {
    permission_id: bigint
    model_type: string
    model_id: bigint
    _count: Model_has_permissionsCountAggregateOutputType | null
    _avg: Model_has_permissionsAvgAggregateOutputType | null
    _sum: Model_has_permissionsSumAggregateOutputType | null
    _min: Model_has_permissionsMinAggregateOutputType | null
    _max: Model_has_permissionsMaxAggregateOutputType | null
  }

  type GetModel_has_permissionsGroupByPayload<T extends model_has_permissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Model_has_permissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Model_has_permissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Model_has_permissionsGroupByOutputType[P]>
            : GetScalarType<T[P], Model_has_permissionsGroupByOutputType[P]>
        }
      >
    >


  export type model_has_permissionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    permission_id?: boolean
    model_type?: boolean
    model_id?: boolean
    permissions?: boolean | permissionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["model_has_permissions"]>

  export type model_has_permissionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    permission_id?: boolean
    model_type?: boolean
    model_id?: boolean
    permissions?: boolean | permissionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["model_has_permissions"]>

  export type model_has_permissionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    permission_id?: boolean
    model_type?: boolean
    model_id?: boolean
    permissions?: boolean | permissionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["model_has_permissions"]>

  export type model_has_permissionsSelectScalar = {
    permission_id?: boolean
    model_type?: boolean
    model_id?: boolean
  }

  export type model_has_permissionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"permission_id" | "model_type" | "model_id", ExtArgs["result"]["model_has_permissions"]>
  export type model_has_permissionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | permissionsDefaultArgs<ExtArgs>
  }
  export type model_has_permissionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | permissionsDefaultArgs<ExtArgs>
  }
  export type model_has_permissionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | permissionsDefaultArgs<ExtArgs>
  }

  export type $model_has_permissionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "model_has_permissions"
    objects: {
      permissions: Prisma.$permissionsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      permission_id: bigint
      model_type: string
      model_id: bigint
    }, ExtArgs["result"]["model_has_permissions"]>
    composites: {}
  }

  type model_has_permissionsGetPayload<S extends boolean | null | undefined | model_has_permissionsDefaultArgs> = $Result.GetResult<Prisma.$model_has_permissionsPayload, S>

  type model_has_permissionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<model_has_permissionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Model_has_permissionsCountAggregateInputType | true
    }

  export interface model_has_permissionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['model_has_permissions'], meta: { name: 'model_has_permissions' } }
    /**
     * Find zero or one Model_has_permissions that matches the filter.
     * @param {model_has_permissionsFindUniqueArgs} args - Arguments to find a Model_has_permissions
     * @example
     * // Get one Model_has_permissions
     * const model_has_permissions = await prisma.model_has_permissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends model_has_permissionsFindUniqueArgs>(args: SelectSubset<T, model_has_permissionsFindUniqueArgs<ExtArgs>>): Prisma__model_has_permissionsClient<$Result.GetResult<Prisma.$model_has_permissionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Model_has_permissions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {model_has_permissionsFindUniqueOrThrowArgs} args - Arguments to find a Model_has_permissions
     * @example
     * // Get one Model_has_permissions
     * const model_has_permissions = await prisma.model_has_permissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends model_has_permissionsFindUniqueOrThrowArgs>(args: SelectSubset<T, model_has_permissionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__model_has_permissionsClient<$Result.GetResult<Prisma.$model_has_permissionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Model_has_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {model_has_permissionsFindFirstArgs} args - Arguments to find a Model_has_permissions
     * @example
     * // Get one Model_has_permissions
     * const model_has_permissions = await prisma.model_has_permissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends model_has_permissionsFindFirstArgs>(args?: SelectSubset<T, model_has_permissionsFindFirstArgs<ExtArgs>>): Prisma__model_has_permissionsClient<$Result.GetResult<Prisma.$model_has_permissionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Model_has_permissions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {model_has_permissionsFindFirstOrThrowArgs} args - Arguments to find a Model_has_permissions
     * @example
     * // Get one Model_has_permissions
     * const model_has_permissions = await prisma.model_has_permissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends model_has_permissionsFindFirstOrThrowArgs>(args?: SelectSubset<T, model_has_permissionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__model_has_permissionsClient<$Result.GetResult<Prisma.$model_has_permissionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Model_has_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {model_has_permissionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Model_has_permissions
     * const model_has_permissions = await prisma.model_has_permissions.findMany()
     * 
     * // Get first 10 Model_has_permissions
     * const model_has_permissions = await prisma.model_has_permissions.findMany({ take: 10 })
     * 
     * // Only select the `permission_id`
     * const model_has_permissionsWithPermission_idOnly = await prisma.model_has_permissions.findMany({ select: { permission_id: true } })
     * 
     */
    findMany<T extends model_has_permissionsFindManyArgs>(args?: SelectSubset<T, model_has_permissionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$model_has_permissionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Model_has_permissions.
     * @param {model_has_permissionsCreateArgs} args - Arguments to create a Model_has_permissions.
     * @example
     * // Create one Model_has_permissions
     * const Model_has_permissions = await prisma.model_has_permissions.create({
     *   data: {
     *     // ... data to create a Model_has_permissions
     *   }
     * })
     * 
     */
    create<T extends model_has_permissionsCreateArgs>(args: SelectSubset<T, model_has_permissionsCreateArgs<ExtArgs>>): Prisma__model_has_permissionsClient<$Result.GetResult<Prisma.$model_has_permissionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Model_has_permissions.
     * @param {model_has_permissionsCreateManyArgs} args - Arguments to create many Model_has_permissions.
     * @example
     * // Create many Model_has_permissions
     * const model_has_permissions = await prisma.model_has_permissions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends model_has_permissionsCreateManyArgs>(args?: SelectSubset<T, model_has_permissionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Model_has_permissions and returns the data saved in the database.
     * @param {model_has_permissionsCreateManyAndReturnArgs} args - Arguments to create many Model_has_permissions.
     * @example
     * // Create many Model_has_permissions
     * const model_has_permissions = await prisma.model_has_permissions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Model_has_permissions and only return the `permission_id`
     * const model_has_permissionsWithPermission_idOnly = await prisma.model_has_permissions.createManyAndReturn({
     *   select: { permission_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends model_has_permissionsCreateManyAndReturnArgs>(args?: SelectSubset<T, model_has_permissionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$model_has_permissionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Model_has_permissions.
     * @param {model_has_permissionsDeleteArgs} args - Arguments to delete one Model_has_permissions.
     * @example
     * // Delete one Model_has_permissions
     * const Model_has_permissions = await prisma.model_has_permissions.delete({
     *   where: {
     *     // ... filter to delete one Model_has_permissions
     *   }
     * })
     * 
     */
    delete<T extends model_has_permissionsDeleteArgs>(args: SelectSubset<T, model_has_permissionsDeleteArgs<ExtArgs>>): Prisma__model_has_permissionsClient<$Result.GetResult<Prisma.$model_has_permissionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Model_has_permissions.
     * @param {model_has_permissionsUpdateArgs} args - Arguments to update one Model_has_permissions.
     * @example
     * // Update one Model_has_permissions
     * const model_has_permissions = await prisma.model_has_permissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends model_has_permissionsUpdateArgs>(args: SelectSubset<T, model_has_permissionsUpdateArgs<ExtArgs>>): Prisma__model_has_permissionsClient<$Result.GetResult<Prisma.$model_has_permissionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Model_has_permissions.
     * @param {model_has_permissionsDeleteManyArgs} args - Arguments to filter Model_has_permissions to delete.
     * @example
     * // Delete a few Model_has_permissions
     * const { count } = await prisma.model_has_permissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends model_has_permissionsDeleteManyArgs>(args?: SelectSubset<T, model_has_permissionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Model_has_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {model_has_permissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Model_has_permissions
     * const model_has_permissions = await prisma.model_has_permissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends model_has_permissionsUpdateManyArgs>(args: SelectSubset<T, model_has_permissionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Model_has_permissions and returns the data updated in the database.
     * @param {model_has_permissionsUpdateManyAndReturnArgs} args - Arguments to update many Model_has_permissions.
     * @example
     * // Update many Model_has_permissions
     * const model_has_permissions = await prisma.model_has_permissions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Model_has_permissions and only return the `permission_id`
     * const model_has_permissionsWithPermission_idOnly = await prisma.model_has_permissions.updateManyAndReturn({
     *   select: { permission_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends model_has_permissionsUpdateManyAndReturnArgs>(args: SelectSubset<T, model_has_permissionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$model_has_permissionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Model_has_permissions.
     * @param {model_has_permissionsUpsertArgs} args - Arguments to update or create a Model_has_permissions.
     * @example
     * // Update or create a Model_has_permissions
     * const model_has_permissions = await prisma.model_has_permissions.upsert({
     *   create: {
     *     // ... data to create a Model_has_permissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Model_has_permissions we want to update
     *   }
     * })
     */
    upsert<T extends model_has_permissionsUpsertArgs>(args: SelectSubset<T, model_has_permissionsUpsertArgs<ExtArgs>>): Prisma__model_has_permissionsClient<$Result.GetResult<Prisma.$model_has_permissionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Model_has_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {model_has_permissionsCountArgs} args - Arguments to filter Model_has_permissions to count.
     * @example
     * // Count the number of Model_has_permissions
     * const count = await prisma.model_has_permissions.count({
     *   where: {
     *     // ... the filter for the Model_has_permissions we want to count
     *   }
     * })
    **/
    count<T extends model_has_permissionsCountArgs>(
      args?: Subset<T, model_has_permissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Model_has_permissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Model_has_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Model_has_permissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Model_has_permissionsAggregateArgs>(args: Subset<T, Model_has_permissionsAggregateArgs>): Prisma.PrismaPromise<GetModel_has_permissionsAggregateType<T>>

    /**
     * Group by Model_has_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {model_has_permissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends model_has_permissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: model_has_permissionsGroupByArgs['orderBy'] }
        : { orderBy?: model_has_permissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, model_has_permissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModel_has_permissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the model_has_permissions model
   */
  readonly fields: model_has_permissionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for model_has_permissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__model_has_permissionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    permissions<T extends permissionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, permissionsDefaultArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the model_has_permissions model
   */
  interface model_has_permissionsFieldRefs {
    readonly permission_id: FieldRef<"model_has_permissions", 'BigInt'>
    readonly model_type: FieldRef<"model_has_permissions", 'String'>
    readonly model_id: FieldRef<"model_has_permissions", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * model_has_permissions findUnique
   */
  export type model_has_permissionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_permissions
     */
    select?: model_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_permissions
     */
    omit?: model_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which model_has_permissions to fetch.
     */
    where: model_has_permissionsWhereUniqueInput
  }

  /**
   * model_has_permissions findUniqueOrThrow
   */
  export type model_has_permissionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_permissions
     */
    select?: model_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_permissions
     */
    omit?: model_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which model_has_permissions to fetch.
     */
    where: model_has_permissionsWhereUniqueInput
  }

  /**
   * model_has_permissions findFirst
   */
  export type model_has_permissionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_permissions
     */
    select?: model_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_permissions
     */
    omit?: model_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which model_has_permissions to fetch.
     */
    where?: model_has_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of model_has_permissions to fetch.
     */
    orderBy?: model_has_permissionsOrderByWithRelationInput | model_has_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for model_has_permissions.
     */
    cursor?: model_has_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` model_has_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` model_has_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of model_has_permissions.
     */
    distinct?: Model_has_permissionsScalarFieldEnum | Model_has_permissionsScalarFieldEnum[]
  }

  /**
   * model_has_permissions findFirstOrThrow
   */
  export type model_has_permissionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_permissions
     */
    select?: model_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_permissions
     */
    omit?: model_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which model_has_permissions to fetch.
     */
    where?: model_has_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of model_has_permissions to fetch.
     */
    orderBy?: model_has_permissionsOrderByWithRelationInput | model_has_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for model_has_permissions.
     */
    cursor?: model_has_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` model_has_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` model_has_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of model_has_permissions.
     */
    distinct?: Model_has_permissionsScalarFieldEnum | Model_has_permissionsScalarFieldEnum[]
  }

  /**
   * model_has_permissions findMany
   */
  export type model_has_permissionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_permissions
     */
    select?: model_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_permissions
     */
    omit?: model_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which model_has_permissions to fetch.
     */
    where?: model_has_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of model_has_permissions to fetch.
     */
    orderBy?: model_has_permissionsOrderByWithRelationInput | model_has_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing model_has_permissions.
     */
    cursor?: model_has_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` model_has_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` model_has_permissions.
     */
    skip?: number
    distinct?: Model_has_permissionsScalarFieldEnum | Model_has_permissionsScalarFieldEnum[]
  }

  /**
   * model_has_permissions create
   */
  export type model_has_permissionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_permissions
     */
    select?: model_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_permissions
     */
    omit?: model_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_permissionsInclude<ExtArgs> | null
    /**
     * The data needed to create a model_has_permissions.
     */
    data: XOR<model_has_permissionsCreateInput, model_has_permissionsUncheckedCreateInput>
  }

  /**
   * model_has_permissions createMany
   */
  export type model_has_permissionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many model_has_permissions.
     */
    data: model_has_permissionsCreateManyInput | model_has_permissionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * model_has_permissions createManyAndReturn
   */
  export type model_has_permissionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_permissions
     */
    select?: model_has_permissionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_permissions
     */
    omit?: model_has_permissionsOmit<ExtArgs> | null
    /**
     * The data used to create many model_has_permissions.
     */
    data: model_has_permissionsCreateManyInput | model_has_permissionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_permissionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * model_has_permissions update
   */
  export type model_has_permissionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_permissions
     */
    select?: model_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_permissions
     */
    omit?: model_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_permissionsInclude<ExtArgs> | null
    /**
     * The data needed to update a model_has_permissions.
     */
    data: XOR<model_has_permissionsUpdateInput, model_has_permissionsUncheckedUpdateInput>
    /**
     * Choose, which model_has_permissions to update.
     */
    where: model_has_permissionsWhereUniqueInput
  }

  /**
   * model_has_permissions updateMany
   */
  export type model_has_permissionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update model_has_permissions.
     */
    data: XOR<model_has_permissionsUpdateManyMutationInput, model_has_permissionsUncheckedUpdateManyInput>
    /**
     * Filter which model_has_permissions to update
     */
    where?: model_has_permissionsWhereInput
    /**
     * Limit how many model_has_permissions to update.
     */
    limit?: number
  }

  /**
   * model_has_permissions updateManyAndReturn
   */
  export type model_has_permissionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_permissions
     */
    select?: model_has_permissionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_permissions
     */
    omit?: model_has_permissionsOmit<ExtArgs> | null
    /**
     * The data used to update model_has_permissions.
     */
    data: XOR<model_has_permissionsUpdateManyMutationInput, model_has_permissionsUncheckedUpdateManyInput>
    /**
     * Filter which model_has_permissions to update
     */
    where?: model_has_permissionsWhereInput
    /**
     * Limit how many model_has_permissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_permissionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * model_has_permissions upsert
   */
  export type model_has_permissionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_permissions
     */
    select?: model_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_permissions
     */
    omit?: model_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_permissionsInclude<ExtArgs> | null
    /**
     * The filter to search for the model_has_permissions to update in case it exists.
     */
    where: model_has_permissionsWhereUniqueInput
    /**
     * In case the model_has_permissions found by the `where` argument doesn't exist, create a new model_has_permissions with this data.
     */
    create: XOR<model_has_permissionsCreateInput, model_has_permissionsUncheckedCreateInput>
    /**
     * In case the model_has_permissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<model_has_permissionsUpdateInput, model_has_permissionsUncheckedUpdateInput>
  }

  /**
   * model_has_permissions delete
   */
  export type model_has_permissionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_permissions
     */
    select?: model_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_permissions
     */
    omit?: model_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_permissionsInclude<ExtArgs> | null
    /**
     * Filter which model_has_permissions to delete.
     */
    where: model_has_permissionsWhereUniqueInput
  }

  /**
   * model_has_permissions deleteMany
   */
  export type model_has_permissionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which model_has_permissions to delete
     */
    where?: model_has_permissionsWhereInput
    /**
     * Limit how many model_has_permissions to delete.
     */
    limit?: number
  }

  /**
   * model_has_permissions without action
   */
  export type model_has_permissionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_permissions
     */
    select?: model_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_permissions
     */
    omit?: model_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_permissionsInclude<ExtArgs> | null
  }


  /**
   * Model model_has_roles
   */

  export type AggregateModel_has_roles = {
    _count: Model_has_rolesCountAggregateOutputType | null
    _avg: Model_has_rolesAvgAggregateOutputType | null
    _sum: Model_has_rolesSumAggregateOutputType | null
    _min: Model_has_rolesMinAggregateOutputType | null
    _max: Model_has_rolesMaxAggregateOutputType | null
  }

  export type Model_has_rolesAvgAggregateOutputType = {
    role_id: number | null
    model_id: number | null
  }

  export type Model_has_rolesSumAggregateOutputType = {
    role_id: bigint | null
    model_id: bigint | null
  }

  export type Model_has_rolesMinAggregateOutputType = {
    role_id: bigint | null
    model_type: string | null
    model_id: bigint | null
  }

  export type Model_has_rolesMaxAggregateOutputType = {
    role_id: bigint | null
    model_type: string | null
    model_id: bigint | null
  }

  export type Model_has_rolesCountAggregateOutputType = {
    role_id: number
    model_type: number
    model_id: number
    _all: number
  }


  export type Model_has_rolesAvgAggregateInputType = {
    role_id?: true
    model_id?: true
  }

  export type Model_has_rolesSumAggregateInputType = {
    role_id?: true
    model_id?: true
  }

  export type Model_has_rolesMinAggregateInputType = {
    role_id?: true
    model_type?: true
    model_id?: true
  }

  export type Model_has_rolesMaxAggregateInputType = {
    role_id?: true
    model_type?: true
    model_id?: true
  }

  export type Model_has_rolesCountAggregateInputType = {
    role_id?: true
    model_type?: true
    model_id?: true
    _all?: true
  }

  export type Model_has_rolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which model_has_roles to aggregate.
     */
    where?: model_has_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of model_has_roles to fetch.
     */
    orderBy?: model_has_rolesOrderByWithRelationInput | model_has_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: model_has_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` model_has_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` model_has_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned model_has_roles
    **/
    _count?: true | Model_has_rolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Model_has_rolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Model_has_rolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Model_has_rolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Model_has_rolesMaxAggregateInputType
  }

  export type GetModel_has_rolesAggregateType<T extends Model_has_rolesAggregateArgs> = {
        [P in keyof T & keyof AggregateModel_has_roles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModel_has_roles[P]>
      : GetScalarType<T[P], AggregateModel_has_roles[P]>
  }




  export type model_has_rolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: model_has_rolesWhereInput
    orderBy?: model_has_rolesOrderByWithAggregationInput | model_has_rolesOrderByWithAggregationInput[]
    by: Model_has_rolesScalarFieldEnum[] | Model_has_rolesScalarFieldEnum
    having?: model_has_rolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Model_has_rolesCountAggregateInputType | true
    _avg?: Model_has_rolesAvgAggregateInputType
    _sum?: Model_has_rolesSumAggregateInputType
    _min?: Model_has_rolesMinAggregateInputType
    _max?: Model_has_rolesMaxAggregateInputType
  }

  export type Model_has_rolesGroupByOutputType = {
    role_id: bigint
    model_type: string
    model_id: bigint
    _count: Model_has_rolesCountAggregateOutputType | null
    _avg: Model_has_rolesAvgAggregateOutputType | null
    _sum: Model_has_rolesSumAggregateOutputType | null
    _min: Model_has_rolesMinAggregateOutputType | null
    _max: Model_has_rolesMaxAggregateOutputType | null
  }

  type GetModel_has_rolesGroupByPayload<T extends model_has_rolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Model_has_rolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Model_has_rolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Model_has_rolesGroupByOutputType[P]>
            : GetScalarType<T[P], Model_has_rolesGroupByOutputType[P]>
        }
      >
    >


  export type model_has_rolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    role_id?: boolean
    model_type?: boolean
    model_id?: boolean
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["model_has_roles"]>

  export type model_has_rolesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    role_id?: boolean
    model_type?: boolean
    model_id?: boolean
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["model_has_roles"]>

  export type model_has_rolesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    role_id?: boolean
    model_type?: boolean
    model_id?: boolean
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["model_has_roles"]>

  export type model_has_rolesSelectScalar = {
    role_id?: boolean
    model_type?: boolean
    model_id?: boolean
  }

  export type model_has_rolesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"role_id" | "model_type" | "model_id", ExtArgs["result"]["model_has_roles"]>
  export type model_has_rolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }
  export type model_has_rolesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }
  export type model_has_rolesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }

  export type $model_has_rolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "model_has_roles"
    objects: {
      roles: Prisma.$rolesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      role_id: bigint
      model_type: string
      model_id: bigint
    }, ExtArgs["result"]["model_has_roles"]>
    composites: {}
  }

  type model_has_rolesGetPayload<S extends boolean | null | undefined | model_has_rolesDefaultArgs> = $Result.GetResult<Prisma.$model_has_rolesPayload, S>

  type model_has_rolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<model_has_rolesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Model_has_rolesCountAggregateInputType | true
    }

  export interface model_has_rolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['model_has_roles'], meta: { name: 'model_has_roles' } }
    /**
     * Find zero or one Model_has_roles that matches the filter.
     * @param {model_has_rolesFindUniqueArgs} args - Arguments to find a Model_has_roles
     * @example
     * // Get one Model_has_roles
     * const model_has_roles = await prisma.model_has_roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends model_has_rolesFindUniqueArgs>(args: SelectSubset<T, model_has_rolesFindUniqueArgs<ExtArgs>>): Prisma__model_has_rolesClient<$Result.GetResult<Prisma.$model_has_rolesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Model_has_roles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {model_has_rolesFindUniqueOrThrowArgs} args - Arguments to find a Model_has_roles
     * @example
     * // Get one Model_has_roles
     * const model_has_roles = await prisma.model_has_roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends model_has_rolesFindUniqueOrThrowArgs>(args: SelectSubset<T, model_has_rolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__model_has_rolesClient<$Result.GetResult<Prisma.$model_has_rolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Model_has_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {model_has_rolesFindFirstArgs} args - Arguments to find a Model_has_roles
     * @example
     * // Get one Model_has_roles
     * const model_has_roles = await prisma.model_has_roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends model_has_rolesFindFirstArgs>(args?: SelectSubset<T, model_has_rolesFindFirstArgs<ExtArgs>>): Prisma__model_has_rolesClient<$Result.GetResult<Prisma.$model_has_rolesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Model_has_roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {model_has_rolesFindFirstOrThrowArgs} args - Arguments to find a Model_has_roles
     * @example
     * // Get one Model_has_roles
     * const model_has_roles = await prisma.model_has_roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends model_has_rolesFindFirstOrThrowArgs>(args?: SelectSubset<T, model_has_rolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__model_has_rolesClient<$Result.GetResult<Prisma.$model_has_rolesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Model_has_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {model_has_rolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Model_has_roles
     * const model_has_roles = await prisma.model_has_roles.findMany()
     * 
     * // Get first 10 Model_has_roles
     * const model_has_roles = await prisma.model_has_roles.findMany({ take: 10 })
     * 
     * // Only select the `role_id`
     * const model_has_rolesWithRole_idOnly = await prisma.model_has_roles.findMany({ select: { role_id: true } })
     * 
     */
    findMany<T extends model_has_rolesFindManyArgs>(args?: SelectSubset<T, model_has_rolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$model_has_rolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Model_has_roles.
     * @param {model_has_rolesCreateArgs} args - Arguments to create a Model_has_roles.
     * @example
     * // Create one Model_has_roles
     * const Model_has_roles = await prisma.model_has_roles.create({
     *   data: {
     *     // ... data to create a Model_has_roles
     *   }
     * })
     * 
     */
    create<T extends model_has_rolesCreateArgs>(args: SelectSubset<T, model_has_rolesCreateArgs<ExtArgs>>): Prisma__model_has_rolesClient<$Result.GetResult<Prisma.$model_has_rolesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Model_has_roles.
     * @param {model_has_rolesCreateManyArgs} args - Arguments to create many Model_has_roles.
     * @example
     * // Create many Model_has_roles
     * const model_has_roles = await prisma.model_has_roles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends model_has_rolesCreateManyArgs>(args?: SelectSubset<T, model_has_rolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Model_has_roles and returns the data saved in the database.
     * @param {model_has_rolesCreateManyAndReturnArgs} args - Arguments to create many Model_has_roles.
     * @example
     * // Create many Model_has_roles
     * const model_has_roles = await prisma.model_has_roles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Model_has_roles and only return the `role_id`
     * const model_has_rolesWithRole_idOnly = await prisma.model_has_roles.createManyAndReturn({
     *   select: { role_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends model_has_rolesCreateManyAndReturnArgs>(args?: SelectSubset<T, model_has_rolesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$model_has_rolesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Model_has_roles.
     * @param {model_has_rolesDeleteArgs} args - Arguments to delete one Model_has_roles.
     * @example
     * // Delete one Model_has_roles
     * const Model_has_roles = await prisma.model_has_roles.delete({
     *   where: {
     *     // ... filter to delete one Model_has_roles
     *   }
     * })
     * 
     */
    delete<T extends model_has_rolesDeleteArgs>(args: SelectSubset<T, model_has_rolesDeleteArgs<ExtArgs>>): Prisma__model_has_rolesClient<$Result.GetResult<Prisma.$model_has_rolesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Model_has_roles.
     * @param {model_has_rolesUpdateArgs} args - Arguments to update one Model_has_roles.
     * @example
     * // Update one Model_has_roles
     * const model_has_roles = await prisma.model_has_roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends model_has_rolesUpdateArgs>(args: SelectSubset<T, model_has_rolesUpdateArgs<ExtArgs>>): Prisma__model_has_rolesClient<$Result.GetResult<Prisma.$model_has_rolesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Model_has_roles.
     * @param {model_has_rolesDeleteManyArgs} args - Arguments to filter Model_has_roles to delete.
     * @example
     * // Delete a few Model_has_roles
     * const { count } = await prisma.model_has_roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends model_has_rolesDeleteManyArgs>(args?: SelectSubset<T, model_has_rolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Model_has_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {model_has_rolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Model_has_roles
     * const model_has_roles = await prisma.model_has_roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends model_has_rolesUpdateManyArgs>(args: SelectSubset<T, model_has_rolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Model_has_roles and returns the data updated in the database.
     * @param {model_has_rolesUpdateManyAndReturnArgs} args - Arguments to update many Model_has_roles.
     * @example
     * // Update many Model_has_roles
     * const model_has_roles = await prisma.model_has_roles.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Model_has_roles and only return the `role_id`
     * const model_has_rolesWithRole_idOnly = await prisma.model_has_roles.updateManyAndReturn({
     *   select: { role_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends model_has_rolesUpdateManyAndReturnArgs>(args: SelectSubset<T, model_has_rolesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$model_has_rolesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Model_has_roles.
     * @param {model_has_rolesUpsertArgs} args - Arguments to update or create a Model_has_roles.
     * @example
     * // Update or create a Model_has_roles
     * const model_has_roles = await prisma.model_has_roles.upsert({
     *   create: {
     *     // ... data to create a Model_has_roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Model_has_roles we want to update
     *   }
     * })
     */
    upsert<T extends model_has_rolesUpsertArgs>(args: SelectSubset<T, model_has_rolesUpsertArgs<ExtArgs>>): Prisma__model_has_rolesClient<$Result.GetResult<Prisma.$model_has_rolesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Model_has_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {model_has_rolesCountArgs} args - Arguments to filter Model_has_roles to count.
     * @example
     * // Count the number of Model_has_roles
     * const count = await prisma.model_has_roles.count({
     *   where: {
     *     // ... the filter for the Model_has_roles we want to count
     *   }
     * })
    **/
    count<T extends model_has_rolesCountArgs>(
      args?: Subset<T, model_has_rolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Model_has_rolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Model_has_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Model_has_rolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Model_has_rolesAggregateArgs>(args: Subset<T, Model_has_rolesAggregateArgs>): Prisma.PrismaPromise<GetModel_has_rolesAggregateType<T>>

    /**
     * Group by Model_has_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {model_has_rolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends model_has_rolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: model_has_rolesGroupByArgs['orderBy'] }
        : { orderBy?: model_has_rolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, model_has_rolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModel_has_rolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the model_has_roles model
   */
  readonly fields: model_has_rolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for model_has_roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__model_has_rolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roles<T extends rolesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, rolesDefaultArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the model_has_roles model
   */
  interface model_has_rolesFieldRefs {
    readonly role_id: FieldRef<"model_has_roles", 'BigInt'>
    readonly model_type: FieldRef<"model_has_roles", 'String'>
    readonly model_id: FieldRef<"model_has_roles", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * model_has_roles findUnique
   */
  export type model_has_rolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_roles
     */
    select?: model_has_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_roles
     */
    omit?: model_has_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_rolesInclude<ExtArgs> | null
    /**
     * Filter, which model_has_roles to fetch.
     */
    where: model_has_rolesWhereUniqueInput
  }

  /**
   * model_has_roles findUniqueOrThrow
   */
  export type model_has_rolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_roles
     */
    select?: model_has_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_roles
     */
    omit?: model_has_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_rolesInclude<ExtArgs> | null
    /**
     * Filter, which model_has_roles to fetch.
     */
    where: model_has_rolesWhereUniqueInput
  }

  /**
   * model_has_roles findFirst
   */
  export type model_has_rolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_roles
     */
    select?: model_has_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_roles
     */
    omit?: model_has_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_rolesInclude<ExtArgs> | null
    /**
     * Filter, which model_has_roles to fetch.
     */
    where?: model_has_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of model_has_roles to fetch.
     */
    orderBy?: model_has_rolesOrderByWithRelationInput | model_has_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for model_has_roles.
     */
    cursor?: model_has_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` model_has_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` model_has_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of model_has_roles.
     */
    distinct?: Model_has_rolesScalarFieldEnum | Model_has_rolesScalarFieldEnum[]
  }

  /**
   * model_has_roles findFirstOrThrow
   */
  export type model_has_rolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_roles
     */
    select?: model_has_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_roles
     */
    omit?: model_has_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_rolesInclude<ExtArgs> | null
    /**
     * Filter, which model_has_roles to fetch.
     */
    where?: model_has_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of model_has_roles to fetch.
     */
    orderBy?: model_has_rolesOrderByWithRelationInput | model_has_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for model_has_roles.
     */
    cursor?: model_has_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` model_has_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` model_has_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of model_has_roles.
     */
    distinct?: Model_has_rolesScalarFieldEnum | Model_has_rolesScalarFieldEnum[]
  }

  /**
   * model_has_roles findMany
   */
  export type model_has_rolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_roles
     */
    select?: model_has_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_roles
     */
    omit?: model_has_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_rolesInclude<ExtArgs> | null
    /**
     * Filter, which model_has_roles to fetch.
     */
    where?: model_has_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of model_has_roles to fetch.
     */
    orderBy?: model_has_rolesOrderByWithRelationInput | model_has_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing model_has_roles.
     */
    cursor?: model_has_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` model_has_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` model_has_roles.
     */
    skip?: number
    distinct?: Model_has_rolesScalarFieldEnum | Model_has_rolesScalarFieldEnum[]
  }

  /**
   * model_has_roles create
   */
  export type model_has_rolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_roles
     */
    select?: model_has_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_roles
     */
    omit?: model_has_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_rolesInclude<ExtArgs> | null
    /**
     * The data needed to create a model_has_roles.
     */
    data: XOR<model_has_rolesCreateInput, model_has_rolesUncheckedCreateInput>
  }

  /**
   * model_has_roles createMany
   */
  export type model_has_rolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many model_has_roles.
     */
    data: model_has_rolesCreateManyInput | model_has_rolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * model_has_roles createManyAndReturn
   */
  export type model_has_rolesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_roles
     */
    select?: model_has_rolesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_roles
     */
    omit?: model_has_rolesOmit<ExtArgs> | null
    /**
     * The data used to create many model_has_roles.
     */
    data: model_has_rolesCreateManyInput | model_has_rolesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_rolesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * model_has_roles update
   */
  export type model_has_rolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_roles
     */
    select?: model_has_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_roles
     */
    omit?: model_has_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_rolesInclude<ExtArgs> | null
    /**
     * The data needed to update a model_has_roles.
     */
    data: XOR<model_has_rolesUpdateInput, model_has_rolesUncheckedUpdateInput>
    /**
     * Choose, which model_has_roles to update.
     */
    where: model_has_rolesWhereUniqueInput
  }

  /**
   * model_has_roles updateMany
   */
  export type model_has_rolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update model_has_roles.
     */
    data: XOR<model_has_rolesUpdateManyMutationInput, model_has_rolesUncheckedUpdateManyInput>
    /**
     * Filter which model_has_roles to update
     */
    where?: model_has_rolesWhereInput
    /**
     * Limit how many model_has_roles to update.
     */
    limit?: number
  }

  /**
   * model_has_roles updateManyAndReturn
   */
  export type model_has_rolesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_roles
     */
    select?: model_has_rolesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_roles
     */
    omit?: model_has_rolesOmit<ExtArgs> | null
    /**
     * The data used to update model_has_roles.
     */
    data: XOR<model_has_rolesUpdateManyMutationInput, model_has_rolesUncheckedUpdateManyInput>
    /**
     * Filter which model_has_roles to update
     */
    where?: model_has_rolesWhereInput
    /**
     * Limit how many model_has_roles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_rolesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * model_has_roles upsert
   */
  export type model_has_rolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_roles
     */
    select?: model_has_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_roles
     */
    omit?: model_has_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_rolesInclude<ExtArgs> | null
    /**
     * The filter to search for the model_has_roles to update in case it exists.
     */
    where: model_has_rolesWhereUniqueInput
    /**
     * In case the model_has_roles found by the `where` argument doesn't exist, create a new model_has_roles with this data.
     */
    create: XOR<model_has_rolesCreateInput, model_has_rolesUncheckedCreateInput>
    /**
     * In case the model_has_roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<model_has_rolesUpdateInput, model_has_rolesUncheckedUpdateInput>
  }

  /**
   * model_has_roles delete
   */
  export type model_has_rolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_roles
     */
    select?: model_has_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_roles
     */
    omit?: model_has_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_rolesInclude<ExtArgs> | null
    /**
     * Filter which model_has_roles to delete.
     */
    where: model_has_rolesWhereUniqueInput
  }

  /**
   * model_has_roles deleteMany
   */
  export type model_has_rolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which model_has_roles to delete
     */
    where?: model_has_rolesWhereInput
    /**
     * Limit how many model_has_roles to delete.
     */
    limit?: number
  }

  /**
   * model_has_roles without action
   */
  export type model_has_rolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_roles
     */
    select?: model_has_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_roles
     */
    omit?: model_has_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_rolesInclude<ExtArgs> | null
  }


  /**
   * Model password_reset_tokens
   */

  export type AggregatePassword_reset_tokens = {
    _count: Password_reset_tokensCountAggregateOutputType | null
    _min: Password_reset_tokensMinAggregateOutputType | null
    _max: Password_reset_tokensMaxAggregateOutputType | null
  }

  export type Password_reset_tokensMinAggregateOutputType = {
    email: string | null
    token: string | null
    created_at: Date | null
  }

  export type Password_reset_tokensMaxAggregateOutputType = {
    email: string | null
    token: string | null
    created_at: Date | null
  }

  export type Password_reset_tokensCountAggregateOutputType = {
    email: number
    token: number
    created_at: number
    _all: number
  }


  export type Password_reset_tokensMinAggregateInputType = {
    email?: true
    token?: true
    created_at?: true
  }

  export type Password_reset_tokensMaxAggregateInputType = {
    email?: true
    token?: true
    created_at?: true
  }

  export type Password_reset_tokensCountAggregateInputType = {
    email?: true
    token?: true
    created_at?: true
    _all?: true
  }

  export type Password_reset_tokensAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which password_reset_tokens to aggregate.
     */
    where?: password_reset_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of password_reset_tokens to fetch.
     */
    orderBy?: password_reset_tokensOrderByWithRelationInput | password_reset_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: password_reset_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` password_reset_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` password_reset_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned password_reset_tokens
    **/
    _count?: true | Password_reset_tokensCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Password_reset_tokensMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Password_reset_tokensMaxAggregateInputType
  }

  export type GetPassword_reset_tokensAggregateType<T extends Password_reset_tokensAggregateArgs> = {
        [P in keyof T & keyof AggregatePassword_reset_tokens]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePassword_reset_tokens[P]>
      : GetScalarType<T[P], AggregatePassword_reset_tokens[P]>
  }




  export type password_reset_tokensGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: password_reset_tokensWhereInput
    orderBy?: password_reset_tokensOrderByWithAggregationInput | password_reset_tokensOrderByWithAggregationInput[]
    by: Password_reset_tokensScalarFieldEnum[] | Password_reset_tokensScalarFieldEnum
    having?: password_reset_tokensScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Password_reset_tokensCountAggregateInputType | true
    _min?: Password_reset_tokensMinAggregateInputType
    _max?: Password_reset_tokensMaxAggregateInputType
  }

  export type Password_reset_tokensGroupByOutputType = {
    email: string
    token: string
    created_at: Date | null
    _count: Password_reset_tokensCountAggregateOutputType | null
    _min: Password_reset_tokensMinAggregateOutputType | null
    _max: Password_reset_tokensMaxAggregateOutputType | null
  }

  type GetPassword_reset_tokensGroupByPayload<T extends password_reset_tokensGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Password_reset_tokensGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Password_reset_tokensGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Password_reset_tokensGroupByOutputType[P]>
            : GetScalarType<T[P], Password_reset_tokensGroupByOutputType[P]>
        }
      >
    >


  export type password_reset_tokensSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    email?: boolean
    token?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["password_reset_tokens"]>

  export type password_reset_tokensSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    email?: boolean
    token?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["password_reset_tokens"]>

  export type password_reset_tokensSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    email?: boolean
    token?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["password_reset_tokens"]>

  export type password_reset_tokensSelectScalar = {
    email?: boolean
    token?: boolean
    created_at?: boolean
  }

  export type password_reset_tokensOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"email" | "token" | "created_at", ExtArgs["result"]["password_reset_tokens"]>

  export type $password_reset_tokensPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "password_reset_tokens"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      email: string
      token: string
      created_at: Date | null
    }, ExtArgs["result"]["password_reset_tokens"]>
    composites: {}
  }

  type password_reset_tokensGetPayload<S extends boolean | null | undefined | password_reset_tokensDefaultArgs> = $Result.GetResult<Prisma.$password_reset_tokensPayload, S>

  type password_reset_tokensCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<password_reset_tokensFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Password_reset_tokensCountAggregateInputType | true
    }

  export interface password_reset_tokensDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['password_reset_tokens'], meta: { name: 'password_reset_tokens' } }
    /**
     * Find zero or one Password_reset_tokens that matches the filter.
     * @param {password_reset_tokensFindUniqueArgs} args - Arguments to find a Password_reset_tokens
     * @example
     * // Get one Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends password_reset_tokensFindUniqueArgs>(args: SelectSubset<T, password_reset_tokensFindUniqueArgs<ExtArgs>>): Prisma__password_reset_tokensClient<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Password_reset_tokens that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {password_reset_tokensFindUniqueOrThrowArgs} args - Arguments to find a Password_reset_tokens
     * @example
     * // Get one Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends password_reset_tokensFindUniqueOrThrowArgs>(args: SelectSubset<T, password_reset_tokensFindUniqueOrThrowArgs<ExtArgs>>): Prisma__password_reset_tokensClient<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Password_reset_tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_reset_tokensFindFirstArgs} args - Arguments to find a Password_reset_tokens
     * @example
     * // Get one Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends password_reset_tokensFindFirstArgs>(args?: SelectSubset<T, password_reset_tokensFindFirstArgs<ExtArgs>>): Prisma__password_reset_tokensClient<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Password_reset_tokens that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_reset_tokensFindFirstOrThrowArgs} args - Arguments to find a Password_reset_tokens
     * @example
     * // Get one Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends password_reset_tokensFindFirstOrThrowArgs>(args?: SelectSubset<T, password_reset_tokensFindFirstOrThrowArgs<ExtArgs>>): Prisma__password_reset_tokensClient<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Password_reset_tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_reset_tokensFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.findMany()
     * 
     * // Get first 10 Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.findMany({ take: 10 })
     * 
     * // Only select the `email`
     * const password_reset_tokensWithEmailOnly = await prisma.password_reset_tokens.findMany({ select: { email: true } })
     * 
     */
    findMany<T extends password_reset_tokensFindManyArgs>(args?: SelectSubset<T, password_reset_tokensFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Password_reset_tokens.
     * @param {password_reset_tokensCreateArgs} args - Arguments to create a Password_reset_tokens.
     * @example
     * // Create one Password_reset_tokens
     * const Password_reset_tokens = await prisma.password_reset_tokens.create({
     *   data: {
     *     // ... data to create a Password_reset_tokens
     *   }
     * })
     * 
     */
    create<T extends password_reset_tokensCreateArgs>(args: SelectSubset<T, password_reset_tokensCreateArgs<ExtArgs>>): Prisma__password_reset_tokensClient<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Password_reset_tokens.
     * @param {password_reset_tokensCreateManyArgs} args - Arguments to create many Password_reset_tokens.
     * @example
     * // Create many Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends password_reset_tokensCreateManyArgs>(args?: SelectSubset<T, password_reset_tokensCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Password_reset_tokens and returns the data saved in the database.
     * @param {password_reset_tokensCreateManyAndReturnArgs} args - Arguments to create many Password_reset_tokens.
     * @example
     * // Create many Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Password_reset_tokens and only return the `email`
     * const password_reset_tokensWithEmailOnly = await prisma.password_reset_tokens.createManyAndReturn({
     *   select: { email: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends password_reset_tokensCreateManyAndReturnArgs>(args?: SelectSubset<T, password_reset_tokensCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Password_reset_tokens.
     * @param {password_reset_tokensDeleteArgs} args - Arguments to delete one Password_reset_tokens.
     * @example
     * // Delete one Password_reset_tokens
     * const Password_reset_tokens = await prisma.password_reset_tokens.delete({
     *   where: {
     *     // ... filter to delete one Password_reset_tokens
     *   }
     * })
     * 
     */
    delete<T extends password_reset_tokensDeleteArgs>(args: SelectSubset<T, password_reset_tokensDeleteArgs<ExtArgs>>): Prisma__password_reset_tokensClient<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Password_reset_tokens.
     * @param {password_reset_tokensUpdateArgs} args - Arguments to update one Password_reset_tokens.
     * @example
     * // Update one Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends password_reset_tokensUpdateArgs>(args: SelectSubset<T, password_reset_tokensUpdateArgs<ExtArgs>>): Prisma__password_reset_tokensClient<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Password_reset_tokens.
     * @param {password_reset_tokensDeleteManyArgs} args - Arguments to filter Password_reset_tokens to delete.
     * @example
     * // Delete a few Password_reset_tokens
     * const { count } = await prisma.password_reset_tokens.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends password_reset_tokensDeleteManyArgs>(args?: SelectSubset<T, password_reset_tokensDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Password_reset_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_reset_tokensUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends password_reset_tokensUpdateManyArgs>(args: SelectSubset<T, password_reset_tokensUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Password_reset_tokens and returns the data updated in the database.
     * @param {password_reset_tokensUpdateManyAndReturnArgs} args - Arguments to update many Password_reset_tokens.
     * @example
     * // Update many Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Password_reset_tokens and only return the `email`
     * const password_reset_tokensWithEmailOnly = await prisma.password_reset_tokens.updateManyAndReturn({
     *   select: { email: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends password_reset_tokensUpdateManyAndReturnArgs>(args: SelectSubset<T, password_reset_tokensUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Password_reset_tokens.
     * @param {password_reset_tokensUpsertArgs} args - Arguments to update or create a Password_reset_tokens.
     * @example
     * // Update or create a Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.upsert({
     *   create: {
     *     // ... data to create a Password_reset_tokens
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Password_reset_tokens we want to update
     *   }
     * })
     */
    upsert<T extends password_reset_tokensUpsertArgs>(args: SelectSubset<T, password_reset_tokensUpsertArgs<ExtArgs>>): Prisma__password_reset_tokensClient<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Password_reset_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_reset_tokensCountArgs} args - Arguments to filter Password_reset_tokens to count.
     * @example
     * // Count the number of Password_reset_tokens
     * const count = await prisma.password_reset_tokens.count({
     *   where: {
     *     // ... the filter for the Password_reset_tokens we want to count
     *   }
     * })
    **/
    count<T extends password_reset_tokensCountArgs>(
      args?: Subset<T, password_reset_tokensCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Password_reset_tokensCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Password_reset_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Password_reset_tokensAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Password_reset_tokensAggregateArgs>(args: Subset<T, Password_reset_tokensAggregateArgs>): Prisma.PrismaPromise<GetPassword_reset_tokensAggregateType<T>>

    /**
     * Group by Password_reset_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_reset_tokensGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends password_reset_tokensGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: password_reset_tokensGroupByArgs['orderBy'] }
        : { orderBy?: password_reset_tokensGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, password_reset_tokensGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPassword_reset_tokensGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the password_reset_tokens model
   */
  readonly fields: password_reset_tokensFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for password_reset_tokens.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__password_reset_tokensClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the password_reset_tokens model
   */
  interface password_reset_tokensFieldRefs {
    readonly email: FieldRef<"password_reset_tokens", 'String'>
    readonly token: FieldRef<"password_reset_tokens", 'String'>
    readonly created_at: FieldRef<"password_reset_tokens", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * password_reset_tokens findUnique
   */
  export type password_reset_tokensFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * Filter, which password_reset_tokens to fetch.
     */
    where: password_reset_tokensWhereUniqueInput
  }

  /**
   * password_reset_tokens findUniqueOrThrow
   */
  export type password_reset_tokensFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * Filter, which password_reset_tokens to fetch.
     */
    where: password_reset_tokensWhereUniqueInput
  }

  /**
   * password_reset_tokens findFirst
   */
  export type password_reset_tokensFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * Filter, which password_reset_tokens to fetch.
     */
    where?: password_reset_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of password_reset_tokens to fetch.
     */
    orderBy?: password_reset_tokensOrderByWithRelationInput | password_reset_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for password_reset_tokens.
     */
    cursor?: password_reset_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` password_reset_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` password_reset_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of password_reset_tokens.
     */
    distinct?: Password_reset_tokensScalarFieldEnum | Password_reset_tokensScalarFieldEnum[]
  }

  /**
   * password_reset_tokens findFirstOrThrow
   */
  export type password_reset_tokensFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * Filter, which password_reset_tokens to fetch.
     */
    where?: password_reset_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of password_reset_tokens to fetch.
     */
    orderBy?: password_reset_tokensOrderByWithRelationInput | password_reset_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for password_reset_tokens.
     */
    cursor?: password_reset_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` password_reset_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` password_reset_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of password_reset_tokens.
     */
    distinct?: Password_reset_tokensScalarFieldEnum | Password_reset_tokensScalarFieldEnum[]
  }

  /**
   * password_reset_tokens findMany
   */
  export type password_reset_tokensFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * Filter, which password_reset_tokens to fetch.
     */
    where?: password_reset_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of password_reset_tokens to fetch.
     */
    orderBy?: password_reset_tokensOrderByWithRelationInput | password_reset_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing password_reset_tokens.
     */
    cursor?: password_reset_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` password_reset_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` password_reset_tokens.
     */
    skip?: number
    distinct?: Password_reset_tokensScalarFieldEnum | Password_reset_tokensScalarFieldEnum[]
  }

  /**
   * password_reset_tokens create
   */
  export type password_reset_tokensCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * The data needed to create a password_reset_tokens.
     */
    data: XOR<password_reset_tokensCreateInput, password_reset_tokensUncheckedCreateInput>
  }

  /**
   * password_reset_tokens createMany
   */
  export type password_reset_tokensCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many password_reset_tokens.
     */
    data: password_reset_tokensCreateManyInput | password_reset_tokensCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * password_reset_tokens createManyAndReturn
   */
  export type password_reset_tokensCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * The data used to create many password_reset_tokens.
     */
    data: password_reset_tokensCreateManyInput | password_reset_tokensCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * password_reset_tokens update
   */
  export type password_reset_tokensUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * The data needed to update a password_reset_tokens.
     */
    data: XOR<password_reset_tokensUpdateInput, password_reset_tokensUncheckedUpdateInput>
    /**
     * Choose, which password_reset_tokens to update.
     */
    where: password_reset_tokensWhereUniqueInput
  }

  /**
   * password_reset_tokens updateMany
   */
  export type password_reset_tokensUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update password_reset_tokens.
     */
    data: XOR<password_reset_tokensUpdateManyMutationInput, password_reset_tokensUncheckedUpdateManyInput>
    /**
     * Filter which password_reset_tokens to update
     */
    where?: password_reset_tokensWhereInput
    /**
     * Limit how many password_reset_tokens to update.
     */
    limit?: number
  }

  /**
   * password_reset_tokens updateManyAndReturn
   */
  export type password_reset_tokensUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * The data used to update password_reset_tokens.
     */
    data: XOR<password_reset_tokensUpdateManyMutationInput, password_reset_tokensUncheckedUpdateManyInput>
    /**
     * Filter which password_reset_tokens to update
     */
    where?: password_reset_tokensWhereInput
    /**
     * Limit how many password_reset_tokens to update.
     */
    limit?: number
  }

  /**
   * password_reset_tokens upsert
   */
  export type password_reset_tokensUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * The filter to search for the password_reset_tokens to update in case it exists.
     */
    where: password_reset_tokensWhereUniqueInput
    /**
     * In case the password_reset_tokens found by the `where` argument doesn't exist, create a new password_reset_tokens with this data.
     */
    create: XOR<password_reset_tokensCreateInput, password_reset_tokensUncheckedCreateInput>
    /**
     * In case the password_reset_tokens was found with the provided `where` argument, update it with this data.
     */
    update: XOR<password_reset_tokensUpdateInput, password_reset_tokensUncheckedUpdateInput>
  }

  /**
   * password_reset_tokens delete
   */
  export type password_reset_tokensDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * Filter which password_reset_tokens to delete.
     */
    where: password_reset_tokensWhereUniqueInput
  }

  /**
   * password_reset_tokens deleteMany
   */
  export type password_reset_tokensDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which password_reset_tokens to delete
     */
    where?: password_reset_tokensWhereInput
    /**
     * Limit how many password_reset_tokens to delete.
     */
    limit?: number
  }

  /**
   * password_reset_tokens without action
   */
  export type password_reset_tokensDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
  }


  /**
   * Model permissions
   */

  export type AggregatePermissions = {
    _count: PermissionsCountAggregateOutputType | null
    _avg: PermissionsAvgAggregateOutputType | null
    _sum: PermissionsSumAggregateOutputType | null
    _min: PermissionsMinAggregateOutputType | null
    _max: PermissionsMaxAggregateOutputType | null
  }

  export type PermissionsAvgAggregateOutputType = {
    id: number | null
  }

  export type PermissionsSumAggregateOutputType = {
    id: bigint | null
  }

  export type PermissionsMinAggregateOutputType = {
    id: bigint | null
    name: string | null
    guard_name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PermissionsMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
    guard_name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PermissionsCountAggregateOutputType = {
    id: number
    name: number
    guard_name: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type PermissionsAvgAggregateInputType = {
    id?: true
  }

  export type PermissionsSumAggregateInputType = {
    id?: true
  }

  export type PermissionsMinAggregateInputType = {
    id?: true
    name?: true
    guard_name?: true
    created_at?: true
    updated_at?: true
  }

  export type PermissionsMaxAggregateInputType = {
    id?: true
    name?: true
    guard_name?: true
    created_at?: true
    updated_at?: true
  }

  export type PermissionsCountAggregateInputType = {
    id?: true
    name?: true
    guard_name?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type PermissionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which permissions to aggregate.
     */
    where?: permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionsOrderByWithRelationInput | permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned permissions
    **/
    _count?: true | PermissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PermissionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PermissionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionsMaxAggregateInputType
  }

  export type GetPermissionsAggregateType<T extends PermissionsAggregateArgs> = {
        [P in keyof T & keyof AggregatePermissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermissions[P]>
      : GetScalarType<T[P], AggregatePermissions[P]>
  }




  export type permissionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: permissionsWhereInput
    orderBy?: permissionsOrderByWithAggregationInput | permissionsOrderByWithAggregationInput[]
    by: PermissionsScalarFieldEnum[] | PermissionsScalarFieldEnum
    having?: permissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionsCountAggregateInputType | true
    _avg?: PermissionsAvgAggregateInputType
    _sum?: PermissionsSumAggregateInputType
    _min?: PermissionsMinAggregateInputType
    _max?: PermissionsMaxAggregateInputType
  }

  export type PermissionsGroupByOutputType = {
    id: bigint
    name: string
    guard_name: string
    created_at: Date | null
    updated_at: Date | null
    _count: PermissionsCountAggregateOutputType | null
    _avg: PermissionsAvgAggregateOutputType | null
    _sum: PermissionsSumAggregateOutputType | null
    _min: PermissionsMinAggregateOutputType | null
    _max: PermissionsMaxAggregateOutputType | null
  }

  type GetPermissionsGroupByPayload<T extends permissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionsGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionsGroupByOutputType[P]>
        }
      >
    >


  export type permissionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    guard_name?: boolean
    created_at?: boolean
    updated_at?: boolean
    model_has_permissions?: boolean | permissions$model_has_permissionsArgs<ExtArgs>
    role_has_permissions?: boolean | permissions$role_has_permissionsArgs<ExtArgs>
    _count?: boolean | PermissionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permissions"]>

  export type permissionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    guard_name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["permissions"]>

  export type permissionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    guard_name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["permissions"]>

  export type permissionsSelectScalar = {
    id?: boolean
    name?: boolean
    guard_name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type permissionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "guard_name" | "created_at" | "updated_at", ExtArgs["result"]["permissions"]>
  export type permissionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    model_has_permissions?: boolean | permissions$model_has_permissionsArgs<ExtArgs>
    role_has_permissions?: boolean | permissions$role_has_permissionsArgs<ExtArgs>
    _count?: boolean | PermissionsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type permissionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type permissionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $permissionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "permissions"
    objects: {
      model_has_permissions: Prisma.$model_has_permissionsPayload<ExtArgs>[]
      role_has_permissions: Prisma.$role_has_permissionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
      guard_name: string
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["permissions"]>
    composites: {}
  }

  type permissionsGetPayload<S extends boolean | null | undefined | permissionsDefaultArgs> = $Result.GetResult<Prisma.$permissionsPayload, S>

  type permissionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<permissionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionsCountAggregateInputType | true
    }

  export interface permissionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['permissions'], meta: { name: 'permissions' } }
    /**
     * Find zero or one Permissions that matches the filter.
     * @param {permissionsFindUniqueArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends permissionsFindUniqueArgs>(args: SelectSubset<T, permissionsFindUniqueArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Permissions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {permissionsFindUniqueOrThrowArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends permissionsFindUniqueOrThrowArgs>(args: SelectSubset<T, permissionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionsFindFirstArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends permissionsFindFirstArgs>(args?: SelectSubset<T, permissionsFindFirstArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permissions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionsFindFirstOrThrowArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends permissionsFindFirstOrThrowArgs>(args?: SelectSubset<T, permissionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permissions.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permissions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionsWithIdOnly = await prisma.permissions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends permissionsFindManyArgs>(args?: SelectSubset<T, permissionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Permissions.
     * @param {permissionsCreateArgs} args - Arguments to create a Permissions.
     * @example
     * // Create one Permissions
     * const Permissions = await prisma.permissions.create({
     *   data: {
     *     // ... data to create a Permissions
     *   }
     * })
     * 
     */
    create<T extends permissionsCreateArgs>(args: SelectSubset<T, permissionsCreateArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Permissions.
     * @param {permissionsCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permissions = await prisma.permissions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends permissionsCreateManyArgs>(args?: SelectSubset<T, permissionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permissions and returns the data saved in the database.
     * @param {permissionsCreateManyAndReturnArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permissions = await prisma.permissions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permissions and only return the `id`
     * const permissionsWithIdOnly = await prisma.permissions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends permissionsCreateManyAndReturnArgs>(args?: SelectSubset<T, permissionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Permissions.
     * @param {permissionsDeleteArgs} args - Arguments to delete one Permissions.
     * @example
     * // Delete one Permissions
     * const Permissions = await prisma.permissions.delete({
     *   where: {
     *     // ... filter to delete one Permissions
     *   }
     * })
     * 
     */
    delete<T extends permissionsDeleteArgs>(args: SelectSubset<T, permissionsDeleteArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Permissions.
     * @param {permissionsUpdateArgs} args - Arguments to update one Permissions.
     * @example
     * // Update one Permissions
     * const permissions = await prisma.permissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends permissionsUpdateArgs>(args: SelectSubset<T, permissionsUpdateArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Permissions.
     * @param {permissionsDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends permissionsDeleteManyArgs>(args?: SelectSubset<T, permissionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permissions = await prisma.permissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends permissionsUpdateManyArgs>(args: SelectSubset<T, permissionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions and returns the data updated in the database.
     * @param {permissionsUpdateManyAndReturnArgs} args - Arguments to update many Permissions.
     * @example
     * // Update many Permissions
     * const permissions = await prisma.permissions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Permissions and only return the `id`
     * const permissionsWithIdOnly = await prisma.permissions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends permissionsUpdateManyAndReturnArgs>(args: SelectSubset<T, permissionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Permissions.
     * @param {permissionsUpsertArgs} args - Arguments to update or create a Permissions.
     * @example
     * // Update or create a Permissions
     * const permissions = await prisma.permissions.upsert({
     *   create: {
     *     // ... data to create a Permissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permissions we want to update
     *   }
     * })
     */
    upsert<T extends permissionsUpsertArgs>(args: SelectSubset<T, permissionsUpsertArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionsCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permissions.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends permissionsCountArgs>(
      args?: Subset<T, permissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionsAggregateArgs>(args: Subset<T, PermissionsAggregateArgs>): Prisma.PrismaPromise<GetPermissionsAggregateType<T>>

    /**
     * Group by Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends permissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: permissionsGroupByArgs['orderBy'] }
        : { orderBy?: permissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, permissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the permissions model
   */
  readonly fields: permissionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for permissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__permissionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    model_has_permissions<T extends permissions$model_has_permissionsArgs<ExtArgs> = {}>(args?: Subset<T, permissions$model_has_permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$model_has_permissionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    role_has_permissions<T extends permissions$role_has_permissionsArgs<ExtArgs> = {}>(args?: Subset<T, permissions$role_has_permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$role_has_permissionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the permissions model
   */
  interface permissionsFieldRefs {
    readonly id: FieldRef<"permissions", 'BigInt'>
    readonly name: FieldRef<"permissions", 'String'>
    readonly guard_name: FieldRef<"permissions", 'String'>
    readonly created_at: FieldRef<"permissions", 'DateTime'>
    readonly updated_at: FieldRef<"permissions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * permissions findUnique
   */
  export type permissionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * Filter, which permissions to fetch.
     */
    where: permissionsWhereUniqueInput
  }

  /**
   * permissions findUniqueOrThrow
   */
  export type permissionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * Filter, which permissions to fetch.
     */
    where: permissionsWhereUniqueInput
  }

  /**
   * permissions findFirst
   */
  export type permissionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * Filter, which permissions to fetch.
     */
    where?: permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionsOrderByWithRelationInput | permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for permissions.
     */
    cursor?: permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of permissions.
     */
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[]
  }

  /**
   * permissions findFirstOrThrow
   */
  export type permissionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * Filter, which permissions to fetch.
     */
    where?: permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionsOrderByWithRelationInput | permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for permissions.
     */
    cursor?: permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of permissions.
     */
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[]
  }

  /**
   * permissions findMany
   */
  export type permissionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * Filter, which permissions to fetch.
     */
    where?: permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionsOrderByWithRelationInput | permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing permissions.
     */
    cursor?: permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[]
  }

  /**
   * permissions create
   */
  export type permissionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * The data needed to create a permissions.
     */
    data: XOR<permissionsCreateInput, permissionsUncheckedCreateInput>
  }

  /**
   * permissions createMany
   */
  export type permissionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many permissions.
     */
    data: permissionsCreateManyInput | permissionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * permissions createManyAndReturn
   */
  export type permissionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * The data used to create many permissions.
     */
    data: permissionsCreateManyInput | permissionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * permissions update
   */
  export type permissionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * The data needed to update a permissions.
     */
    data: XOR<permissionsUpdateInput, permissionsUncheckedUpdateInput>
    /**
     * Choose, which permissions to update.
     */
    where: permissionsWhereUniqueInput
  }

  /**
   * permissions updateMany
   */
  export type permissionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update permissions.
     */
    data: XOR<permissionsUpdateManyMutationInput, permissionsUncheckedUpdateManyInput>
    /**
     * Filter which permissions to update
     */
    where?: permissionsWhereInput
    /**
     * Limit how many permissions to update.
     */
    limit?: number
  }

  /**
   * permissions updateManyAndReturn
   */
  export type permissionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * The data used to update permissions.
     */
    data: XOR<permissionsUpdateManyMutationInput, permissionsUncheckedUpdateManyInput>
    /**
     * Filter which permissions to update
     */
    where?: permissionsWhereInput
    /**
     * Limit how many permissions to update.
     */
    limit?: number
  }

  /**
   * permissions upsert
   */
  export type permissionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * The filter to search for the permissions to update in case it exists.
     */
    where: permissionsWhereUniqueInput
    /**
     * In case the permissions found by the `where` argument doesn't exist, create a new permissions with this data.
     */
    create: XOR<permissionsCreateInput, permissionsUncheckedCreateInput>
    /**
     * In case the permissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<permissionsUpdateInput, permissionsUncheckedUpdateInput>
  }

  /**
   * permissions delete
   */
  export type permissionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * Filter which permissions to delete.
     */
    where: permissionsWhereUniqueInput
  }

  /**
   * permissions deleteMany
   */
  export type permissionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which permissions to delete
     */
    where?: permissionsWhereInput
    /**
     * Limit how many permissions to delete.
     */
    limit?: number
  }

  /**
   * permissions.model_has_permissions
   */
  export type permissions$model_has_permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_permissions
     */
    select?: model_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_permissions
     */
    omit?: model_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_permissionsInclude<ExtArgs> | null
    where?: model_has_permissionsWhereInput
    orderBy?: model_has_permissionsOrderByWithRelationInput | model_has_permissionsOrderByWithRelationInput[]
    cursor?: model_has_permissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Model_has_permissionsScalarFieldEnum | Model_has_permissionsScalarFieldEnum[]
  }

  /**
   * permissions.role_has_permissions
   */
  export type permissions$role_has_permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_has_permissions
     */
    select?: role_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_has_permissions
     */
    omit?: role_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_has_permissionsInclude<ExtArgs> | null
    where?: role_has_permissionsWhereInput
    orderBy?: role_has_permissionsOrderByWithRelationInput | role_has_permissionsOrderByWithRelationInput[]
    cursor?: role_has_permissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Role_has_permissionsScalarFieldEnum | Role_has_permissionsScalarFieldEnum[]
  }

  /**
   * permissions without action
   */
  export type permissionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
  }


  /**
   * Model personal_access_tokens
   */

  export type AggregatePersonal_access_tokens = {
    _count: Personal_access_tokensCountAggregateOutputType | null
    _avg: Personal_access_tokensAvgAggregateOutputType | null
    _sum: Personal_access_tokensSumAggregateOutputType | null
    _min: Personal_access_tokensMinAggregateOutputType | null
    _max: Personal_access_tokensMaxAggregateOutputType | null
  }

  export type Personal_access_tokensAvgAggregateOutputType = {
    id: number | null
    tokenable_id: number | null
  }

  export type Personal_access_tokensSumAggregateOutputType = {
    id: bigint | null
    tokenable_id: bigint | null
  }

  export type Personal_access_tokensMinAggregateOutputType = {
    id: bigint | null
    tokenable_type: string | null
    tokenable_id: bigint | null
    name: string | null
    token: string | null
    abilities: string | null
    last_used_at: Date | null
    expires_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Personal_access_tokensMaxAggregateOutputType = {
    id: bigint | null
    tokenable_type: string | null
    tokenable_id: bigint | null
    name: string | null
    token: string | null
    abilities: string | null
    last_used_at: Date | null
    expires_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Personal_access_tokensCountAggregateOutputType = {
    id: number
    tokenable_type: number
    tokenable_id: number
    name: number
    token: number
    abilities: number
    last_used_at: number
    expires_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Personal_access_tokensAvgAggregateInputType = {
    id?: true
    tokenable_id?: true
  }

  export type Personal_access_tokensSumAggregateInputType = {
    id?: true
    tokenable_id?: true
  }

  export type Personal_access_tokensMinAggregateInputType = {
    id?: true
    tokenable_type?: true
    tokenable_id?: true
    name?: true
    token?: true
    abilities?: true
    last_used_at?: true
    expires_at?: true
    created_at?: true
    updated_at?: true
  }

  export type Personal_access_tokensMaxAggregateInputType = {
    id?: true
    tokenable_type?: true
    tokenable_id?: true
    name?: true
    token?: true
    abilities?: true
    last_used_at?: true
    expires_at?: true
    created_at?: true
    updated_at?: true
  }

  export type Personal_access_tokensCountAggregateInputType = {
    id?: true
    tokenable_type?: true
    tokenable_id?: true
    name?: true
    token?: true
    abilities?: true
    last_used_at?: true
    expires_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Personal_access_tokensAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which personal_access_tokens to aggregate.
     */
    where?: personal_access_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of personal_access_tokens to fetch.
     */
    orderBy?: personal_access_tokensOrderByWithRelationInput | personal_access_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: personal_access_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` personal_access_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` personal_access_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned personal_access_tokens
    **/
    _count?: true | Personal_access_tokensCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Personal_access_tokensAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Personal_access_tokensSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Personal_access_tokensMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Personal_access_tokensMaxAggregateInputType
  }

  export type GetPersonal_access_tokensAggregateType<T extends Personal_access_tokensAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonal_access_tokens]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonal_access_tokens[P]>
      : GetScalarType<T[P], AggregatePersonal_access_tokens[P]>
  }




  export type personal_access_tokensGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: personal_access_tokensWhereInput
    orderBy?: personal_access_tokensOrderByWithAggregationInput | personal_access_tokensOrderByWithAggregationInput[]
    by: Personal_access_tokensScalarFieldEnum[] | Personal_access_tokensScalarFieldEnum
    having?: personal_access_tokensScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Personal_access_tokensCountAggregateInputType | true
    _avg?: Personal_access_tokensAvgAggregateInputType
    _sum?: Personal_access_tokensSumAggregateInputType
    _min?: Personal_access_tokensMinAggregateInputType
    _max?: Personal_access_tokensMaxAggregateInputType
  }

  export type Personal_access_tokensGroupByOutputType = {
    id: bigint
    tokenable_type: string
    tokenable_id: bigint
    name: string
    token: string
    abilities: string | null
    last_used_at: Date | null
    expires_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    _count: Personal_access_tokensCountAggregateOutputType | null
    _avg: Personal_access_tokensAvgAggregateOutputType | null
    _sum: Personal_access_tokensSumAggregateOutputType | null
    _min: Personal_access_tokensMinAggregateOutputType | null
    _max: Personal_access_tokensMaxAggregateOutputType | null
  }

  type GetPersonal_access_tokensGroupByPayload<T extends personal_access_tokensGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Personal_access_tokensGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Personal_access_tokensGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Personal_access_tokensGroupByOutputType[P]>
            : GetScalarType<T[P], Personal_access_tokensGroupByOutputType[P]>
        }
      >
    >


  export type personal_access_tokensSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tokenable_type?: boolean
    tokenable_id?: boolean
    name?: boolean
    token?: boolean
    abilities?: boolean
    last_used_at?: boolean
    expires_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["personal_access_tokens"]>

  export type personal_access_tokensSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tokenable_type?: boolean
    tokenable_id?: boolean
    name?: boolean
    token?: boolean
    abilities?: boolean
    last_used_at?: boolean
    expires_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["personal_access_tokens"]>

  export type personal_access_tokensSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tokenable_type?: boolean
    tokenable_id?: boolean
    name?: boolean
    token?: boolean
    abilities?: boolean
    last_used_at?: boolean
    expires_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["personal_access_tokens"]>

  export type personal_access_tokensSelectScalar = {
    id?: boolean
    tokenable_type?: boolean
    tokenable_id?: boolean
    name?: boolean
    token?: boolean
    abilities?: boolean
    last_used_at?: boolean
    expires_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type personal_access_tokensOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tokenable_type" | "tokenable_id" | "name" | "token" | "abilities" | "last_used_at" | "expires_at" | "created_at" | "updated_at", ExtArgs["result"]["personal_access_tokens"]>

  export type $personal_access_tokensPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "personal_access_tokens"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      tokenable_type: string
      tokenable_id: bigint
      name: string
      token: string
      abilities: string | null
      last_used_at: Date | null
      expires_at: Date | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["personal_access_tokens"]>
    composites: {}
  }

  type personal_access_tokensGetPayload<S extends boolean | null | undefined | personal_access_tokensDefaultArgs> = $Result.GetResult<Prisma.$personal_access_tokensPayload, S>

  type personal_access_tokensCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<personal_access_tokensFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Personal_access_tokensCountAggregateInputType | true
    }

  export interface personal_access_tokensDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['personal_access_tokens'], meta: { name: 'personal_access_tokens' } }
    /**
     * Find zero or one Personal_access_tokens that matches the filter.
     * @param {personal_access_tokensFindUniqueArgs} args - Arguments to find a Personal_access_tokens
     * @example
     * // Get one Personal_access_tokens
     * const personal_access_tokens = await prisma.personal_access_tokens.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends personal_access_tokensFindUniqueArgs>(args: SelectSubset<T, personal_access_tokensFindUniqueArgs<ExtArgs>>): Prisma__personal_access_tokensClient<$Result.GetResult<Prisma.$personal_access_tokensPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Personal_access_tokens that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {personal_access_tokensFindUniqueOrThrowArgs} args - Arguments to find a Personal_access_tokens
     * @example
     * // Get one Personal_access_tokens
     * const personal_access_tokens = await prisma.personal_access_tokens.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends personal_access_tokensFindUniqueOrThrowArgs>(args: SelectSubset<T, personal_access_tokensFindUniqueOrThrowArgs<ExtArgs>>): Prisma__personal_access_tokensClient<$Result.GetResult<Prisma.$personal_access_tokensPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Personal_access_tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personal_access_tokensFindFirstArgs} args - Arguments to find a Personal_access_tokens
     * @example
     * // Get one Personal_access_tokens
     * const personal_access_tokens = await prisma.personal_access_tokens.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends personal_access_tokensFindFirstArgs>(args?: SelectSubset<T, personal_access_tokensFindFirstArgs<ExtArgs>>): Prisma__personal_access_tokensClient<$Result.GetResult<Prisma.$personal_access_tokensPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Personal_access_tokens that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personal_access_tokensFindFirstOrThrowArgs} args - Arguments to find a Personal_access_tokens
     * @example
     * // Get one Personal_access_tokens
     * const personal_access_tokens = await prisma.personal_access_tokens.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends personal_access_tokensFindFirstOrThrowArgs>(args?: SelectSubset<T, personal_access_tokensFindFirstOrThrowArgs<ExtArgs>>): Prisma__personal_access_tokensClient<$Result.GetResult<Prisma.$personal_access_tokensPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Personal_access_tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personal_access_tokensFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Personal_access_tokens
     * const personal_access_tokens = await prisma.personal_access_tokens.findMany()
     * 
     * // Get first 10 Personal_access_tokens
     * const personal_access_tokens = await prisma.personal_access_tokens.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personal_access_tokensWithIdOnly = await prisma.personal_access_tokens.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends personal_access_tokensFindManyArgs>(args?: SelectSubset<T, personal_access_tokensFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$personal_access_tokensPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Personal_access_tokens.
     * @param {personal_access_tokensCreateArgs} args - Arguments to create a Personal_access_tokens.
     * @example
     * // Create one Personal_access_tokens
     * const Personal_access_tokens = await prisma.personal_access_tokens.create({
     *   data: {
     *     // ... data to create a Personal_access_tokens
     *   }
     * })
     * 
     */
    create<T extends personal_access_tokensCreateArgs>(args: SelectSubset<T, personal_access_tokensCreateArgs<ExtArgs>>): Prisma__personal_access_tokensClient<$Result.GetResult<Prisma.$personal_access_tokensPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Personal_access_tokens.
     * @param {personal_access_tokensCreateManyArgs} args - Arguments to create many Personal_access_tokens.
     * @example
     * // Create many Personal_access_tokens
     * const personal_access_tokens = await prisma.personal_access_tokens.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends personal_access_tokensCreateManyArgs>(args?: SelectSubset<T, personal_access_tokensCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Personal_access_tokens and returns the data saved in the database.
     * @param {personal_access_tokensCreateManyAndReturnArgs} args - Arguments to create many Personal_access_tokens.
     * @example
     * // Create many Personal_access_tokens
     * const personal_access_tokens = await prisma.personal_access_tokens.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Personal_access_tokens and only return the `id`
     * const personal_access_tokensWithIdOnly = await prisma.personal_access_tokens.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends personal_access_tokensCreateManyAndReturnArgs>(args?: SelectSubset<T, personal_access_tokensCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$personal_access_tokensPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Personal_access_tokens.
     * @param {personal_access_tokensDeleteArgs} args - Arguments to delete one Personal_access_tokens.
     * @example
     * // Delete one Personal_access_tokens
     * const Personal_access_tokens = await prisma.personal_access_tokens.delete({
     *   where: {
     *     // ... filter to delete one Personal_access_tokens
     *   }
     * })
     * 
     */
    delete<T extends personal_access_tokensDeleteArgs>(args: SelectSubset<T, personal_access_tokensDeleteArgs<ExtArgs>>): Prisma__personal_access_tokensClient<$Result.GetResult<Prisma.$personal_access_tokensPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Personal_access_tokens.
     * @param {personal_access_tokensUpdateArgs} args - Arguments to update one Personal_access_tokens.
     * @example
     * // Update one Personal_access_tokens
     * const personal_access_tokens = await prisma.personal_access_tokens.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends personal_access_tokensUpdateArgs>(args: SelectSubset<T, personal_access_tokensUpdateArgs<ExtArgs>>): Prisma__personal_access_tokensClient<$Result.GetResult<Prisma.$personal_access_tokensPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Personal_access_tokens.
     * @param {personal_access_tokensDeleteManyArgs} args - Arguments to filter Personal_access_tokens to delete.
     * @example
     * // Delete a few Personal_access_tokens
     * const { count } = await prisma.personal_access_tokens.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends personal_access_tokensDeleteManyArgs>(args?: SelectSubset<T, personal_access_tokensDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Personal_access_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personal_access_tokensUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Personal_access_tokens
     * const personal_access_tokens = await prisma.personal_access_tokens.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends personal_access_tokensUpdateManyArgs>(args: SelectSubset<T, personal_access_tokensUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Personal_access_tokens and returns the data updated in the database.
     * @param {personal_access_tokensUpdateManyAndReturnArgs} args - Arguments to update many Personal_access_tokens.
     * @example
     * // Update many Personal_access_tokens
     * const personal_access_tokens = await prisma.personal_access_tokens.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Personal_access_tokens and only return the `id`
     * const personal_access_tokensWithIdOnly = await prisma.personal_access_tokens.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends personal_access_tokensUpdateManyAndReturnArgs>(args: SelectSubset<T, personal_access_tokensUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$personal_access_tokensPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Personal_access_tokens.
     * @param {personal_access_tokensUpsertArgs} args - Arguments to update or create a Personal_access_tokens.
     * @example
     * // Update or create a Personal_access_tokens
     * const personal_access_tokens = await prisma.personal_access_tokens.upsert({
     *   create: {
     *     // ... data to create a Personal_access_tokens
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Personal_access_tokens we want to update
     *   }
     * })
     */
    upsert<T extends personal_access_tokensUpsertArgs>(args: SelectSubset<T, personal_access_tokensUpsertArgs<ExtArgs>>): Prisma__personal_access_tokensClient<$Result.GetResult<Prisma.$personal_access_tokensPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Personal_access_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personal_access_tokensCountArgs} args - Arguments to filter Personal_access_tokens to count.
     * @example
     * // Count the number of Personal_access_tokens
     * const count = await prisma.personal_access_tokens.count({
     *   where: {
     *     // ... the filter for the Personal_access_tokens we want to count
     *   }
     * })
    **/
    count<T extends personal_access_tokensCountArgs>(
      args?: Subset<T, personal_access_tokensCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Personal_access_tokensCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Personal_access_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Personal_access_tokensAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Personal_access_tokensAggregateArgs>(args: Subset<T, Personal_access_tokensAggregateArgs>): Prisma.PrismaPromise<GetPersonal_access_tokensAggregateType<T>>

    /**
     * Group by Personal_access_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personal_access_tokensGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends personal_access_tokensGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: personal_access_tokensGroupByArgs['orderBy'] }
        : { orderBy?: personal_access_tokensGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, personal_access_tokensGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonal_access_tokensGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the personal_access_tokens model
   */
  readonly fields: personal_access_tokensFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for personal_access_tokens.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__personal_access_tokensClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the personal_access_tokens model
   */
  interface personal_access_tokensFieldRefs {
    readonly id: FieldRef<"personal_access_tokens", 'BigInt'>
    readonly tokenable_type: FieldRef<"personal_access_tokens", 'String'>
    readonly tokenable_id: FieldRef<"personal_access_tokens", 'BigInt'>
    readonly name: FieldRef<"personal_access_tokens", 'String'>
    readonly token: FieldRef<"personal_access_tokens", 'String'>
    readonly abilities: FieldRef<"personal_access_tokens", 'String'>
    readonly last_used_at: FieldRef<"personal_access_tokens", 'DateTime'>
    readonly expires_at: FieldRef<"personal_access_tokens", 'DateTime'>
    readonly created_at: FieldRef<"personal_access_tokens", 'DateTime'>
    readonly updated_at: FieldRef<"personal_access_tokens", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * personal_access_tokens findUnique
   */
  export type personal_access_tokensFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personal_access_tokens
     */
    select?: personal_access_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the personal_access_tokens
     */
    omit?: personal_access_tokensOmit<ExtArgs> | null
    /**
     * Filter, which personal_access_tokens to fetch.
     */
    where: personal_access_tokensWhereUniqueInput
  }

  /**
   * personal_access_tokens findUniqueOrThrow
   */
  export type personal_access_tokensFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personal_access_tokens
     */
    select?: personal_access_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the personal_access_tokens
     */
    omit?: personal_access_tokensOmit<ExtArgs> | null
    /**
     * Filter, which personal_access_tokens to fetch.
     */
    where: personal_access_tokensWhereUniqueInput
  }

  /**
   * personal_access_tokens findFirst
   */
  export type personal_access_tokensFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personal_access_tokens
     */
    select?: personal_access_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the personal_access_tokens
     */
    omit?: personal_access_tokensOmit<ExtArgs> | null
    /**
     * Filter, which personal_access_tokens to fetch.
     */
    where?: personal_access_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of personal_access_tokens to fetch.
     */
    orderBy?: personal_access_tokensOrderByWithRelationInput | personal_access_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for personal_access_tokens.
     */
    cursor?: personal_access_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` personal_access_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` personal_access_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of personal_access_tokens.
     */
    distinct?: Personal_access_tokensScalarFieldEnum | Personal_access_tokensScalarFieldEnum[]
  }

  /**
   * personal_access_tokens findFirstOrThrow
   */
  export type personal_access_tokensFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personal_access_tokens
     */
    select?: personal_access_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the personal_access_tokens
     */
    omit?: personal_access_tokensOmit<ExtArgs> | null
    /**
     * Filter, which personal_access_tokens to fetch.
     */
    where?: personal_access_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of personal_access_tokens to fetch.
     */
    orderBy?: personal_access_tokensOrderByWithRelationInput | personal_access_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for personal_access_tokens.
     */
    cursor?: personal_access_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` personal_access_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` personal_access_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of personal_access_tokens.
     */
    distinct?: Personal_access_tokensScalarFieldEnum | Personal_access_tokensScalarFieldEnum[]
  }

  /**
   * personal_access_tokens findMany
   */
  export type personal_access_tokensFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personal_access_tokens
     */
    select?: personal_access_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the personal_access_tokens
     */
    omit?: personal_access_tokensOmit<ExtArgs> | null
    /**
     * Filter, which personal_access_tokens to fetch.
     */
    where?: personal_access_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of personal_access_tokens to fetch.
     */
    orderBy?: personal_access_tokensOrderByWithRelationInput | personal_access_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing personal_access_tokens.
     */
    cursor?: personal_access_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` personal_access_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` personal_access_tokens.
     */
    skip?: number
    distinct?: Personal_access_tokensScalarFieldEnum | Personal_access_tokensScalarFieldEnum[]
  }

  /**
   * personal_access_tokens create
   */
  export type personal_access_tokensCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personal_access_tokens
     */
    select?: personal_access_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the personal_access_tokens
     */
    omit?: personal_access_tokensOmit<ExtArgs> | null
    /**
     * The data needed to create a personal_access_tokens.
     */
    data: XOR<personal_access_tokensCreateInput, personal_access_tokensUncheckedCreateInput>
  }

  /**
   * personal_access_tokens createMany
   */
  export type personal_access_tokensCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many personal_access_tokens.
     */
    data: personal_access_tokensCreateManyInput | personal_access_tokensCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * personal_access_tokens createManyAndReturn
   */
  export type personal_access_tokensCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personal_access_tokens
     */
    select?: personal_access_tokensSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the personal_access_tokens
     */
    omit?: personal_access_tokensOmit<ExtArgs> | null
    /**
     * The data used to create many personal_access_tokens.
     */
    data: personal_access_tokensCreateManyInput | personal_access_tokensCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * personal_access_tokens update
   */
  export type personal_access_tokensUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personal_access_tokens
     */
    select?: personal_access_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the personal_access_tokens
     */
    omit?: personal_access_tokensOmit<ExtArgs> | null
    /**
     * The data needed to update a personal_access_tokens.
     */
    data: XOR<personal_access_tokensUpdateInput, personal_access_tokensUncheckedUpdateInput>
    /**
     * Choose, which personal_access_tokens to update.
     */
    where: personal_access_tokensWhereUniqueInput
  }

  /**
   * personal_access_tokens updateMany
   */
  export type personal_access_tokensUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update personal_access_tokens.
     */
    data: XOR<personal_access_tokensUpdateManyMutationInput, personal_access_tokensUncheckedUpdateManyInput>
    /**
     * Filter which personal_access_tokens to update
     */
    where?: personal_access_tokensWhereInput
    /**
     * Limit how many personal_access_tokens to update.
     */
    limit?: number
  }

  /**
   * personal_access_tokens updateManyAndReturn
   */
  export type personal_access_tokensUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personal_access_tokens
     */
    select?: personal_access_tokensSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the personal_access_tokens
     */
    omit?: personal_access_tokensOmit<ExtArgs> | null
    /**
     * The data used to update personal_access_tokens.
     */
    data: XOR<personal_access_tokensUpdateManyMutationInput, personal_access_tokensUncheckedUpdateManyInput>
    /**
     * Filter which personal_access_tokens to update
     */
    where?: personal_access_tokensWhereInput
    /**
     * Limit how many personal_access_tokens to update.
     */
    limit?: number
  }

  /**
   * personal_access_tokens upsert
   */
  export type personal_access_tokensUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personal_access_tokens
     */
    select?: personal_access_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the personal_access_tokens
     */
    omit?: personal_access_tokensOmit<ExtArgs> | null
    /**
     * The filter to search for the personal_access_tokens to update in case it exists.
     */
    where: personal_access_tokensWhereUniqueInput
    /**
     * In case the personal_access_tokens found by the `where` argument doesn't exist, create a new personal_access_tokens with this data.
     */
    create: XOR<personal_access_tokensCreateInput, personal_access_tokensUncheckedCreateInput>
    /**
     * In case the personal_access_tokens was found with the provided `where` argument, update it with this data.
     */
    update: XOR<personal_access_tokensUpdateInput, personal_access_tokensUncheckedUpdateInput>
  }

  /**
   * personal_access_tokens delete
   */
  export type personal_access_tokensDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personal_access_tokens
     */
    select?: personal_access_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the personal_access_tokens
     */
    omit?: personal_access_tokensOmit<ExtArgs> | null
    /**
     * Filter which personal_access_tokens to delete.
     */
    where: personal_access_tokensWhereUniqueInput
  }

  /**
   * personal_access_tokens deleteMany
   */
  export type personal_access_tokensDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which personal_access_tokens to delete
     */
    where?: personal_access_tokensWhereInput
    /**
     * Limit how many personal_access_tokens to delete.
     */
    limit?: number
  }

  /**
   * personal_access_tokens without action
   */
  export type personal_access_tokensDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personal_access_tokens
     */
    select?: personal_access_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the personal_access_tokens
     */
    omit?: personal_access_tokensOmit<ExtArgs> | null
  }


  /**
   * Model role_has_permissions
   */

  export type AggregateRole_has_permissions = {
    _count: Role_has_permissionsCountAggregateOutputType | null
    _avg: Role_has_permissionsAvgAggregateOutputType | null
    _sum: Role_has_permissionsSumAggregateOutputType | null
    _min: Role_has_permissionsMinAggregateOutputType | null
    _max: Role_has_permissionsMaxAggregateOutputType | null
  }

  export type Role_has_permissionsAvgAggregateOutputType = {
    permission_id: number | null
    role_id: number | null
  }

  export type Role_has_permissionsSumAggregateOutputType = {
    permission_id: bigint | null
    role_id: bigint | null
  }

  export type Role_has_permissionsMinAggregateOutputType = {
    permission_id: bigint | null
    role_id: bigint | null
  }

  export type Role_has_permissionsMaxAggregateOutputType = {
    permission_id: bigint | null
    role_id: bigint | null
  }

  export type Role_has_permissionsCountAggregateOutputType = {
    permission_id: number
    role_id: number
    _all: number
  }


  export type Role_has_permissionsAvgAggregateInputType = {
    permission_id?: true
    role_id?: true
  }

  export type Role_has_permissionsSumAggregateInputType = {
    permission_id?: true
    role_id?: true
  }

  export type Role_has_permissionsMinAggregateInputType = {
    permission_id?: true
    role_id?: true
  }

  export type Role_has_permissionsMaxAggregateInputType = {
    permission_id?: true
    role_id?: true
  }

  export type Role_has_permissionsCountAggregateInputType = {
    permission_id?: true
    role_id?: true
    _all?: true
  }

  export type Role_has_permissionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which role_has_permissions to aggregate.
     */
    where?: role_has_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of role_has_permissions to fetch.
     */
    orderBy?: role_has_permissionsOrderByWithRelationInput | role_has_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: role_has_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` role_has_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` role_has_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned role_has_permissions
    **/
    _count?: true | Role_has_permissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Role_has_permissionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Role_has_permissionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Role_has_permissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Role_has_permissionsMaxAggregateInputType
  }

  export type GetRole_has_permissionsAggregateType<T extends Role_has_permissionsAggregateArgs> = {
        [P in keyof T & keyof AggregateRole_has_permissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole_has_permissions[P]>
      : GetScalarType<T[P], AggregateRole_has_permissions[P]>
  }




  export type role_has_permissionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: role_has_permissionsWhereInput
    orderBy?: role_has_permissionsOrderByWithAggregationInput | role_has_permissionsOrderByWithAggregationInput[]
    by: Role_has_permissionsScalarFieldEnum[] | Role_has_permissionsScalarFieldEnum
    having?: role_has_permissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Role_has_permissionsCountAggregateInputType | true
    _avg?: Role_has_permissionsAvgAggregateInputType
    _sum?: Role_has_permissionsSumAggregateInputType
    _min?: Role_has_permissionsMinAggregateInputType
    _max?: Role_has_permissionsMaxAggregateInputType
  }

  export type Role_has_permissionsGroupByOutputType = {
    permission_id: bigint
    role_id: bigint
    _count: Role_has_permissionsCountAggregateOutputType | null
    _avg: Role_has_permissionsAvgAggregateOutputType | null
    _sum: Role_has_permissionsSumAggregateOutputType | null
    _min: Role_has_permissionsMinAggregateOutputType | null
    _max: Role_has_permissionsMaxAggregateOutputType | null
  }

  type GetRole_has_permissionsGroupByPayload<T extends role_has_permissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Role_has_permissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Role_has_permissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Role_has_permissionsGroupByOutputType[P]>
            : GetScalarType<T[P], Role_has_permissionsGroupByOutputType[P]>
        }
      >
    >


  export type role_has_permissionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    permission_id?: boolean
    role_id?: boolean
    permissions?: boolean | permissionsDefaultArgs<ExtArgs>
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role_has_permissions"]>

  export type role_has_permissionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    permission_id?: boolean
    role_id?: boolean
    permissions?: boolean | permissionsDefaultArgs<ExtArgs>
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role_has_permissions"]>

  export type role_has_permissionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    permission_id?: boolean
    role_id?: boolean
    permissions?: boolean | permissionsDefaultArgs<ExtArgs>
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role_has_permissions"]>

  export type role_has_permissionsSelectScalar = {
    permission_id?: boolean
    role_id?: boolean
  }

  export type role_has_permissionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"permission_id" | "role_id", ExtArgs["result"]["role_has_permissions"]>
  export type role_has_permissionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | permissionsDefaultArgs<ExtArgs>
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }
  export type role_has_permissionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | permissionsDefaultArgs<ExtArgs>
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }
  export type role_has_permissionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | permissionsDefaultArgs<ExtArgs>
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }

  export type $role_has_permissionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "role_has_permissions"
    objects: {
      permissions: Prisma.$permissionsPayload<ExtArgs>
      roles: Prisma.$rolesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      permission_id: bigint
      role_id: bigint
    }, ExtArgs["result"]["role_has_permissions"]>
    composites: {}
  }

  type role_has_permissionsGetPayload<S extends boolean | null | undefined | role_has_permissionsDefaultArgs> = $Result.GetResult<Prisma.$role_has_permissionsPayload, S>

  type role_has_permissionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<role_has_permissionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Role_has_permissionsCountAggregateInputType | true
    }

  export interface role_has_permissionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['role_has_permissions'], meta: { name: 'role_has_permissions' } }
    /**
     * Find zero or one Role_has_permissions that matches the filter.
     * @param {role_has_permissionsFindUniqueArgs} args - Arguments to find a Role_has_permissions
     * @example
     * // Get one Role_has_permissions
     * const role_has_permissions = await prisma.role_has_permissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends role_has_permissionsFindUniqueArgs>(args: SelectSubset<T, role_has_permissionsFindUniqueArgs<ExtArgs>>): Prisma__role_has_permissionsClient<$Result.GetResult<Prisma.$role_has_permissionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role_has_permissions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {role_has_permissionsFindUniqueOrThrowArgs} args - Arguments to find a Role_has_permissions
     * @example
     * // Get one Role_has_permissions
     * const role_has_permissions = await prisma.role_has_permissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends role_has_permissionsFindUniqueOrThrowArgs>(args: SelectSubset<T, role_has_permissionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__role_has_permissionsClient<$Result.GetResult<Prisma.$role_has_permissionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role_has_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_has_permissionsFindFirstArgs} args - Arguments to find a Role_has_permissions
     * @example
     * // Get one Role_has_permissions
     * const role_has_permissions = await prisma.role_has_permissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends role_has_permissionsFindFirstArgs>(args?: SelectSubset<T, role_has_permissionsFindFirstArgs<ExtArgs>>): Prisma__role_has_permissionsClient<$Result.GetResult<Prisma.$role_has_permissionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role_has_permissions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_has_permissionsFindFirstOrThrowArgs} args - Arguments to find a Role_has_permissions
     * @example
     * // Get one Role_has_permissions
     * const role_has_permissions = await prisma.role_has_permissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends role_has_permissionsFindFirstOrThrowArgs>(args?: SelectSubset<T, role_has_permissionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__role_has_permissionsClient<$Result.GetResult<Prisma.$role_has_permissionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Role_has_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_has_permissionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Role_has_permissions
     * const role_has_permissions = await prisma.role_has_permissions.findMany()
     * 
     * // Get first 10 Role_has_permissions
     * const role_has_permissions = await prisma.role_has_permissions.findMany({ take: 10 })
     * 
     * // Only select the `permission_id`
     * const role_has_permissionsWithPermission_idOnly = await prisma.role_has_permissions.findMany({ select: { permission_id: true } })
     * 
     */
    findMany<T extends role_has_permissionsFindManyArgs>(args?: SelectSubset<T, role_has_permissionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$role_has_permissionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role_has_permissions.
     * @param {role_has_permissionsCreateArgs} args - Arguments to create a Role_has_permissions.
     * @example
     * // Create one Role_has_permissions
     * const Role_has_permissions = await prisma.role_has_permissions.create({
     *   data: {
     *     // ... data to create a Role_has_permissions
     *   }
     * })
     * 
     */
    create<T extends role_has_permissionsCreateArgs>(args: SelectSubset<T, role_has_permissionsCreateArgs<ExtArgs>>): Prisma__role_has_permissionsClient<$Result.GetResult<Prisma.$role_has_permissionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Role_has_permissions.
     * @param {role_has_permissionsCreateManyArgs} args - Arguments to create many Role_has_permissions.
     * @example
     * // Create many Role_has_permissions
     * const role_has_permissions = await prisma.role_has_permissions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends role_has_permissionsCreateManyArgs>(args?: SelectSubset<T, role_has_permissionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Role_has_permissions and returns the data saved in the database.
     * @param {role_has_permissionsCreateManyAndReturnArgs} args - Arguments to create many Role_has_permissions.
     * @example
     * // Create many Role_has_permissions
     * const role_has_permissions = await prisma.role_has_permissions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Role_has_permissions and only return the `permission_id`
     * const role_has_permissionsWithPermission_idOnly = await prisma.role_has_permissions.createManyAndReturn({
     *   select: { permission_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends role_has_permissionsCreateManyAndReturnArgs>(args?: SelectSubset<T, role_has_permissionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$role_has_permissionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role_has_permissions.
     * @param {role_has_permissionsDeleteArgs} args - Arguments to delete one Role_has_permissions.
     * @example
     * // Delete one Role_has_permissions
     * const Role_has_permissions = await prisma.role_has_permissions.delete({
     *   where: {
     *     // ... filter to delete one Role_has_permissions
     *   }
     * })
     * 
     */
    delete<T extends role_has_permissionsDeleteArgs>(args: SelectSubset<T, role_has_permissionsDeleteArgs<ExtArgs>>): Prisma__role_has_permissionsClient<$Result.GetResult<Prisma.$role_has_permissionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role_has_permissions.
     * @param {role_has_permissionsUpdateArgs} args - Arguments to update one Role_has_permissions.
     * @example
     * // Update one Role_has_permissions
     * const role_has_permissions = await prisma.role_has_permissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends role_has_permissionsUpdateArgs>(args: SelectSubset<T, role_has_permissionsUpdateArgs<ExtArgs>>): Prisma__role_has_permissionsClient<$Result.GetResult<Prisma.$role_has_permissionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Role_has_permissions.
     * @param {role_has_permissionsDeleteManyArgs} args - Arguments to filter Role_has_permissions to delete.
     * @example
     * // Delete a few Role_has_permissions
     * const { count } = await prisma.role_has_permissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends role_has_permissionsDeleteManyArgs>(args?: SelectSubset<T, role_has_permissionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Role_has_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_has_permissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Role_has_permissions
     * const role_has_permissions = await prisma.role_has_permissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends role_has_permissionsUpdateManyArgs>(args: SelectSubset<T, role_has_permissionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Role_has_permissions and returns the data updated in the database.
     * @param {role_has_permissionsUpdateManyAndReturnArgs} args - Arguments to update many Role_has_permissions.
     * @example
     * // Update many Role_has_permissions
     * const role_has_permissions = await prisma.role_has_permissions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Role_has_permissions and only return the `permission_id`
     * const role_has_permissionsWithPermission_idOnly = await prisma.role_has_permissions.updateManyAndReturn({
     *   select: { permission_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends role_has_permissionsUpdateManyAndReturnArgs>(args: SelectSubset<T, role_has_permissionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$role_has_permissionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role_has_permissions.
     * @param {role_has_permissionsUpsertArgs} args - Arguments to update or create a Role_has_permissions.
     * @example
     * // Update or create a Role_has_permissions
     * const role_has_permissions = await prisma.role_has_permissions.upsert({
     *   create: {
     *     // ... data to create a Role_has_permissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role_has_permissions we want to update
     *   }
     * })
     */
    upsert<T extends role_has_permissionsUpsertArgs>(args: SelectSubset<T, role_has_permissionsUpsertArgs<ExtArgs>>): Prisma__role_has_permissionsClient<$Result.GetResult<Prisma.$role_has_permissionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Role_has_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_has_permissionsCountArgs} args - Arguments to filter Role_has_permissions to count.
     * @example
     * // Count the number of Role_has_permissions
     * const count = await prisma.role_has_permissions.count({
     *   where: {
     *     // ... the filter for the Role_has_permissions we want to count
     *   }
     * })
    **/
    count<T extends role_has_permissionsCountArgs>(
      args?: Subset<T, role_has_permissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Role_has_permissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role_has_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Role_has_permissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Role_has_permissionsAggregateArgs>(args: Subset<T, Role_has_permissionsAggregateArgs>): Prisma.PrismaPromise<GetRole_has_permissionsAggregateType<T>>

    /**
     * Group by Role_has_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_has_permissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends role_has_permissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: role_has_permissionsGroupByArgs['orderBy'] }
        : { orderBy?: role_has_permissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, role_has_permissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRole_has_permissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the role_has_permissions model
   */
  readonly fields: role_has_permissionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for role_has_permissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__role_has_permissionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    permissions<T extends permissionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, permissionsDefaultArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    roles<T extends rolesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, rolesDefaultArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the role_has_permissions model
   */
  interface role_has_permissionsFieldRefs {
    readonly permission_id: FieldRef<"role_has_permissions", 'BigInt'>
    readonly role_id: FieldRef<"role_has_permissions", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * role_has_permissions findUnique
   */
  export type role_has_permissionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_has_permissions
     */
    select?: role_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_has_permissions
     */
    omit?: role_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_has_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which role_has_permissions to fetch.
     */
    where: role_has_permissionsWhereUniqueInput
  }

  /**
   * role_has_permissions findUniqueOrThrow
   */
  export type role_has_permissionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_has_permissions
     */
    select?: role_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_has_permissions
     */
    omit?: role_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_has_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which role_has_permissions to fetch.
     */
    where: role_has_permissionsWhereUniqueInput
  }

  /**
   * role_has_permissions findFirst
   */
  export type role_has_permissionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_has_permissions
     */
    select?: role_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_has_permissions
     */
    omit?: role_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_has_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which role_has_permissions to fetch.
     */
    where?: role_has_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of role_has_permissions to fetch.
     */
    orderBy?: role_has_permissionsOrderByWithRelationInput | role_has_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for role_has_permissions.
     */
    cursor?: role_has_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` role_has_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` role_has_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of role_has_permissions.
     */
    distinct?: Role_has_permissionsScalarFieldEnum | Role_has_permissionsScalarFieldEnum[]
  }

  /**
   * role_has_permissions findFirstOrThrow
   */
  export type role_has_permissionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_has_permissions
     */
    select?: role_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_has_permissions
     */
    omit?: role_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_has_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which role_has_permissions to fetch.
     */
    where?: role_has_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of role_has_permissions to fetch.
     */
    orderBy?: role_has_permissionsOrderByWithRelationInput | role_has_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for role_has_permissions.
     */
    cursor?: role_has_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` role_has_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` role_has_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of role_has_permissions.
     */
    distinct?: Role_has_permissionsScalarFieldEnum | Role_has_permissionsScalarFieldEnum[]
  }

  /**
   * role_has_permissions findMany
   */
  export type role_has_permissionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_has_permissions
     */
    select?: role_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_has_permissions
     */
    omit?: role_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_has_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which role_has_permissions to fetch.
     */
    where?: role_has_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of role_has_permissions to fetch.
     */
    orderBy?: role_has_permissionsOrderByWithRelationInput | role_has_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing role_has_permissions.
     */
    cursor?: role_has_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` role_has_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` role_has_permissions.
     */
    skip?: number
    distinct?: Role_has_permissionsScalarFieldEnum | Role_has_permissionsScalarFieldEnum[]
  }

  /**
   * role_has_permissions create
   */
  export type role_has_permissionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_has_permissions
     */
    select?: role_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_has_permissions
     */
    omit?: role_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_has_permissionsInclude<ExtArgs> | null
    /**
     * The data needed to create a role_has_permissions.
     */
    data: XOR<role_has_permissionsCreateInput, role_has_permissionsUncheckedCreateInput>
  }

  /**
   * role_has_permissions createMany
   */
  export type role_has_permissionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many role_has_permissions.
     */
    data: role_has_permissionsCreateManyInput | role_has_permissionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * role_has_permissions createManyAndReturn
   */
  export type role_has_permissionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_has_permissions
     */
    select?: role_has_permissionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the role_has_permissions
     */
    omit?: role_has_permissionsOmit<ExtArgs> | null
    /**
     * The data used to create many role_has_permissions.
     */
    data: role_has_permissionsCreateManyInput | role_has_permissionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_has_permissionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * role_has_permissions update
   */
  export type role_has_permissionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_has_permissions
     */
    select?: role_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_has_permissions
     */
    omit?: role_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_has_permissionsInclude<ExtArgs> | null
    /**
     * The data needed to update a role_has_permissions.
     */
    data: XOR<role_has_permissionsUpdateInput, role_has_permissionsUncheckedUpdateInput>
    /**
     * Choose, which role_has_permissions to update.
     */
    where: role_has_permissionsWhereUniqueInput
  }

  /**
   * role_has_permissions updateMany
   */
  export type role_has_permissionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update role_has_permissions.
     */
    data: XOR<role_has_permissionsUpdateManyMutationInput, role_has_permissionsUncheckedUpdateManyInput>
    /**
     * Filter which role_has_permissions to update
     */
    where?: role_has_permissionsWhereInput
    /**
     * Limit how many role_has_permissions to update.
     */
    limit?: number
  }

  /**
   * role_has_permissions updateManyAndReturn
   */
  export type role_has_permissionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_has_permissions
     */
    select?: role_has_permissionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the role_has_permissions
     */
    omit?: role_has_permissionsOmit<ExtArgs> | null
    /**
     * The data used to update role_has_permissions.
     */
    data: XOR<role_has_permissionsUpdateManyMutationInput, role_has_permissionsUncheckedUpdateManyInput>
    /**
     * Filter which role_has_permissions to update
     */
    where?: role_has_permissionsWhereInput
    /**
     * Limit how many role_has_permissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_has_permissionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * role_has_permissions upsert
   */
  export type role_has_permissionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_has_permissions
     */
    select?: role_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_has_permissions
     */
    omit?: role_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_has_permissionsInclude<ExtArgs> | null
    /**
     * The filter to search for the role_has_permissions to update in case it exists.
     */
    where: role_has_permissionsWhereUniqueInput
    /**
     * In case the role_has_permissions found by the `where` argument doesn't exist, create a new role_has_permissions with this data.
     */
    create: XOR<role_has_permissionsCreateInput, role_has_permissionsUncheckedCreateInput>
    /**
     * In case the role_has_permissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<role_has_permissionsUpdateInput, role_has_permissionsUncheckedUpdateInput>
  }

  /**
   * role_has_permissions delete
   */
  export type role_has_permissionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_has_permissions
     */
    select?: role_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_has_permissions
     */
    omit?: role_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_has_permissionsInclude<ExtArgs> | null
    /**
     * Filter which role_has_permissions to delete.
     */
    where: role_has_permissionsWhereUniqueInput
  }

  /**
   * role_has_permissions deleteMany
   */
  export type role_has_permissionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which role_has_permissions to delete
     */
    where?: role_has_permissionsWhereInput
    /**
     * Limit how many role_has_permissions to delete.
     */
    limit?: number
  }

  /**
   * role_has_permissions without action
   */
  export type role_has_permissionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_has_permissions
     */
    select?: role_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_has_permissions
     */
    omit?: role_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_has_permissionsInclude<ExtArgs> | null
  }


  /**
   * Model roles
   */

  export type AggregateRoles = {
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  export type RolesAvgAggregateOutputType = {
    id: number | null
  }

  export type RolesSumAggregateOutputType = {
    id: bigint | null
  }

  export type RolesMinAggregateOutputType = {
    id: bigint | null
    name: string | null
    guard_name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type RolesMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
    guard_name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type RolesCountAggregateOutputType = {
    id: number
    name: number
    guard_name: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type RolesAvgAggregateInputType = {
    id?: true
  }

  export type RolesSumAggregateInputType = {
    id?: true
  }

  export type RolesMinAggregateInputType = {
    id?: true
    name?: true
    guard_name?: true
    created_at?: true
    updated_at?: true
  }

  export type RolesMaxAggregateInputType = {
    id?: true
    name?: true
    guard_name?: true
    created_at?: true
    updated_at?: true
  }

  export type RolesCountAggregateInputType = {
    id?: true
    name?: true
    guard_name?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type RolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to aggregate.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned roles
    **/
    _count?: true | RolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolesMaxAggregateInputType
  }

  export type GetRolesAggregateType<T extends RolesAggregateArgs> = {
        [P in keyof T & keyof AggregateRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoles[P]>
      : GetScalarType<T[P], AggregateRoles[P]>
  }




  export type rolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rolesWhereInput
    orderBy?: rolesOrderByWithAggregationInput | rolesOrderByWithAggregationInput[]
    by: RolesScalarFieldEnum[] | RolesScalarFieldEnum
    having?: rolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolesCountAggregateInputType | true
    _avg?: RolesAvgAggregateInputType
    _sum?: RolesSumAggregateInputType
    _min?: RolesMinAggregateInputType
    _max?: RolesMaxAggregateInputType
  }

  export type RolesGroupByOutputType = {
    id: bigint
    name: string
    guard_name: string
    created_at: Date | null
    updated_at: Date | null
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  type GetRolesGroupByPayload<T extends rolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolesGroupByOutputType[P]>
            : GetScalarType<T[P], RolesGroupByOutputType[P]>
        }
      >
    >


  export type rolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    guard_name?: boolean
    created_at?: boolean
    updated_at?: boolean
    model_has_roles?: boolean | roles$model_has_rolesArgs<ExtArgs>
    role_has_permissions?: boolean | roles$role_has_permissionsArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roles"]>

  export type rolesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    guard_name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["roles"]>

  export type rolesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    guard_name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["roles"]>

  export type rolesSelectScalar = {
    id?: boolean
    name?: boolean
    guard_name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type rolesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "guard_name" | "created_at" | "updated_at", ExtArgs["result"]["roles"]>
  export type rolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    model_has_roles?: boolean | roles$model_has_rolesArgs<ExtArgs>
    role_has_permissions?: boolean | roles$role_has_permissionsArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type rolesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type rolesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $rolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "roles"
    objects: {
      model_has_roles: Prisma.$model_has_rolesPayload<ExtArgs>[]
      role_has_permissions: Prisma.$role_has_permissionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
      guard_name: string
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["roles"]>
    composites: {}
  }

  type rolesGetPayload<S extends boolean | null | undefined | rolesDefaultArgs> = $Result.GetResult<Prisma.$rolesPayload, S>

  type rolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<rolesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolesCountAggregateInputType | true
    }

  export interface rolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['roles'], meta: { name: 'roles' } }
    /**
     * Find zero or one Roles that matches the filter.
     * @param {rolesFindUniqueArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rolesFindUniqueArgs>(args: SelectSubset<T, rolesFindUniqueArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Roles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {rolesFindUniqueOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rolesFindUniqueOrThrowArgs>(args: SelectSubset<T, rolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindFirstArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rolesFindFirstArgs>(args?: SelectSubset<T, rolesFindFirstArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindFirstOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rolesFindFirstOrThrowArgs>(args?: SelectSubset<T, rolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.roles.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.roles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolesWithIdOnly = await prisma.roles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends rolesFindManyArgs>(args?: SelectSubset<T, rolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Roles.
     * @param {rolesCreateArgs} args - Arguments to create a Roles.
     * @example
     * // Create one Roles
     * const Roles = await prisma.roles.create({
     *   data: {
     *     // ... data to create a Roles
     *   }
     * })
     * 
     */
    create<T extends rolesCreateArgs>(args: SelectSubset<T, rolesCreateArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {rolesCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const roles = await prisma.roles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends rolesCreateManyArgs>(args?: SelectSubset<T, rolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {rolesCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const roles = await prisma.roles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const rolesWithIdOnly = await prisma.roles.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends rolesCreateManyAndReturnArgs>(args?: SelectSubset<T, rolesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Roles.
     * @param {rolesDeleteArgs} args - Arguments to delete one Roles.
     * @example
     * // Delete one Roles
     * const Roles = await prisma.roles.delete({
     *   where: {
     *     // ... filter to delete one Roles
     *   }
     * })
     * 
     */
    delete<T extends rolesDeleteArgs>(args: SelectSubset<T, rolesDeleteArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Roles.
     * @param {rolesUpdateArgs} args - Arguments to update one Roles.
     * @example
     * // Update one Roles
     * const roles = await prisma.roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends rolesUpdateArgs>(args: SelectSubset<T, rolesUpdateArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {rolesDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends rolesDeleteManyArgs>(args?: SelectSubset<T, rolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends rolesUpdateManyArgs>(args: SelectSubset<T, rolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {rolesUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const rolesWithIdOnly = await prisma.roles.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends rolesUpdateManyAndReturnArgs>(args: SelectSubset<T, rolesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Roles.
     * @param {rolesUpsertArgs} args - Arguments to update or create a Roles.
     * @example
     * // Update or create a Roles
     * const roles = await prisma.roles.upsert({
     *   create: {
     *     // ... data to create a Roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roles we want to update
     *   }
     * })
     */
    upsert<T extends rolesUpsertArgs>(args: SelectSubset<T, rolesUpsertArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.roles.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends rolesCountArgs>(
      args?: Subset<T, rolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolesAggregateArgs>(args: Subset<T, RolesAggregateArgs>): Prisma.PrismaPromise<GetRolesAggregateType<T>>

    /**
     * Group by Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rolesGroupByArgs['orderBy'] }
        : { orderBy?: rolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the roles model
   */
  readonly fields: rolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    model_has_roles<T extends roles$model_has_rolesArgs<ExtArgs> = {}>(args?: Subset<T, roles$model_has_rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$model_has_rolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    role_has_permissions<T extends roles$role_has_permissionsArgs<ExtArgs> = {}>(args?: Subset<T, roles$role_has_permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$role_has_permissionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the roles model
   */
  interface rolesFieldRefs {
    readonly id: FieldRef<"roles", 'BigInt'>
    readonly name: FieldRef<"roles", 'String'>
    readonly guard_name: FieldRef<"roles", 'String'>
    readonly created_at: FieldRef<"roles", 'DateTime'>
    readonly updated_at: FieldRef<"roles", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * roles findUnique
   */
  export type rolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles findUniqueOrThrow
   */
  export type rolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles findFirst
   */
  export type rolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles findFirstOrThrow
   */
  export type rolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles findMany
   */
  export type rolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles create
   */
  export type rolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The data needed to create a roles.
     */
    data: XOR<rolesCreateInput, rolesUncheckedCreateInput>
  }

  /**
   * roles createMany
   */
  export type rolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many roles.
     */
    data: rolesCreateManyInput | rolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * roles createManyAndReturn
   */
  export type rolesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * The data used to create many roles.
     */
    data: rolesCreateManyInput | rolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * roles update
   */
  export type rolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The data needed to update a roles.
     */
    data: XOR<rolesUpdateInput, rolesUncheckedUpdateInput>
    /**
     * Choose, which roles to update.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles updateMany
   */
  export type rolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update roles.
     */
    data: XOR<rolesUpdateManyMutationInput, rolesUncheckedUpdateManyInput>
    /**
     * Filter which roles to update
     */
    where?: rolesWhereInput
    /**
     * Limit how many roles to update.
     */
    limit?: number
  }

  /**
   * roles updateManyAndReturn
   */
  export type rolesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * The data used to update roles.
     */
    data: XOR<rolesUpdateManyMutationInput, rolesUncheckedUpdateManyInput>
    /**
     * Filter which roles to update
     */
    where?: rolesWhereInput
    /**
     * Limit how many roles to update.
     */
    limit?: number
  }

  /**
   * roles upsert
   */
  export type rolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The filter to search for the roles to update in case it exists.
     */
    where: rolesWhereUniqueInput
    /**
     * In case the roles found by the `where` argument doesn't exist, create a new roles with this data.
     */
    create: XOR<rolesCreateInput, rolesUncheckedCreateInput>
    /**
     * In case the roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rolesUpdateInput, rolesUncheckedUpdateInput>
  }

  /**
   * roles delete
   */
  export type rolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter which roles to delete.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles deleteMany
   */
  export type rolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to delete
     */
    where?: rolesWhereInput
    /**
     * Limit how many roles to delete.
     */
    limit?: number
  }

  /**
   * roles.model_has_roles
   */
  export type roles$model_has_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_roles
     */
    select?: model_has_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_roles
     */
    omit?: model_has_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_rolesInclude<ExtArgs> | null
    where?: model_has_rolesWhereInput
    orderBy?: model_has_rolesOrderByWithRelationInput | model_has_rolesOrderByWithRelationInput[]
    cursor?: model_has_rolesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Model_has_rolesScalarFieldEnum | Model_has_rolesScalarFieldEnum[]
  }

  /**
   * roles.role_has_permissions
   */
  export type roles$role_has_permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_has_permissions
     */
    select?: role_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_has_permissions
     */
    omit?: role_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_has_permissionsInclude<ExtArgs> | null
    where?: role_has_permissionsWhereInput
    orderBy?: role_has_permissionsOrderByWithRelationInput | role_has_permissionsOrderByWithRelationInput[]
    cursor?: role_has_permissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Role_has_permissionsScalarFieldEnum | Role_has_permissionsScalarFieldEnum[]
  }

  /**
   * roles without action
   */
  export type rolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
  }


  /**
   * Model socialite_users
   */

  export type AggregateSocialite_users = {
    _count: Socialite_usersCountAggregateOutputType | null
    _avg: Socialite_usersAvgAggregateOutputType | null
    _sum: Socialite_usersSumAggregateOutputType | null
    _min: Socialite_usersMinAggregateOutputType | null
    _max: Socialite_usersMaxAggregateOutputType | null
  }

  export type Socialite_usersAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Socialite_usersSumAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
  }

  export type Socialite_usersMinAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    provider: string | null
    provider_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Socialite_usersMaxAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    provider: string | null
    provider_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Socialite_usersCountAggregateOutputType = {
    id: number
    user_id: number
    provider: number
    provider_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Socialite_usersAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Socialite_usersSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Socialite_usersMinAggregateInputType = {
    id?: true
    user_id?: true
    provider?: true
    provider_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Socialite_usersMaxAggregateInputType = {
    id?: true
    user_id?: true
    provider?: true
    provider_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Socialite_usersCountAggregateInputType = {
    id?: true
    user_id?: true
    provider?: true
    provider_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Socialite_usersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which socialite_users to aggregate.
     */
    where?: socialite_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of socialite_users to fetch.
     */
    orderBy?: socialite_usersOrderByWithRelationInput | socialite_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: socialite_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` socialite_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` socialite_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned socialite_users
    **/
    _count?: true | Socialite_usersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Socialite_usersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Socialite_usersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Socialite_usersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Socialite_usersMaxAggregateInputType
  }

  export type GetSocialite_usersAggregateType<T extends Socialite_usersAggregateArgs> = {
        [P in keyof T & keyof AggregateSocialite_users]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSocialite_users[P]>
      : GetScalarType<T[P], AggregateSocialite_users[P]>
  }




  export type socialite_usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: socialite_usersWhereInput
    orderBy?: socialite_usersOrderByWithAggregationInput | socialite_usersOrderByWithAggregationInput[]
    by: Socialite_usersScalarFieldEnum[] | Socialite_usersScalarFieldEnum
    having?: socialite_usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Socialite_usersCountAggregateInputType | true
    _avg?: Socialite_usersAvgAggregateInputType
    _sum?: Socialite_usersSumAggregateInputType
    _min?: Socialite_usersMinAggregateInputType
    _max?: Socialite_usersMaxAggregateInputType
  }

  export type Socialite_usersGroupByOutputType = {
    id: bigint
    user_id: bigint
    provider: string
    provider_id: string
    created_at: Date | null
    updated_at: Date | null
    _count: Socialite_usersCountAggregateOutputType | null
    _avg: Socialite_usersAvgAggregateOutputType | null
    _sum: Socialite_usersSumAggregateOutputType | null
    _min: Socialite_usersMinAggregateOutputType | null
    _max: Socialite_usersMaxAggregateOutputType | null
  }

  type GetSocialite_usersGroupByPayload<T extends socialite_usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Socialite_usersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Socialite_usersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Socialite_usersGroupByOutputType[P]>
            : GetScalarType<T[P], Socialite_usersGroupByOutputType[P]>
        }
      >
    >


  export type socialite_usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    provider?: boolean
    provider_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["socialite_users"]>

  export type socialite_usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    provider?: boolean
    provider_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["socialite_users"]>

  export type socialite_usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    provider?: boolean
    provider_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["socialite_users"]>

  export type socialite_usersSelectScalar = {
    id?: boolean
    user_id?: boolean
    provider?: boolean
    provider_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type socialite_usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "provider" | "provider_id" | "created_at" | "updated_at", ExtArgs["result"]["socialite_users"]>

  export type $socialite_usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "socialite_users"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      user_id: bigint
      provider: string
      provider_id: string
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["socialite_users"]>
    composites: {}
  }

  type socialite_usersGetPayload<S extends boolean | null | undefined | socialite_usersDefaultArgs> = $Result.GetResult<Prisma.$socialite_usersPayload, S>

  type socialite_usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<socialite_usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Socialite_usersCountAggregateInputType | true
    }

  export interface socialite_usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['socialite_users'], meta: { name: 'socialite_users' } }
    /**
     * Find zero or one Socialite_users that matches the filter.
     * @param {socialite_usersFindUniqueArgs} args - Arguments to find a Socialite_users
     * @example
     * // Get one Socialite_users
     * const socialite_users = await prisma.socialite_users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends socialite_usersFindUniqueArgs>(args: SelectSubset<T, socialite_usersFindUniqueArgs<ExtArgs>>): Prisma__socialite_usersClient<$Result.GetResult<Prisma.$socialite_usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Socialite_users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {socialite_usersFindUniqueOrThrowArgs} args - Arguments to find a Socialite_users
     * @example
     * // Get one Socialite_users
     * const socialite_users = await prisma.socialite_users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends socialite_usersFindUniqueOrThrowArgs>(args: SelectSubset<T, socialite_usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__socialite_usersClient<$Result.GetResult<Prisma.$socialite_usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Socialite_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {socialite_usersFindFirstArgs} args - Arguments to find a Socialite_users
     * @example
     * // Get one Socialite_users
     * const socialite_users = await prisma.socialite_users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends socialite_usersFindFirstArgs>(args?: SelectSubset<T, socialite_usersFindFirstArgs<ExtArgs>>): Prisma__socialite_usersClient<$Result.GetResult<Prisma.$socialite_usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Socialite_users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {socialite_usersFindFirstOrThrowArgs} args - Arguments to find a Socialite_users
     * @example
     * // Get one Socialite_users
     * const socialite_users = await prisma.socialite_users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends socialite_usersFindFirstOrThrowArgs>(args?: SelectSubset<T, socialite_usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__socialite_usersClient<$Result.GetResult<Prisma.$socialite_usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Socialite_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {socialite_usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Socialite_users
     * const socialite_users = await prisma.socialite_users.findMany()
     * 
     * // Get first 10 Socialite_users
     * const socialite_users = await prisma.socialite_users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const socialite_usersWithIdOnly = await prisma.socialite_users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends socialite_usersFindManyArgs>(args?: SelectSubset<T, socialite_usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$socialite_usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Socialite_users.
     * @param {socialite_usersCreateArgs} args - Arguments to create a Socialite_users.
     * @example
     * // Create one Socialite_users
     * const Socialite_users = await prisma.socialite_users.create({
     *   data: {
     *     // ... data to create a Socialite_users
     *   }
     * })
     * 
     */
    create<T extends socialite_usersCreateArgs>(args: SelectSubset<T, socialite_usersCreateArgs<ExtArgs>>): Prisma__socialite_usersClient<$Result.GetResult<Prisma.$socialite_usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Socialite_users.
     * @param {socialite_usersCreateManyArgs} args - Arguments to create many Socialite_users.
     * @example
     * // Create many Socialite_users
     * const socialite_users = await prisma.socialite_users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends socialite_usersCreateManyArgs>(args?: SelectSubset<T, socialite_usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Socialite_users and returns the data saved in the database.
     * @param {socialite_usersCreateManyAndReturnArgs} args - Arguments to create many Socialite_users.
     * @example
     * // Create many Socialite_users
     * const socialite_users = await prisma.socialite_users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Socialite_users and only return the `id`
     * const socialite_usersWithIdOnly = await prisma.socialite_users.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends socialite_usersCreateManyAndReturnArgs>(args?: SelectSubset<T, socialite_usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$socialite_usersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Socialite_users.
     * @param {socialite_usersDeleteArgs} args - Arguments to delete one Socialite_users.
     * @example
     * // Delete one Socialite_users
     * const Socialite_users = await prisma.socialite_users.delete({
     *   where: {
     *     // ... filter to delete one Socialite_users
     *   }
     * })
     * 
     */
    delete<T extends socialite_usersDeleteArgs>(args: SelectSubset<T, socialite_usersDeleteArgs<ExtArgs>>): Prisma__socialite_usersClient<$Result.GetResult<Prisma.$socialite_usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Socialite_users.
     * @param {socialite_usersUpdateArgs} args - Arguments to update one Socialite_users.
     * @example
     * // Update one Socialite_users
     * const socialite_users = await prisma.socialite_users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends socialite_usersUpdateArgs>(args: SelectSubset<T, socialite_usersUpdateArgs<ExtArgs>>): Prisma__socialite_usersClient<$Result.GetResult<Prisma.$socialite_usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Socialite_users.
     * @param {socialite_usersDeleteManyArgs} args - Arguments to filter Socialite_users to delete.
     * @example
     * // Delete a few Socialite_users
     * const { count } = await prisma.socialite_users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends socialite_usersDeleteManyArgs>(args?: SelectSubset<T, socialite_usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Socialite_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {socialite_usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Socialite_users
     * const socialite_users = await prisma.socialite_users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends socialite_usersUpdateManyArgs>(args: SelectSubset<T, socialite_usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Socialite_users and returns the data updated in the database.
     * @param {socialite_usersUpdateManyAndReturnArgs} args - Arguments to update many Socialite_users.
     * @example
     * // Update many Socialite_users
     * const socialite_users = await prisma.socialite_users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Socialite_users and only return the `id`
     * const socialite_usersWithIdOnly = await prisma.socialite_users.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends socialite_usersUpdateManyAndReturnArgs>(args: SelectSubset<T, socialite_usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$socialite_usersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Socialite_users.
     * @param {socialite_usersUpsertArgs} args - Arguments to update or create a Socialite_users.
     * @example
     * // Update or create a Socialite_users
     * const socialite_users = await prisma.socialite_users.upsert({
     *   create: {
     *     // ... data to create a Socialite_users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Socialite_users we want to update
     *   }
     * })
     */
    upsert<T extends socialite_usersUpsertArgs>(args: SelectSubset<T, socialite_usersUpsertArgs<ExtArgs>>): Prisma__socialite_usersClient<$Result.GetResult<Prisma.$socialite_usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Socialite_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {socialite_usersCountArgs} args - Arguments to filter Socialite_users to count.
     * @example
     * // Count the number of Socialite_users
     * const count = await prisma.socialite_users.count({
     *   where: {
     *     // ... the filter for the Socialite_users we want to count
     *   }
     * })
    **/
    count<T extends socialite_usersCountArgs>(
      args?: Subset<T, socialite_usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Socialite_usersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Socialite_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Socialite_usersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Socialite_usersAggregateArgs>(args: Subset<T, Socialite_usersAggregateArgs>): Prisma.PrismaPromise<GetSocialite_usersAggregateType<T>>

    /**
     * Group by Socialite_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {socialite_usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends socialite_usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: socialite_usersGroupByArgs['orderBy'] }
        : { orderBy?: socialite_usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, socialite_usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSocialite_usersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the socialite_users model
   */
  readonly fields: socialite_usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for socialite_users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__socialite_usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the socialite_users model
   */
  interface socialite_usersFieldRefs {
    readonly id: FieldRef<"socialite_users", 'BigInt'>
    readonly user_id: FieldRef<"socialite_users", 'BigInt'>
    readonly provider: FieldRef<"socialite_users", 'String'>
    readonly provider_id: FieldRef<"socialite_users", 'String'>
    readonly created_at: FieldRef<"socialite_users", 'DateTime'>
    readonly updated_at: FieldRef<"socialite_users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * socialite_users findUnique
   */
  export type socialite_usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the socialite_users
     */
    select?: socialite_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the socialite_users
     */
    omit?: socialite_usersOmit<ExtArgs> | null
    /**
     * Filter, which socialite_users to fetch.
     */
    where: socialite_usersWhereUniqueInput
  }

  /**
   * socialite_users findUniqueOrThrow
   */
  export type socialite_usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the socialite_users
     */
    select?: socialite_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the socialite_users
     */
    omit?: socialite_usersOmit<ExtArgs> | null
    /**
     * Filter, which socialite_users to fetch.
     */
    where: socialite_usersWhereUniqueInput
  }

  /**
   * socialite_users findFirst
   */
  export type socialite_usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the socialite_users
     */
    select?: socialite_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the socialite_users
     */
    omit?: socialite_usersOmit<ExtArgs> | null
    /**
     * Filter, which socialite_users to fetch.
     */
    where?: socialite_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of socialite_users to fetch.
     */
    orderBy?: socialite_usersOrderByWithRelationInput | socialite_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for socialite_users.
     */
    cursor?: socialite_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` socialite_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` socialite_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of socialite_users.
     */
    distinct?: Socialite_usersScalarFieldEnum | Socialite_usersScalarFieldEnum[]
  }

  /**
   * socialite_users findFirstOrThrow
   */
  export type socialite_usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the socialite_users
     */
    select?: socialite_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the socialite_users
     */
    omit?: socialite_usersOmit<ExtArgs> | null
    /**
     * Filter, which socialite_users to fetch.
     */
    where?: socialite_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of socialite_users to fetch.
     */
    orderBy?: socialite_usersOrderByWithRelationInput | socialite_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for socialite_users.
     */
    cursor?: socialite_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` socialite_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` socialite_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of socialite_users.
     */
    distinct?: Socialite_usersScalarFieldEnum | Socialite_usersScalarFieldEnum[]
  }

  /**
   * socialite_users findMany
   */
  export type socialite_usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the socialite_users
     */
    select?: socialite_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the socialite_users
     */
    omit?: socialite_usersOmit<ExtArgs> | null
    /**
     * Filter, which socialite_users to fetch.
     */
    where?: socialite_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of socialite_users to fetch.
     */
    orderBy?: socialite_usersOrderByWithRelationInput | socialite_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing socialite_users.
     */
    cursor?: socialite_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` socialite_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` socialite_users.
     */
    skip?: number
    distinct?: Socialite_usersScalarFieldEnum | Socialite_usersScalarFieldEnum[]
  }

  /**
   * socialite_users create
   */
  export type socialite_usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the socialite_users
     */
    select?: socialite_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the socialite_users
     */
    omit?: socialite_usersOmit<ExtArgs> | null
    /**
     * The data needed to create a socialite_users.
     */
    data: XOR<socialite_usersCreateInput, socialite_usersUncheckedCreateInput>
  }

  /**
   * socialite_users createMany
   */
  export type socialite_usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many socialite_users.
     */
    data: socialite_usersCreateManyInput | socialite_usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * socialite_users createManyAndReturn
   */
  export type socialite_usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the socialite_users
     */
    select?: socialite_usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the socialite_users
     */
    omit?: socialite_usersOmit<ExtArgs> | null
    /**
     * The data used to create many socialite_users.
     */
    data: socialite_usersCreateManyInput | socialite_usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * socialite_users update
   */
  export type socialite_usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the socialite_users
     */
    select?: socialite_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the socialite_users
     */
    omit?: socialite_usersOmit<ExtArgs> | null
    /**
     * The data needed to update a socialite_users.
     */
    data: XOR<socialite_usersUpdateInput, socialite_usersUncheckedUpdateInput>
    /**
     * Choose, which socialite_users to update.
     */
    where: socialite_usersWhereUniqueInput
  }

  /**
   * socialite_users updateMany
   */
  export type socialite_usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update socialite_users.
     */
    data: XOR<socialite_usersUpdateManyMutationInput, socialite_usersUncheckedUpdateManyInput>
    /**
     * Filter which socialite_users to update
     */
    where?: socialite_usersWhereInput
    /**
     * Limit how many socialite_users to update.
     */
    limit?: number
  }

  /**
   * socialite_users updateManyAndReturn
   */
  export type socialite_usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the socialite_users
     */
    select?: socialite_usersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the socialite_users
     */
    omit?: socialite_usersOmit<ExtArgs> | null
    /**
     * The data used to update socialite_users.
     */
    data: XOR<socialite_usersUpdateManyMutationInput, socialite_usersUncheckedUpdateManyInput>
    /**
     * Filter which socialite_users to update
     */
    where?: socialite_usersWhereInput
    /**
     * Limit how many socialite_users to update.
     */
    limit?: number
  }

  /**
   * socialite_users upsert
   */
  export type socialite_usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the socialite_users
     */
    select?: socialite_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the socialite_users
     */
    omit?: socialite_usersOmit<ExtArgs> | null
    /**
     * The filter to search for the socialite_users to update in case it exists.
     */
    where: socialite_usersWhereUniqueInput
    /**
     * In case the socialite_users found by the `where` argument doesn't exist, create a new socialite_users with this data.
     */
    create: XOR<socialite_usersCreateInput, socialite_usersUncheckedCreateInput>
    /**
     * In case the socialite_users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<socialite_usersUpdateInput, socialite_usersUncheckedUpdateInput>
  }

  /**
   * socialite_users delete
   */
  export type socialite_usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the socialite_users
     */
    select?: socialite_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the socialite_users
     */
    omit?: socialite_usersOmit<ExtArgs> | null
    /**
     * Filter which socialite_users to delete.
     */
    where: socialite_usersWhereUniqueInput
  }

  /**
   * socialite_users deleteMany
   */
  export type socialite_usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which socialite_users to delete
     */
    where?: socialite_usersWhereInput
    /**
     * Limit how many socialite_users to delete.
     */
    limit?: number
  }

  /**
   * socialite_users without action
   */
  export type socialite_usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the socialite_users
     */
    select?: socialite_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the socialite_users
     */
    omit?: socialite_usersOmit<ExtArgs> | null
  }


  /**
   * Model volunteers
   */

  export type AggregateVolunteers = {
    _count: VolunteersCountAggregateOutputType | null
    _avg: VolunteersAvgAggregateOutputType | null
    _sum: VolunteersSumAggregateOutputType | null
    _min: VolunteersMinAggregateOutputType | null
    _max: VolunteersMaxAggregateOutputType | null
  }

  export type VolunteersAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    project_id: number | null
  }

  export type VolunteersSumAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    project_id: bigint | null
  }

  export type VolunteersMinAggregateOutputType = {
    id: bigint | null
    volunteer_id: string | null
    user_id: bigint | null
    project_id: bigint | null
    first_name: string | null
    last_name: string | null
    email: string | null
    phone: string | null
    experience: string | null
    motivation: string | null
    location: string | null
    occupation: string | null
    status: string | null
    approved_at: Date | null
    notes: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type VolunteersMaxAggregateOutputType = {
    id: bigint | null
    volunteer_id: string | null
    user_id: bigint | null
    project_id: bigint | null
    first_name: string | null
    last_name: string | null
    email: string | null
    phone: string | null
    experience: string | null
    motivation: string | null
    location: string | null
    occupation: string | null
    status: string | null
    approved_at: Date | null
    notes: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type VolunteersCountAggregateOutputType = {
    id: number
    volunteer_id: number
    user_id: number
    project_id: number
    first_name: number
    last_name: number
    email: number
    phone: number
    interests: number
    availability: number
    experience: number
    motivation: number
    location: number
    occupation: number
    status: number
    approved_at: number
    notes: number
    skills: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type VolunteersAvgAggregateInputType = {
    id?: true
    user_id?: true
    project_id?: true
  }

  export type VolunteersSumAggregateInputType = {
    id?: true
    user_id?: true
    project_id?: true
  }

  export type VolunteersMinAggregateInputType = {
    id?: true
    volunteer_id?: true
    user_id?: true
    project_id?: true
    first_name?: true
    last_name?: true
    email?: true
    phone?: true
    experience?: true
    motivation?: true
    location?: true
    occupation?: true
    status?: true
    approved_at?: true
    notes?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type VolunteersMaxAggregateInputType = {
    id?: true
    volunteer_id?: true
    user_id?: true
    project_id?: true
    first_name?: true
    last_name?: true
    email?: true
    phone?: true
    experience?: true
    motivation?: true
    location?: true
    occupation?: true
    status?: true
    approved_at?: true
    notes?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type VolunteersCountAggregateInputType = {
    id?: true
    volunteer_id?: true
    user_id?: true
    project_id?: true
    first_name?: true
    last_name?: true
    email?: true
    phone?: true
    interests?: true
    availability?: true
    experience?: true
    motivation?: true
    location?: true
    occupation?: true
    status?: true
    approved_at?: true
    notes?: true
    skills?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type VolunteersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which volunteers to aggregate.
     */
    where?: volunteersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of volunteers to fetch.
     */
    orderBy?: volunteersOrderByWithRelationInput | volunteersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: volunteersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` volunteers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` volunteers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned volunteers
    **/
    _count?: true | VolunteersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VolunteersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VolunteersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VolunteersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VolunteersMaxAggregateInputType
  }

  export type GetVolunteersAggregateType<T extends VolunteersAggregateArgs> = {
        [P in keyof T & keyof AggregateVolunteers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVolunteers[P]>
      : GetScalarType<T[P], AggregateVolunteers[P]>
  }




  export type volunteersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: volunteersWhereInput
    orderBy?: volunteersOrderByWithAggregationInput | volunteersOrderByWithAggregationInput[]
    by: VolunteersScalarFieldEnum[] | VolunteersScalarFieldEnum
    having?: volunteersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VolunteersCountAggregateInputType | true
    _avg?: VolunteersAvgAggregateInputType
    _sum?: VolunteersSumAggregateInputType
    _min?: VolunteersMinAggregateInputType
    _max?: VolunteersMaxAggregateInputType
  }

  export type VolunteersGroupByOutputType = {
    id: bigint
    volunteer_id: string
    user_id: bigint | null
    project_id: bigint | null
    first_name: string
    last_name: string
    email: string
    phone: string
    interests: JsonValue | null
    availability: JsonValue | null
    experience: string | null
    motivation: string
    location: string | null
    occupation: string | null
    status: string
    approved_at: Date | null
    notes: string | null
    skills: JsonValue | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    _count: VolunteersCountAggregateOutputType | null
    _avg: VolunteersAvgAggregateOutputType | null
    _sum: VolunteersSumAggregateOutputType | null
    _min: VolunteersMinAggregateOutputType | null
    _max: VolunteersMaxAggregateOutputType | null
  }

  type GetVolunteersGroupByPayload<T extends volunteersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VolunteersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VolunteersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VolunteersGroupByOutputType[P]>
            : GetScalarType<T[P], VolunteersGroupByOutputType[P]>
        }
      >
    >


  export type volunteersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    volunteer_id?: boolean
    user_id?: boolean
    project_id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    phone?: boolean
    interests?: boolean
    availability?: boolean
    experience?: boolean
    motivation?: boolean
    location?: boolean
    occupation?: boolean
    status?: boolean
    approved_at?: boolean
    notes?: boolean
    skills?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    projects?: boolean | volunteers$projectsArgs<ExtArgs>
    users?: boolean | volunteers$usersArgs<ExtArgs>
  }, ExtArgs["result"]["volunteers"]>

  export type volunteersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    volunteer_id?: boolean
    user_id?: boolean
    project_id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    phone?: boolean
    interests?: boolean
    availability?: boolean
    experience?: boolean
    motivation?: boolean
    location?: boolean
    occupation?: boolean
    status?: boolean
    approved_at?: boolean
    notes?: boolean
    skills?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    projects?: boolean | volunteers$projectsArgs<ExtArgs>
    users?: boolean | volunteers$usersArgs<ExtArgs>
  }, ExtArgs["result"]["volunteers"]>

  export type volunteersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    volunteer_id?: boolean
    user_id?: boolean
    project_id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    phone?: boolean
    interests?: boolean
    availability?: boolean
    experience?: boolean
    motivation?: boolean
    location?: boolean
    occupation?: boolean
    status?: boolean
    approved_at?: boolean
    notes?: boolean
    skills?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    projects?: boolean | volunteers$projectsArgs<ExtArgs>
    users?: boolean | volunteers$usersArgs<ExtArgs>
  }, ExtArgs["result"]["volunteers"]>

  export type volunteersSelectScalar = {
    id?: boolean
    volunteer_id?: boolean
    user_id?: boolean
    project_id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    phone?: boolean
    interests?: boolean
    availability?: boolean
    experience?: boolean
    motivation?: boolean
    location?: boolean
    occupation?: boolean
    status?: boolean
    approved_at?: boolean
    notes?: boolean
    skills?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type volunteersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "volunteer_id" | "user_id" | "project_id" | "first_name" | "last_name" | "email" | "phone" | "interests" | "availability" | "experience" | "motivation" | "location" | "occupation" | "status" | "approved_at" | "notes" | "skills" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["volunteers"]>
  export type volunteersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | volunteers$projectsArgs<ExtArgs>
    users?: boolean | volunteers$usersArgs<ExtArgs>
  }
  export type volunteersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | volunteers$projectsArgs<ExtArgs>
    users?: boolean | volunteers$usersArgs<ExtArgs>
  }
  export type volunteersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | volunteers$projectsArgs<ExtArgs>
    users?: boolean | volunteers$usersArgs<ExtArgs>
  }

  export type $volunteersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "volunteers"
    objects: {
      projects: Prisma.$ProjectPayload<ExtArgs> | null
      users: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      volunteer_id: string
      user_id: bigint | null
      project_id: bigint | null
      first_name: string
      last_name: string
      email: string
      phone: string
      interests: Prisma.JsonValue | null
      availability: Prisma.JsonValue | null
      experience: string | null
      motivation: string
      location: string | null
      occupation: string | null
      status: string
      approved_at: Date | null
      notes: string | null
      skills: Prisma.JsonValue | null
      created_at: Date | null
      updated_at: Date | null
      deleted_at: Date | null
    }, ExtArgs["result"]["volunteers"]>
    composites: {}
  }

  type volunteersGetPayload<S extends boolean | null | undefined | volunteersDefaultArgs> = $Result.GetResult<Prisma.$volunteersPayload, S>

  type volunteersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<volunteersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VolunteersCountAggregateInputType | true
    }

  export interface volunteersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['volunteers'], meta: { name: 'volunteers' } }
    /**
     * Find zero or one Volunteers that matches the filter.
     * @param {volunteersFindUniqueArgs} args - Arguments to find a Volunteers
     * @example
     * // Get one Volunteers
     * const volunteers = await prisma.volunteers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends volunteersFindUniqueArgs>(args: SelectSubset<T, volunteersFindUniqueArgs<ExtArgs>>): Prisma__volunteersClient<$Result.GetResult<Prisma.$volunteersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Volunteers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {volunteersFindUniqueOrThrowArgs} args - Arguments to find a Volunteers
     * @example
     * // Get one Volunteers
     * const volunteers = await prisma.volunteers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends volunteersFindUniqueOrThrowArgs>(args: SelectSubset<T, volunteersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__volunteersClient<$Result.GetResult<Prisma.$volunteersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Volunteers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {volunteersFindFirstArgs} args - Arguments to find a Volunteers
     * @example
     * // Get one Volunteers
     * const volunteers = await prisma.volunteers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends volunteersFindFirstArgs>(args?: SelectSubset<T, volunteersFindFirstArgs<ExtArgs>>): Prisma__volunteersClient<$Result.GetResult<Prisma.$volunteersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Volunteers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {volunteersFindFirstOrThrowArgs} args - Arguments to find a Volunteers
     * @example
     * // Get one Volunteers
     * const volunteers = await prisma.volunteers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends volunteersFindFirstOrThrowArgs>(args?: SelectSubset<T, volunteersFindFirstOrThrowArgs<ExtArgs>>): Prisma__volunteersClient<$Result.GetResult<Prisma.$volunteersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Volunteers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {volunteersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Volunteers
     * const volunteers = await prisma.volunteers.findMany()
     * 
     * // Get first 10 Volunteers
     * const volunteers = await prisma.volunteers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const volunteersWithIdOnly = await prisma.volunteers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends volunteersFindManyArgs>(args?: SelectSubset<T, volunteersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$volunteersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Volunteers.
     * @param {volunteersCreateArgs} args - Arguments to create a Volunteers.
     * @example
     * // Create one Volunteers
     * const Volunteers = await prisma.volunteers.create({
     *   data: {
     *     // ... data to create a Volunteers
     *   }
     * })
     * 
     */
    create<T extends volunteersCreateArgs>(args: SelectSubset<T, volunteersCreateArgs<ExtArgs>>): Prisma__volunteersClient<$Result.GetResult<Prisma.$volunteersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Volunteers.
     * @param {volunteersCreateManyArgs} args - Arguments to create many Volunteers.
     * @example
     * // Create many Volunteers
     * const volunteers = await prisma.volunteers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends volunteersCreateManyArgs>(args?: SelectSubset<T, volunteersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Volunteers and returns the data saved in the database.
     * @param {volunteersCreateManyAndReturnArgs} args - Arguments to create many Volunteers.
     * @example
     * // Create many Volunteers
     * const volunteers = await prisma.volunteers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Volunteers and only return the `id`
     * const volunteersWithIdOnly = await prisma.volunteers.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends volunteersCreateManyAndReturnArgs>(args?: SelectSubset<T, volunteersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$volunteersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Volunteers.
     * @param {volunteersDeleteArgs} args - Arguments to delete one Volunteers.
     * @example
     * // Delete one Volunteers
     * const Volunteers = await prisma.volunteers.delete({
     *   where: {
     *     // ... filter to delete one Volunteers
     *   }
     * })
     * 
     */
    delete<T extends volunteersDeleteArgs>(args: SelectSubset<T, volunteersDeleteArgs<ExtArgs>>): Prisma__volunteersClient<$Result.GetResult<Prisma.$volunteersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Volunteers.
     * @param {volunteersUpdateArgs} args - Arguments to update one Volunteers.
     * @example
     * // Update one Volunteers
     * const volunteers = await prisma.volunteers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends volunteersUpdateArgs>(args: SelectSubset<T, volunteersUpdateArgs<ExtArgs>>): Prisma__volunteersClient<$Result.GetResult<Prisma.$volunteersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Volunteers.
     * @param {volunteersDeleteManyArgs} args - Arguments to filter Volunteers to delete.
     * @example
     * // Delete a few Volunteers
     * const { count } = await prisma.volunteers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends volunteersDeleteManyArgs>(args?: SelectSubset<T, volunteersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Volunteers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {volunteersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Volunteers
     * const volunteers = await prisma.volunteers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends volunteersUpdateManyArgs>(args: SelectSubset<T, volunteersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Volunteers and returns the data updated in the database.
     * @param {volunteersUpdateManyAndReturnArgs} args - Arguments to update many Volunteers.
     * @example
     * // Update many Volunteers
     * const volunteers = await prisma.volunteers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Volunteers and only return the `id`
     * const volunteersWithIdOnly = await prisma.volunteers.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends volunteersUpdateManyAndReturnArgs>(args: SelectSubset<T, volunteersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$volunteersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Volunteers.
     * @param {volunteersUpsertArgs} args - Arguments to update or create a Volunteers.
     * @example
     * // Update or create a Volunteers
     * const volunteers = await prisma.volunteers.upsert({
     *   create: {
     *     // ... data to create a Volunteers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Volunteers we want to update
     *   }
     * })
     */
    upsert<T extends volunteersUpsertArgs>(args: SelectSubset<T, volunteersUpsertArgs<ExtArgs>>): Prisma__volunteersClient<$Result.GetResult<Prisma.$volunteersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Volunteers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {volunteersCountArgs} args - Arguments to filter Volunteers to count.
     * @example
     * // Count the number of Volunteers
     * const count = await prisma.volunteers.count({
     *   where: {
     *     // ... the filter for the Volunteers we want to count
     *   }
     * })
    **/
    count<T extends volunteersCountArgs>(
      args?: Subset<T, volunteersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VolunteersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Volunteers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolunteersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VolunteersAggregateArgs>(args: Subset<T, VolunteersAggregateArgs>): Prisma.PrismaPromise<GetVolunteersAggregateType<T>>

    /**
     * Group by Volunteers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {volunteersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends volunteersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: volunteersGroupByArgs['orderBy'] }
        : { orderBy?: volunteersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, volunteersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVolunteersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the volunteers model
   */
  readonly fields: volunteersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for volunteers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__volunteersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projects<T extends volunteers$projectsArgs<ExtArgs> = {}>(args?: Subset<T, volunteers$projectsArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends volunteers$usersArgs<ExtArgs> = {}>(args?: Subset<T, volunteers$usersArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the volunteers model
   */
  interface volunteersFieldRefs {
    readonly id: FieldRef<"volunteers", 'BigInt'>
    readonly volunteer_id: FieldRef<"volunteers", 'String'>
    readonly user_id: FieldRef<"volunteers", 'BigInt'>
    readonly project_id: FieldRef<"volunteers", 'BigInt'>
    readonly first_name: FieldRef<"volunteers", 'String'>
    readonly last_name: FieldRef<"volunteers", 'String'>
    readonly email: FieldRef<"volunteers", 'String'>
    readonly phone: FieldRef<"volunteers", 'String'>
    readonly interests: FieldRef<"volunteers", 'Json'>
    readonly availability: FieldRef<"volunteers", 'Json'>
    readonly experience: FieldRef<"volunteers", 'String'>
    readonly motivation: FieldRef<"volunteers", 'String'>
    readonly location: FieldRef<"volunteers", 'String'>
    readonly occupation: FieldRef<"volunteers", 'String'>
    readonly status: FieldRef<"volunteers", 'String'>
    readonly approved_at: FieldRef<"volunteers", 'DateTime'>
    readonly notes: FieldRef<"volunteers", 'String'>
    readonly skills: FieldRef<"volunteers", 'Json'>
    readonly created_at: FieldRef<"volunteers", 'DateTime'>
    readonly updated_at: FieldRef<"volunteers", 'DateTime'>
    readonly deleted_at: FieldRef<"volunteers", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * volunteers findUnique
   */
  export type volunteersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the volunteers
     */
    select?: volunteersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the volunteers
     */
    omit?: volunteersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: volunteersInclude<ExtArgs> | null
    /**
     * Filter, which volunteers to fetch.
     */
    where: volunteersWhereUniqueInput
  }

  /**
   * volunteers findUniqueOrThrow
   */
  export type volunteersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the volunteers
     */
    select?: volunteersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the volunteers
     */
    omit?: volunteersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: volunteersInclude<ExtArgs> | null
    /**
     * Filter, which volunteers to fetch.
     */
    where: volunteersWhereUniqueInput
  }

  /**
   * volunteers findFirst
   */
  export type volunteersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the volunteers
     */
    select?: volunteersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the volunteers
     */
    omit?: volunteersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: volunteersInclude<ExtArgs> | null
    /**
     * Filter, which volunteers to fetch.
     */
    where?: volunteersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of volunteers to fetch.
     */
    orderBy?: volunteersOrderByWithRelationInput | volunteersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for volunteers.
     */
    cursor?: volunteersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` volunteers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` volunteers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of volunteers.
     */
    distinct?: VolunteersScalarFieldEnum | VolunteersScalarFieldEnum[]
  }

  /**
   * volunteers findFirstOrThrow
   */
  export type volunteersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the volunteers
     */
    select?: volunteersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the volunteers
     */
    omit?: volunteersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: volunteersInclude<ExtArgs> | null
    /**
     * Filter, which volunteers to fetch.
     */
    where?: volunteersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of volunteers to fetch.
     */
    orderBy?: volunteersOrderByWithRelationInput | volunteersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for volunteers.
     */
    cursor?: volunteersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` volunteers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` volunteers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of volunteers.
     */
    distinct?: VolunteersScalarFieldEnum | VolunteersScalarFieldEnum[]
  }

  /**
   * volunteers findMany
   */
  export type volunteersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the volunteers
     */
    select?: volunteersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the volunteers
     */
    omit?: volunteersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: volunteersInclude<ExtArgs> | null
    /**
     * Filter, which volunteers to fetch.
     */
    where?: volunteersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of volunteers to fetch.
     */
    orderBy?: volunteersOrderByWithRelationInput | volunteersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing volunteers.
     */
    cursor?: volunteersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` volunteers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` volunteers.
     */
    skip?: number
    distinct?: VolunteersScalarFieldEnum | VolunteersScalarFieldEnum[]
  }

  /**
   * volunteers create
   */
  export type volunteersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the volunteers
     */
    select?: volunteersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the volunteers
     */
    omit?: volunteersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: volunteersInclude<ExtArgs> | null
    /**
     * The data needed to create a volunteers.
     */
    data: XOR<volunteersCreateInput, volunteersUncheckedCreateInput>
  }

  /**
   * volunteers createMany
   */
  export type volunteersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many volunteers.
     */
    data: volunteersCreateManyInput | volunteersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * volunteers createManyAndReturn
   */
  export type volunteersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the volunteers
     */
    select?: volunteersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the volunteers
     */
    omit?: volunteersOmit<ExtArgs> | null
    /**
     * The data used to create many volunteers.
     */
    data: volunteersCreateManyInput | volunteersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: volunteersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * volunteers update
   */
  export type volunteersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the volunteers
     */
    select?: volunteersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the volunteers
     */
    omit?: volunteersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: volunteersInclude<ExtArgs> | null
    /**
     * The data needed to update a volunteers.
     */
    data: XOR<volunteersUpdateInput, volunteersUncheckedUpdateInput>
    /**
     * Choose, which volunteers to update.
     */
    where: volunteersWhereUniqueInput
  }

  /**
   * volunteers updateMany
   */
  export type volunteersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update volunteers.
     */
    data: XOR<volunteersUpdateManyMutationInput, volunteersUncheckedUpdateManyInput>
    /**
     * Filter which volunteers to update
     */
    where?: volunteersWhereInput
    /**
     * Limit how many volunteers to update.
     */
    limit?: number
  }

  /**
   * volunteers updateManyAndReturn
   */
  export type volunteersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the volunteers
     */
    select?: volunteersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the volunteers
     */
    omit?: volunteersOmit<ExtArgs> | null
    /**
     * The data used to update volunteers.
     */
    data: XOR<volunteersUpdateManyMutationInput, volunteersUncheckedUpdateManyInput>
    /**
     * Filter which volunteers to update
     */
    where?: volunteersWhereInput
    /**
     * Limit how many volunteers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: volunteersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * volunteers upsert
   */
  export type volunteersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the volunteers
     */
    select?: volunteersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the volunteers
     */
    omit?: volunteersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: volunteersInclude<ExtArgs> | null
    /**
     * The filter to search for the volunteers to update in case it exists.
     */
    where: volunteersWhereUniqueInput
    /**
     * In case the volunteers found by the `where` argument doesn't exist, create a new volunteers with this data.
     */
    create: XOR<volunteersCreateInput, volunteersUncheckedCreateInput>
    /**
     * In case the volunteers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<volunteersUpdateInput, volunteersUncheckedUpdateInput>
  }

  /**
   * volunteers delete
   */
  export type volunteersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the volunteers
     */
    select?: volunteersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the volunteers
     */
    omit?: volunteersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: volunteersInclude<ExtArgs> | null
    /**
     * Filter which volunteers to delete.
     */
    where: volunteersWhereUniqueInput
  }

  /**
   * volunteers deleteMany
   */
  export type volunteersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which volunteers to delete
     */
    where?: volunteersWhereInput
    /**
     * Limit how many volunteers to delete.
     */
    limit?: number
  }

  /**
   * volunteers.projects
   */
  export type volunteers$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * volunteers.users
   */
  export type volunteers$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * volunteers without action
   */
  export type volunteersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the volunteers
     */
    select?: volunteersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the volunteers
     */
    omit?: volunteersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: volunteersInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    email_verified_at: 'email_verified_at',
    password: 'password',
    remember_token: 'remember_token',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    accesses: 'accesses',
    must_change_password: 'must_change_password'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    ip_address: 'ip_address',
    user_agent: 'user_agent',
    payload: 'payload',
    last_activity: 'last_activity'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    url: 'url',
    titleId: 'titleId',
    titleEn: 'titleEn',
    descriptionId: 'descriptionId',
    descriptionEn: 'descriptionEn',
    location: 'location',
    goalAmount: 'goalAmount',
    raisedAmount: 'raisedAmount',
    studentsImpacted: 'studentsImpacted',
    image: 'image',
    status: 'status',
    featured: 'featured',
    category: 'category',
    startDate: 'startDate',
    endDate: 'endDate',
    school: 'school',
    donorCount: 'donorCount',
    volunteerCount: 'volunteerCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const BlogsScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    user_id: 'user_id',
    title_id: 'title_id',
    excerpt_id: 'excerpt_id',
    content_id: 'content_id',
    title_en: 'title_en',
    excerpt_en: 'excerpt_en',
    content_en: 'content_en',
    author_name: 'author_name',
    author_role: 'author_role',
    author_avatar: 'author_avatar',
    category: 'category',
    tags: 'tags',
    image: 'image',
    image_alt: 'image_alt',
    meta_title_id: 'meta_title_id',
    meta_description_id: 'meta_description_id',
    meta_title_en: 'meta_title_en',
    meta_description_en: 'meta_description_en',
    read_time: 'read_time',
    views_count: 'views_count',
    status: 'status',
    featured: 'featured',
    published_at: 'published_at',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type BlogsScalarFieldEnum = (typeof BlogsScalarFieldEnum)[keyof typeof BlogsScalarFieldEnum]


  export const CacheScalarFieldEnum: {
    key: 'key',
    value: 'value',
    expiration: 'expiration'
  };

  export type CacheScalarFieldEnum = (typeof CacheScalarFieldEnum)[keyof typeof CacheScalarFieldEnum]


  export const Cache_locksScalarFieldEnum: {
    key: 'key',
    owner: 'owner',
    expiration: 'expiration'
  };

  export type Cache_locksScalarFieldEnum = (typeof Cache_locksScalarFieldEnum)[keyof typeof Cache_locksScalarFieldEnum]


  export const ContactsScalarFieldEnum: {
    id: 'id',
    contact_id: 'contact_id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    subject: 'subject',
    message: 'message',
    ip_address: 'ip_address',
    user_agent: 'user_agent',
    status: 'status',
    priority: 'priority',
    assigned_to: 'assigned_to',
    responded_at: 'responded_at',
    response: 'response',
    internal_notes: 'internal_notes',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type ContactsScalarFieldEnum = (typeof ContactsScalarFieldEnum)[keyof typeof ContactsScalarFieldEnum]


  export const DonationsScalarFieldEnum: {
    id: 'id',
    donation_id: 'donation_id',
    project_id: 'project_id',
    user_id: 'user_id',
    donor_name: 'donor_name',
    donor_email: 'donor_email',
    donor_phone: 'donor_phone',
    amount: 'amount',
    frequency: 'frequency',
    status: 'status',
    payment_method: 'payment_method',
    payment_channel: 'payment_channel',
    transaction_id: 'transaction_id',
    paid_at: 'paid_at',
    message: 'message',
    is_anonymous: 'is_anonymous',
    metadata: 'metadata',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type DonationsScalarFieldEnum = (typeof DonationsScalarFieldEnum)[keyof typeof DonationsScalarFieldEnum]


  export const MigrationsScalarFieldEnum: {
    id: 'id',
    migration: 'migration',
    batch: 'batch'
  };

  export type MigrationsScalarFieldEnum = (typeof MigrationsScalarFieldEnum)[keyof typeof MigrationsScalarFieldEnum]


  export const Model_has_permissionsScalarFieldEnum: {
    permission_id: 'permission_id',
    model_type: 'model_type',
    model_id: 'model_id'
  };

  export type Model_has_permissionsScalarFieldEnum = (typeof Model_has_permissionsScalarFieldEnum)[keyof typeof Model_has_permissionsScalarFieldEnum]


  export const Model_has_rolesScalarFieldEnum: {
    role_id: 'role_id',
    model_type: 'model_type',
    model_id: 'model_id'
  };

  export type Model_has_rolesScalarFieldEnum = (typeof Model_has_rolesScalarFieldEnum)[keyof typeof Model_has_rolesScalarFieldEnum]


  export const Password_reset_tokensScalarFieldEnum: {
    email: 'email',
    token: 'token',
    created_at: 'created_at'
  };

  export type Password_reset_tokensScalarFieldEnum = (typeof Password_reset_tokensScalarFieldEnum)[keyof typeof Password_reset_tokensScalarFieldEnum]


  export const PermissionsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    guard_name: 'guard_name',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type PermissionsScalarFieldEnum = (typeof PermissionsScalarFieldEnum)[keyof typeof PermissionsScalarFieldEnum]


  export const Personal_access_tokensScalarFieldEnum: {
    id: 'id',
    tokenable_type: 'tokenable_type',
    tokenable_id: 'tokenable_id',
    name: 'name',
    token: 'token',
    abilities: 'abilities',
    last_used_at: 'last_used_at',
    expires_at: 'expires_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Personal_access_tokensScalarFieldEnum = (typeof Personal_access_tokensScalarFieldEnum)[keyof typeof Personal_access_tokensScalarFieldEnum]


  export const Role_has_permissionsScalarFieldEnum: {
    permission_id: 'permission_id',
    role_id: 'role_id'
  };

  export type Role_has_permissionsScalarFieldEnum = (typeof Role_has_permissionsScalarFieldEnum)[keyof typeof Role_has_permissionsScalarFieldEnum]


  export const RolesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    guard_name: 'guard_name',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type RolesScalarFieldEnum = (typeof RolesScalarFieldEnum)[keyof typeof RolesScalarFieldEnum]


  export const Socialite_usersScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    provider: 'provider',
    provider_id: 'provider_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Socialite_usersScalarFieldEnum = (typeof Socialite_usersScalarFieldEnum)[keyof typeof Socialite_usersScalarFieldEnum]


  export const VolunteersScalarFieldEnum: {
    id: 'id',
    volunteer_id: 'volunteer_id',
    user_id: 'user_id',
    project_id: 'project_id',
    first_name: 'first_name',
    last_name: 'last_name',
    email: 'email',
    phone: 'phone',
    interests: 'interests',
    availability: 'availability',
    experience: 'experience',
    motivation: 'motivation',
    location: 'location',
    occupation: 'occupation',
    status: 'status',
    approved_at: 'approved_at',
    notes: 'notes',
    skills: 'skills',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type VolunteersScalarFieldEnum = (typeof VolunteersScalarFieldEnum)[keyof typeof VolunteersScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: BigIntFilter<"User"> | bigint | number
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    email_verified_at?: DateTimeNullableFilter<"User"> | Date | string | null
    password?: StringFilter<"User"> | string
    remember_token?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeNullableFilter<"User"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    accesses?: JsonNullableFilter<"User">
    must_change_password?: BoolFilter<"User"> | boolean
    blogs?: BlogsListRelationFilter
    contacts?: ContactsListRelationFilter
    donations?: DonationsListRelationFilter
    volunteers?: VolunteersListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    email_verified_at?: SortOrderInput | SortOrder
    password?: SortOrder
    remember_token?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    accesses?: SortOrderInput | SortOrder
    must_change_password?: SortOrder
    blogs?: blogsOrderByRelationAggregateInput
    contacts?: contactsOrderByRelationAggregateInput
    donations?: donationsOrderByRelationAggregateInput
    volunteers?: volunteersOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    email_verified_at?: DateTimeNullableFilter<"User"> | Date | string | null
    password?: StringFilter<"User"> | string
    remember_token?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeNullableFilter<"User"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    accesses?: JsonNullableFilter<"User">
    must_change_password?: BoolFilter<"User"> | boolean
    blogs?: BlogsListRelationFilter
    contacts?: ContactsListRelationFilter
    donations?: DonationsListRelationFilter
    volunteers?: VolunteersListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    email_verified_at?: SortOrderInput | SortOrder
    password?: SortOrder
    remember_token?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    accesses?: SortOrderInput | SortOrder
    must_change_password?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"User"> | bigint | number
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    email_verified_at?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    password?: StringWithAggregatesFilter<"User"> | string
    remember_token?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    accesses?: JsonNullableWithAggregatesFilter<"User">
    must_change_password?: BoolWithAggregatesFilter<"User"> | boolean
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: BigIntNullableFilter<"Session"> | bigint | number | null
    ip_address?: StringNullableFilter<"Session"> | string | null
    user_agent?: StringNullableFilter<"Session"> | string | null
    payload?: StringFilter<"Session"> | string
    last_activity?: IntFilter<"Session"> | number
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    payload?: SortOrder
    last_activity?: SortOrder
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: BigIntNullableFilter<"Session"> | bigint | number | null
    ip_address?: StringNullableFilter<"Session"> | string | null
    user_agent?: StringNullableFilter<"Session"> | string | null
    payload?: StringFilter<"Session"> | string
    last_activity?: IntFilter<"Session"> | number
  }, "id">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    payload?: SortOrder
    last_activity?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _avg?: SessionAvgOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
    _sum?: SessionSumOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: BigIntNullableWithAggregatesFilter<"Session"> | bigint | number | null
    ip_address?: StringNullableWithAggregatesFilter<"Session"> | string | null
    user_agent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    payload?: StringWithAggregatesFilter<"Session"> | string
    last_activity?: IntWithAggregatesFilter<"Session"> | number
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: BigIntFilter<"Project"> | bigint | number
    projectId?: StringFilter<"Project"> | string
    url?: StringFilter<"Project"> | string
    titleId?: StringFilter<"Project"> | string
    titleEn?: StringFilter<"Project"> | string
    descriptionId?: StringFilter<"Project"> | string
    descriptionEn?: StringFilter<"Project"> | string
    location?: StringFilter<"Project"> | string
    goalAmount?: BigIntFilter<"Project"> | bigint | number
    raisedAmount?: BigIntFilter<"Project"> | bigint | number
    studentsImpacted?: IntFilter<"Project"> | number
    image?: StringNullableFilter<"Project"> | string | null
    status?: StringFilter<"Project"> | string
    featured?: BoolFilter<"Project"> | boolean
    category?: StringFilter<"Project"> | string
    startDate?: DateTimeFilter<"Project"> | Date | string
    endDate?: DateTimeFilter<"Project"> | Date | string
    school?: JsonFilter<"Project">
    donorCount?: IntFilter<"Project"> | number
    volunteerCount?: IntFilter<"Project"> | number
    createdAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    donations?: DonationsListRelationFilter
    volunteers?: VolunteersListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    url?: SortOrder
    titleId?: SortOrder
    titleEn?: SortOrder
    descriptionId?: SortOrder
    descriptionEn?: SortOrder
    location?: SortOrder
    goalAmount?: SortOrder
    raisedAmount?: SortOrder
    studentsImpacted?: SortOrder
    image?: SortOrderInput | SortOrder
    status?: SortOrder
    featured?: SortOrder
    category?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    school?: SortOrder
    donorCount?: SortOrder
    volunteerCount?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    donations?: donationsOrderByRelationAggregateInput
    volunteers?: volunteersOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    projectId?: string
    url?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    titleId?: StringFilter<"Project"> | string
    titleEn?: StringFilter<"Project"> | string
    descriptionId?: StringFilter<"Project"> | string
    descriptionEn?: StringFilter<"Project"> | string
    location?: StringFilter<"Project"> | string
    goalAmount?: BigIntFilter<"Project"> | bigint | number
    raisedAmount?: BigIntFilter<"Project"> | bigint | number
    studentsImpacted?: IntFilter<"Project"> | number
    image?: StringNullableFilter<"Project"> | string | null
    status?: StringFilter<"Project"> | string
    featured?: BoolFilter<"Project"> | boolean
    category?: StringFilter<"Project"> | string
    startDate?: DateTimeFilter<"Project"> | Date | string
    endDate?: DateTimeFilter<"Project"> | Date | string
    school?: JsonFilter<"Project">
    donorCount?: IntFilter<"Project"> | number
    volunteerCount?: IntFilter<"Project"> | number
    createdAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    donations?: DonationsListRelationFilter
    volunteers?: VolunteersListRelationFilter
  }, "id" | "projectId" | "url">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    url?: SortOrder
    titleId?: SortOrder
    titleEn?: SortOrder
    descriptionId?: SortOrder
    descriptionEn?: SortOrder
    location?: SortOrder
    goalAmount?: SortOrder
    raisedAmount?: SortOrder
    studentsImpacted?: SortOrder
    image?: SortOrderInput | SortOrder
    status?: SortOrder
    featured?: SortOrder
    category?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    school?: SortOrder
    donorCount?: SortOrder
    volunteerCount?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _avg?: ProjectAvgOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
    _sum?: ProjectSumOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Project"> | bigint | number
    projectId?: StringWithAggregatesFilter<"Project"> | string
    url?: StringWithAggregatesFilter<"Project"> | string
    titleId?: StringWithAggregatesFilter<"Project"> | string
    titleEn?: StringWithAggregatesFilter<"Project"> | string
    descriptionId?: StringWithAggregatesFilter<"Project"> | string
    descriptionEn?: StringWithAggregatesFilter<"Project"> | string
    location?: StringWithAggregatesFilter<"Project"> | string
    goalAmount?: BigIntWithAggregatesFilter<"Project"> | bigint | number
    raisedAmount?: BigIntWithAggregatesFilter<"Project"> | bigint | number
    studentsImpacted?: IntWithAggregatesFilter<"Project"> | number
    image?: StringNullableWithAggregatesFilter<"Project"> | string | null
    status?: StringWithAggregatesFilter<"Project"> | string
    featured?: BoolWithAggregatesFilter<"Project"> | boolean
    category?: StringWithAggregatesFilter<"Project"> | string
    startDate?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    school?: JsonWithAggregatesFilter<"Project">
    donorCount?: IntWithAggregatesFilter<"Project"> | number
    volunteerCount?: IntWithAggregatesFilter<"Project"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
  }

  export type blogsWhereInput = {
    AND?: blogsWhereInput | blogsWhereInput[]
    OR?: blogsWhereInput[]
    NOT?: blogsWhereInput | blogsWhereInput[]
    id?: BigIntFilter<"blogs"> | bigint | number
    slug?: StringFilter<"blogs"> | string
    user_id?: BigIntNullableFilter<"blogs"> | bigint | number | null
    title_id?: StringFilter<"blogs"> | string
    excerpt_id?: StringFilter<"blogs"> | string
    content_id?: StringFilter<"blogs"> | string
    title_en?: StringFilter<"blogs"> | string
    excerpt_en?: StringFilter<"blogs"> | string
    content_en?: StringFilter<"blogs"> | string
    author_name?: StringFilter<"blogs"> | string
    author_role?: StringNullableFilter<"blogs"> | string | null
    author_avatar?: StringNullableFilter<"blogs"> | string | null
    category?: StringFilter<"blogs"> | string
    tags?: JsonNullableFilter<"blogs">
    image?: StringNullableFilter<"blogs"> | string | null
    image_alt?: StringNullableFilter<"blogs"> | string | null
    meta_title_id?: StringNullableFilter<"blogs"> | string | null
    meta_description_id?: StringNullableFilter<"blogs"> | string | null
    meta_title_en?: StringNullableFilter<"blogs"> | string | null
    meta_description_en?: StringNullableFilter<"blogs"> | string | null
    read_time?: IntFilter<"blogs"> | number
    views_count?: BigIntFilter<"blogs"> | bigint | number
    status?: StringFilter<"blogs"> | string
    featured?: BoolFilter<"blogs"> | boolean
    published_at?: DateTimeNullableFilter<"blogs"> | Date | string | null
    created_at?: DateTimeNullableFilter<"blogs"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"blogs"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"blogs"> | Date | string | null
    users?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type blogsOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    user_id?: SortOrderInput | SortOrder
    title_id?: SortOrder
    excerpt_id?: SortOrder
    content_id?: SortOrder
    title_en?: SortOrder
    excerpt_en?: SortOrder
    content_en?: SortOrder
    author_name?: SortOrder
    author_role?: SortOrderInput | SortOrder
    author_avatar?: SortOrderInput | SortOrder
    category?: SortOrder
    tags?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    image_alt?: SortOrderInput | SortOrder
    meta_title_id?: SortOrderInput | SortOrder
    meta_description_id?: SortOrderInput | SortOrder
    meta_title_en?: SortOrderInput | SortOrder
    meta_description_en?: SortOrderInput | SortOrder
    read_time?: SortOrder
    views_count?: SortOrder
    status?: SortOrder
    featured?: SortOrder
    published_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    users?: UserOrderByWithRelationInput
  }

  export type blogsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    slug?: string
    AND?: blogsWhereInput | blogsWhereInput[]
    OR?: blogsWhereInput[]
    NOT?: blogsWhereInput | blogsWhereInput[]
    user_id?: BigIntNullableFilter<"blogs"> | bigint | number | null
    title_id?: StringFilter<"blogs"> | string
    excerpt_id?: StringFilter<"blogs"> | string
    content_id?: StringFilter<"blogs"> | string
    title_en?: StringFilter<"blogs"> | string
    excerpt_en?: StringFilter<"blogs"> | string
    content_en?: StringFilter<"blogs"> | string
    author_name?: StringFilter<"blogs"> | string
    author_role?: StringNullableFilter<"blogs"> | string | null
    author_avatar?: StringNullableFilter<"blogs"> | string | null
    category?: StringFilter<"blogs"> | string
    tags?: JsonNullableFilter<"blogs">
    image?: StringNullableFilter<"blogs"> | string | null
    image_alt?: StringNullableFilter<"blogs"> | string | null
    meta_title_id?: StringNullableFilter<"blogs"> | string | null
    meta_description_id?: StringNullableFilter<"blogs"> | string | null
    meta_title_en?: StringNullableFilter<"blogs"> | string | null
    meta_description_en?: StringNullableFilter<"blogs"> | string | null
    read_time?: IntFilter<"blogs"> | number
    views_count?: BigIntFilter<"blogs"> | bigint | number
    status?: StringFilter<"blogs"> | string
    featured?: BoolFilter<"blogs"> | boolean
    published_at?: DateTimeNullableFilter<"blogs"> | Date | string | null
    created_at?: DateTimeNullableFilter<"blogs"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"blogs"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"blogs"> | Date | string | null
    users?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "slug">

  export type blogsOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    user_id?: SortOrderInput | SortOrder
    title_id?: SortOrder
    excerpt_id?: SortOrder
    content_id?: SortOrder
    title_en?: SortOrder
    excerpt_en?: SortOrder
    content_en?: SortOrder
    author_name?: SortOrder
    author_role?: SortOrderInput | SortOrder
    author_avatar?: SortOrderInput | SortOrder
    category?: SortOrder
    tags?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    image_alt?: SortOrderInput | SortOrder
    meta_title_id?: SortOrderInput | SortOrder
    meta_description_id?: SortOrderInput | SortOrder
    meta_title_en?: SortOrderInput | SortOrder
    meta_description_en?: SortOrderInput | SortOrder
    read_time?: SortOrder
    views_count?: SortOrder
    status?: SortOrder
    featured?: SortOrder
    published_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: blogsCountOrderByAggregateInput
    _avg?: blogsAvgOrderByAggregateInput
    _max?: blogsMaxOrderByAggregateInput
    _min?: blogsMinOrderByAggregateInput
    _sum?: blogsSumOrderByAggregateInput
  }

  export type blogsScalarWhereWithAggregatesInput = {
    AND?: blogsScalarWhereWithAggregatesInput | blogsScalarWhereWithAggregatesInput[]
    OR?: blogsScalarWhereWithAggregatesInput[]
    NOT?: blogsScalarWhereWithAggregatesInput | blogsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"blogs"> | bigint | number
    slug?: StringWithAggregatesFilter<"blogs"> | string
    user_id?: BigIntNullableWithAggregatesFilter<"blogs"> | bigint | number | null
    title_id?: StringWithAggregatesFilter<"blogs"> | string
    excerpt_id?: StringWithAggregatesFilter<"blogs"> | string
    content_id?: StringWithAggregatesFilter<"blogs"> | string
    title_en?: StringWithAggregatesFilter<"blogs"> | string
    excerpt_en?: StringWithAggregatesFilter<"blogs"> | string
    content_en?: StringWithAggregatesFilter<"blogs"> | string
    author_name?: StringWithAggregatesFilter<"blogs"> | string
    author_role?: StringNullableWithAggregatesFilter<"blogs"> | string | null
    author_avatar?: StringNullableWithAggregatesFilter<"blogs"> | string | null
    category?: StringWithAggregatesFilter<"blogs"> | string
    tags?: JsonNullableWithAggregatesFilter<"blogs">
    image?: StringNullableWithAggregatesFilter<"blogs"> | string | null
    image_alt?: StringNullableWithAggregatesFilter<"blogs"> | string | null
    meta_title_id?: StringNullableWithAggregatesFilter<"blogs"> | string | null
    meta_description_id?: StringNullableWithAggregatesFilter<"blogs"> | string | null
    meta_title_en?: StringNullableWithAggregatesFilter<"blogs"> | string | null
    meta_description_en?: StringNullableWithAggregatesFilter<"blogs"> | string | null
    read_time?: IntWithAggregatesFilter<"blogs"> | number
    views_count?: BigIntWithAggregatesFilter<"blogs"> | bigint | number
    status?: StringWithAggregatesFilter<"blogs"> | string
    featured?: BoolWithAggregatesFilter<"blogs"> | boolean
    published_at?: DateTimeNullableWithAggregatesFilter<"blogs"> | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"blogs"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"blogs"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"blogs"> | Date | string | null
  }

  export type cacheWhereInput = {
    AND?: cacheWhereInput | cacheWhereInput[]
    OR?: cacheWhereInput[]
    NOT?: cacheWhereInput | cacheWhereInput[]
    key?: StringFilter<"cache"> | string
    value?: StringFilter<"cache"> | string
    expiration?: IntFilter<"cache"> | number
  }

  export type cacheOrderByWithRelationInput = {
    key?: SortOrder
    value?: SortOrder
    expiration?: SortOrder
  }

  export type cacheWhereUniqueInput = Prisma.AtLeast<{
    key?: string
    AND?: cacheWhereInput | cacheWhereInput[]
    OR?: cacheWhereInput[]
    NOT?: cacheWhereInput | cacheWhereInput[]
    value?: StringFilter<"cache"> | string
    expiration?: IntFilter<"cache"> | number
  }, "key">

  export type cacheOrderByWithAggregationInput = {
    key?: SortOrder
    value?: SortOrder
    expiration?: SortOrder
    _count?: cacheCountOrderByAggregateInput
    _avg?: cacheAvgOrderByAggregateInput
    _max?: cacheMaxOrderByAggregateInput
    _min?: cacheMinOrderByAggregateInput
    _sum?: cacheSumOrderByAggregateInput
  }

  export type cacheScalarWhereWithAggregatesInput = {
    AND?: cacheScalarWhereWithAggregatesInput | cacheScalarWhereWithAggregatesInput[]
    OR?: cacheScalarWhereWithAggregatesInput[]
    NOT?: cacheScalarWhereWithAggregatesInput | cacheScalarWhereWithAggregatesInput[]
    key?: StringWithAggregatesFilter<"cache"> | string
    value?: StringWithAggregatesFilter<"cache"> | string
    expiration?: IntWithAggregatesFilter<"cache"> | number
  }

  export type cache_locksWhereInput = {
    AND?: cache_locksWhereInput | cache_locksWhereInput[]
    OR?: cache_locksWhereInput[]
    NOT?: cache_locksWhereInput | cache_locksWhereInput[]
    key?: StringFilter<"cache_locks"> | string
    owner?: StringFilter<"cache_locks"> | string
    expiration?: IntFilter<"cache_locks"> | number
  }

  export type cache_locksOrderByWithRelationInput = {
    key?: SortOrder
    owner?: SortOrder
    expiration?: SortOrder
  }

  export type cache_locksWhereUniqueInput = Prisma.AtLeast<{
    key?: string
    AND?: cache_locksWhereInput | cache_locksWhereInput[]
    OR?: cache_locksWhereInput[]
    NOT?: cache_locksWhereInput | cache_locksWhereInput[]
    owner?: StringFilter<"cache_locks"> | string
    expiration?: IntFilter<"cache_locks"> | number
  }, "key">

  export type cache_locksOrderByWithAggregationInput = {
    key?: SortOrder
    owner?: SortOrder
    expiration?: SortOrder
    _count?: cache_locksCountOrderByAggregateInput
    _avg?: cache_locksAvgOrderByAggregateInput
    _max?: cache_locksMaxOrderByAggregateInput
    _min?: cache_locksMinOrderByAggregateInput
    _sum?: cache_locksSumOrderByAggregateInput
  }

  export type cache_locksScalarWhereWithAggregatesInput = {
    AND?: cache_locksScalarWhereWithAggregatesInput | cache_locksScalarWhereWithAggregatesInput[]
    OR?: cache_locksScalarWhereWithAggregatesInput[]
    NOT?: cache_locksScalarWhereWithAggregatesInput | cache_locksScalarWhereWithAggregatesInput[]
    key?: StringWithAggregatesFilter<"cache_locks"> | string
    owner?: StringWithAggregatesFilter<"cache_locks"> | string
    expiration?: IntWithAggregatesFilter<"cache_locks"> | number
  }

  export type contactsWhereInput = {
    AND?: contactsWhereInput | contactsWhereInput[]
    OR?: contactsWhereInput[]
    NOT?: contactsWhereInput | contactsWhereInput[]
    id?: BigIntFilter<"contacts"> | bigint | number
    contact_id?: StringFilter<"contacts"> | string
    name?: StringFilter<"contacts"> | string
    email?: StringFilter<"contacts"> | string
    phone?: StringNullableFilter<"contacts"> | string | null
    subject?: StringFilter<"contacts"> | string
    message?: StringFilter<"contacts"> | string
    ip_address?: StringNullableFilter<"contacts"> | string | null
    user_agent?: StringNullableFilter<"contacts"> | string | null
    status?: StringFilter<"contacts"> | string
    priority?: StringFilter<"contacts"> | string
    assigned_to?: BigIntNullableFilter<"contacts"> | bigint | number | null
    responded_at?: DateTimeNullableFilter<"contacts"> | Date | string | null
    response?: StringNullableFilter<"contacts"> | string | null
    internal_notes?: StringNullableFilter<"contacts"> | string | null
    created_at?: DateTimeNullableFilter<"contacts"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"contacts"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"contacts"> | Date | string | null
    users?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type contactsOrderByWithRelationInput = {
    id?: SortOrder
    contact_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    subject?: SortOrder
    message?: SortOrder
    ip_address?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    assigned_to?: SortOrderInput | SortOrder
    responded_at?: SortOrderInput | SortOrder
    response?: SortOrderInput | SortOrder
    internal_notes?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    users?: UserOrderByWithRelationInput
  }

  export type contactsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    contact_id?: string
    AND?: contactsWhereInput | contactsWhereInput[]
    OR?: contactsWhereInput[]
    NOT?: contactsWhereInput | contactsWhereInput[]
    name?: StringFilter<"contacts"> | string
    email?: StringFilter<"contacts"> | string
    phone?: StringNullableFilter<"contacts"> | string | null
    subject?: StringFilter<"contacts"> | string
    message?: StringFilter<"contacts"> | string
    ip_address?: StringNullableFilter<"contacts"> | string | null
    user_agent?: StringNullableFilter<"contacts"> | string | null
    status?: StringFilter<"contacts"> | string
    priority?: StringFilter<"contacts"> | string
    assigned_to?: BigIntNullableFilter<"contacts"> | bigint | number | null
    responded_at?: DateTimeNullableFilter<"contacts"> | Date | string | null
    response?: StringNullableFilter<"contacts"> | string | null
    internal_notes?: StringNullableFilter<"contacts"> | string | null
    created_at?: DateTimeNullableFilter<"contacts"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"contacts"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"contacts"> | Date | string | null
    users?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "contact_id">

  export type contactsOrderByWithAggregationInput = {
    id?: SortOrder
    contact_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    subject?: SortOrder
    message?: SortOrder
    ip_address?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    assigned_to?: SortOrderInput | SortOrder
    responded_at?: SortOrderInput | SortOrder
    response?: SortOrderInput | SortOrder
    internal_notes?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: contactsCountOrderByAggregateInput
    _avg?: contactsAvgOrderByAggregateInput
    _max?: contactsMaxOrderByAggregateInput
    _min?: contactsMinOrderByAggregateInput
    _sum?: contactsSumOrderByAggregateInput
  }

  export type contactsScalarWhereWithAggregatesInput = {
    AND?: contactsScalarWhereWithAggregatesInput | contactsScalarWhereWithAggregatesInput[]
    OR?: contactsScalarWhereWithAggregatesInput[]
    NOT?: contactsScalarWhereWithAggregatesInput | contactsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"contacts"> | bigint | number
    contact_id?: StringWithAggregatesFilter<"contacts"> | string
    name?: StringWithAggregatesFilter<"contacts"> | string
    email?: StringWithAggregatesFilter<"contacts"> | string
    phone?: StringNullableWithAggregatesFilter<"contacts"> | string | null
    subject?: StringWithAggregatesFilter<"contacts"> | string
    message?: StringWithAggregatesFilter<"contacts"> | string
    ip_address?: StringNullableWithAggregatesFilter<"contacts"> | string | null
    user_agent?: StringNullableWithAggregatesFilter<"contacts"> | string | null
    status?: StringWithAggregatesFilter<"contacts"> | string
    priority?: StringWithAggregatesFilter<"contacts"> | string
    assigned_to?: BigIntNullableWithAggregatesFilter<"contacts"> | bigint | number | null
    responded_at?: DateTimeNullableWithAggregatesFilter<"contacts"> | Date | string | null
    response?: StringNullableWithAggregatesFilter<"contacts"> | string | null
    internal_notes?: StringNullableWithAggregatesFilter<"contacts"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"contacts"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"contacts"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"contacts"> | Date | string | null
  }

  export type donationsWhereInput = {
    AND?: donationsWhereInput | donationsWhereInput[]
    OR?: donationsWhereInput[]
    NOT?: donationsWhereInput | donationsWhereInput[]
    id?: BigIntFilter<"donations"> | bigint | number
    donation_id?: StringFilter<"donations"> | string
    project_id?: BigIntFilter<"donations"> | bigint | number
    user_id?: BigIntNullableFilter<"donations"> | bigint | number | null
    donor_name?: StringNullableFilter<"donations"> | string | null
    donor_email?: StringNullableFilter<"donations"> | string | null
    donor_phone?: StringNullableFilter<"donations"> | string | null
    amount?: BigIntFilter<"donations"> | bigint | number
    frequency?: StringFilter<"donations"> | string
    status?: StringFilter<"donations"> | string
    payment_method?: StringNullableFilter<"donations"> | string | null
    payment_channel?: StringNullableFilter<"donations"> | string | null
    transaction_id?: StringNullableFilter<"donations"> | string | null
    paid_at?: DateTimeNullableFilter<"donations"> | Date | string | null
    message?: StringNullableFilter<"donations"> | string | null
    is_anonymous?: BoolFilter<"donations"> | boolean
    metadata?: JsonNullableFilter<"donations">
    created_at?: DateTimeNullableFilter<"donations"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"donations"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"donations"> | Date | string | null
    projects?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    users?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type donationsOrderByWithRelationInput = {
    id?: SortOrder
    donation_id?: SortOrder
    project_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    donor_name?: SortOrderInput | SortOrder
    donor_email?: SortOrderInput | SortOrder
    donor_phone?: SortOrderInput | SortOrder
    amount?: SortOrder
    frequency?: SortOrder
    status?: SortOrder
    payment_method?: SortOrderInput | SortOrder
    payment_channel?: SortOrderInput | SortOrder
    transaction_id?: SortOrderInput | SortOrder
    paid_at?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    is_anonymous?: SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    projects?: ProjectOrderByWithRelationInput
    users?: UserOrderByWithRelationInput
  }

  export type donationsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    donation_id?: string
    AND?: donationsWhereInput | donationsWhereInput[]
    OR?: donationsWhereInput[]
    NOT?: donationsWhereInput | donationsWhereInput[]
    project_id?: BigIntFilter<"donations"> | bigint | number
    user_id?: BigIntNullableFilter<"donations"> | bigint | number | null
    donor_name?: StringNullableFilter<"donations"> | string | null
    donor_email?: StringNullableFilter<"donations"> | string | null
    donor_phone?: StringNullableFilter<"donations"> | string | null
    amount?: BigIntFilter<"donations"> | bigint | number
    frequency?: StringFilter<"donations"> | string
    status?: StringFilter<"donations"> | string
    payment_method?: StringNullableFilter<"donations"> | string | null
    payment_channel?: StringNullableFilter<"donations"> | string | null
    transaction_id?: StringNullableFilter<"donations"> | string | null
    paid_at?: DateTimeNullableFilter<"donations"> | Date | string | null
    message?: StringNullableFilter<"donations"> | string | null
    is_anonymous?: BoolFilter<"donations"> | boolean
    metadata?: JsonNullableFilter<"donations">
    created_at?: DateTimeNullableFilter<"donations"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"donations"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"donations"> | Date | string | null
    projects?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    users?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "donation_id">

  export type donationsOrderByWithAggregationInput = {
    id?: SortOrder
    donation_id?: SortOrder
    project_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    donor_name?: SortOrderInput | SortOrder
    donor_email?: SortOrderInput | SortOrder
    donor_phone?: SortOrderInput | SortOrder
    amount?: SortOrder
    frequency?: SortOrder
    status?: SortOrder
    payment_method?: SortOrderInput | SortOrder
    payment_channel?: SortOrderInput | SortOrder
    transaction_id?: SortOrderInput | SortOrder
    paid_at?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    is_anonymous?: SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: donationsCountOrderByAggregateInput
    _avg?: donationsAvgOrderByAggregateInput
    _max?: donationsMaxOrderByAggregateInput
    _min?: donationsMinOrderByAggregateInput
    _sum?: donationsSumOrderByAggregateInput
  }

  export type donationsScalarWhereWithAggregatesInput = {
    AND?: donationsScalarWhereWithAggregatesInput | donationsScalarWhereWithAggregatesInput[]
    OR?: donationsScalarWhereWithAggregatesInput[]
    NOT?: donationsScalarWhereWithAggregatesInput | donationsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"donations"> | bigint | number
    donation_id?: StringWithAggregatesFilter<"donations"> | string
    project_id?: BigIntWithAggregatesFilter<"donations"> | bigint | number
    user_id?: BigIntNullableWithAggregatesFilter<"donations"> | bigint | number | null
    donor_name?: StringNullableWithAggregatesFilter<"donations"> | string | null
    donor_email?: StringNullableWithAggregatesFilter<"donations"> | string | null
    donor_phone?: StringNullableWithAggregatesFilter<"donations"> | string | null
    amount?: BigIntWithAggregatesFilter<"donations"> | bigint | number
    frequency?: StringWithAggregatesFilter<"donations"> | string
    status?: StringWithAggregatesFilter<"donations"> | string
    payment_method?: StringNullableWithAggregatesFilter<"donations"> | string | null
    payment_channel?: StringNullableWithAggregatesFilter<"donations"> | string | null
    transaction_id?: StringNullableWithAggregatesFilter<"donations"> | string | null
    paid_at?: DateTimeNullableWithAggregatesFilter<"donations"> | Date | string | null
    message?: StringNullableWithAggregatesFilter<"donations"> | string | null
    is_anonymous?: BoolWithAggregatesFilter<"donations"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"donations">
    created_at?: DateTimeNullableWithAggregatesFilter<"donations"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"donations"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"donations"> | Date | string | null
  }

  export type migrationsWhereInput = {
    AND?: migrationsWhereInput | migrationsWhereInput[]
    OR?: migrationsWhereInput[]
    NOT?: migrationsWhereInput | migrationsWhereInput[]
    id?: IntFilter<"migrations"> | number
    migration?: StringFilter<"migrations"> | string
    batch?: IntFilter<"migrations"> | number
  }

  export type migrationsOrderByWithRelationInput = {
    id?: SortOrder
    migration?: SortOrder
    batch?: SortOrder
  }

  export type migrationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: migrationsWhereInput | migrationsWhereInput[]
    OR?: migrationsWhereInput[]
    NOT?: migrationsWhereInput | migrationsWhereInput[]
    migration?: StringFilter<"migrations"> | string
    batch?: IntFilter<"migrations"> | number
  }, "id">

  export type migrationsOrderByWithAggregationInput = {
    id?: SortOrder
    migration?: SortOrder
    batch?: SortOrder
    _count?: migrationsCountOrderByAggregateInput
    _avg?: migrationsAvgOrderByAggregateInput
    _max?: migrationsMaxOrderByAggregateInput
    _min?: migrationsMinOrderByAggregateInput
    _sum?: migrationsSumOrderByAggregateInput
  }

  export type migrationsScalarWhereWithAggregatesInput = {
    AND?: migrationsScalarWhereWithAggregatesInput | migrationsScalarWhereWithAggregatesInput[]
    OR?: migrationsScalarWhereWithAggregatesInput[]
    NOT?: migrationsScalarWhereWithAggregatesInput | migrationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"migrations"> | number
    migration?: StringWithAggregatesFilter<"migrations"> | string
    batch?: IntWithAggregatesFilter<"migrations"> | number
  }

  export type model_has_permissionsWhereInput = {
    AND?: model_has_permissionsWhereInput | model_has_permissionsWhereInput[]
    OR?: model_has_permissionsWhereInput[]
    NOT?: model_has_permissionsWhereInput | model_has_permissionsWhereInput[]
    permission_id?: BigIntFilter<"model_has_permissions"> | bigint | number
    model_type?: StringFilter<"model_has_permissions"> | string
    model_id?: BigIntFilter<"model_has_permissions"> | bigint | number
    permissions?: XOR<PermissionsScalarRelationFilter, permissionsWhereInput>
  }

  export type model_has_permissionsOrderByWithRelationInput = {
    permission_id?: SortOrder
    model_type?: SortOrder
    model_id?: SortOrder
    permissions?: permissionsOrderByWithRelationInput
  }

  export type model_has_permissionsWhereUniqueInput = Prisma.AtLeast<{
    permission_id_model_id_model_type?: model_has_permissionsPermission_idModel_idModel_typeCompoundUniqueInput
    AND?: model_has_permissionsWhereInput | model_has_permissionsWhereInput[]
    OR?: model_has_permissionsWhereInput[]
    NOT?: model_has_permissionsWhereInput | model_has_permissionsWhereInput[]
    permission_id?: BigIntFilter<"model_has_permissions"> | bigint | number
    model_type?: StringFilter<"model_has_permissions"> | string
    model_id?: BigIntFilter<"model_has_permissions"> | bigint | number
    permissions?: XOR<PermissionsScalarRelationFilter, permissionsWhereInput>
  }, "permission_id_model_id_model_type">

  export type model_has_permissionsOrderByWithAggregationInput = {
    permission_id?: SortOrder
    model_type?: SortOrder
    model_id?: SortOrder
    _count?: model_has_permissionsCountOrderByAggregateInput
    _avg?: model_has_permissionsAvgOrderByAggregateInput
    _max?: model_has_permissionsMaxOrderByAggregateInput
    _min?: model_has_permissionsMinOrderByAggregateInput
    _sum?: model_has_permissionsSumOrderByAggregateInput
  }

  export type model_has_permissionsScalarWhereWithAggregatesInput = {
    AND?: model_has_permissionsScalarWhereWithAggregatesInput | model_has_permissionsScalarWhereWithAggregatesInput[]
    OR?: model_has_permissionsScalarWhereWithAggregatesInput[]
    NOT?: model_has_permissionsScalarWhereWithAggregatesInput | model_has_permissionsScalarWhereWithAggregatesInput[]
    permission_id?: BigIntWithAggregatesFilter<"model_has_permissions"> | bigint | number
    model_type?: StringWithAggregatesFilter<"model_has_permissions"> | string
    model_id?: BigIntWithAggregatesFilter<"model_has_permissions"> | bigint | number
  }

  export type model_has_rolesWhereInput = {
    AND?: model_has_rolesWhereInput | model_has_rolesWhereInput[]
    OR?: model_has_rolesWhereInput[]
    NOT?: model_has_rolesWhereInput | model_has_rolesWhereInput[]
    role_id?: BigIntFilter<"model_has_roles"> | bigint | number
    model_type?: StringFilter<"model_has_roles"> | string
    model_id?: BigIntFilter<"model_has_roles"> | bigint | number
    roles?: XOR<RolesScalarRelationFilter, rolesWhereInput>
  }

  export type model_has_rolesOrderByWithRelationInput = {
    role_id?: SortOrder
    model_type?: SortOrder
    model_id?: SortOrder
    roles?: rolesOrderByWithRelationInput
  }

  export type model_has_rolesWhereUniqueInput = Prisma.AtLeast<{
    role_id_model_id_model_type?: model_has_rolesRole_idModel_idModel_typeCompoundUniqueInput
    AND?: model_has_rolesWhereInput | model_has_rolesWhereInput[]
    OR?: model_has_rolesWhereInput[]
    NOT?: model_has_rolesWhereInput | model_has_rolesWhereInput[]
    role_id?: BigIntFilter<"model_has_roles"> | bigint | number
    model_type?: StringFilter<"model_has_roles"> | string
    model_id?: BigIntFilter<"model_has_roles"> | bigint | number
    roles?: XOR<RolesScalarRelationFilter, rolesWhereInput>
  }, "role_id_model_id_model_type">

  export type model_has_rolesOrderByWithAggregationInput = {
    role_id?: SortOrder
    model_type?: SortOrder
    model_id?: SortOrder
    _count?: model_has_rolesCountOrderByAggregateInput
    _avg?: model_has_rolesAvgOrderByAggregateInput
    _max?: model_has_rolesMaxOrderByAggregateInput
    _min?: model_has_rolesMinOrderByAggregateInput
    _sum?: model_has_rolesSumOrderByAggregateInput
  }

  export type model_has_rolesScalarWhereWithAggregatesInput = {
    AND?: model_has_rolesScalarWhereWithAggregatesInput | model_has_rolesScalarWhereWithAggregatesInput[]
    OR?: model_has_rolesScalarWhereWithAggregatesInput[]
    NOT?: model_has_rolesScalarWhereWithAggregatesInput | model_has_rolesScalarWhereWithAggregatesInput[]
    role_id?: BigIntWithAggregatesFilter<"model_has_roles"> | bigint | number
    model_type?: StringWithAggregatesFilter<"model_has_roles"> | string
    model_id?: BigIntWithAggregatesFilter<"model_has_roles"> | bigint | number
  }

  export type password_reset_tokensWhereInput = {
    AND?: password_reset_tokensWhereInput | password_reset_tokensWhereInput[]
    OR?: password_reset_tokensWhereInput[]
    NOT?: password_reset_tokensWhereInput | password_reset_tokensWhereInput[]
    email?: StringFilter<"password_reset_tokens"> | string
    token?: StringFilter<"password_reset_tokens"> | string
    created_at?: DateTimeNullableFilter<"password_reset_tokens"> | Date | string | null
  }

  export type password_reset_tokensOrderByWithRelationInput = {
    email?: SortOrder
    token?: SortOrder
    created_at?: SortOrderInput | SortOrder
  }

  export type password_reset_tokensWhereUniqueInput = Prisma.AtLeast<{
    email?: string
    AND?: password_reset_tokensWhereInput | password_reset_tokensWhereInput[]
    OR?: password_reset_tokensWhereInput[]
    NOT?: password_reset_tokensWhereInput | password_reset_tokensWhereInput[]
    token?: StringFilter<"password_reset_tokens"> | string
    created_at?: DateTimeNullableFilter<"password_reset_tokens"> | Date | string | null
  }, "email">

  export type password_reset_tokensOrderByWithAggregationInput = {
    email?: SortOrder
    token?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: password_reset_tokensCountOrderByAggregateInput
    _max?: password_reset_tokensMaxOrderByAggregateInput
    _min?: password_reset_tokensMinOrderByAggregateInput
  }

  export type password_reset_tokensScalarWhereWithAggregatesInput = {
    AND?: password_reset_tokensScalarWhereWithAggregatesInput | password_reset_tokensScalarWhereWithAggregatesInput[]
    OR?: password_reset_tokensScalarWhereWithAggregatesInput[]
    NOT?: password_reset_tokensScalarWhereWithAggregatesInput | password_reset_tokensScalarWhereWithAggregatesInput[]
    email?: StringWithAggregatesFilter<"password_reset_tokens"> | string
    token?: StringWithAggregatesFilter<"password_reset_tokens"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"password_reset_tokens"> | Date | string | null
  }

  export type permissionsWhereInput = {
    AND?: permissionsWhereInput | permissionsWhereInput[]
    OR?: permissionsWhereInput[]
    NOT?: permissionsWhereInput | permissionsWhereInput[]
    id?: BigIntFilter<"permissions"> | bigint | number
    name?: StringFilter<"permissions"> | string
    guard_name?: StringFilter<"permissions"> | string
    created_at?: DateTimeNullableFilter<"permissions"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"permissions"> | Date | string | null
    model_has_permissions?: Model_has_permissionsListRelationFilter
    role_has_permissions?: Role_has_permissionsListRelationFilter
  }

  export type permissionsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    guard_name?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    model_has_permissions?: model_has_permissionsOrderByRelationAggregateInput
    role_has_permissions?: role_has_permissionsOrderByRelationAggregateInput
  }

  export type permissionsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    name_guard_name?: permissionsNameGuard_nameCompoundUniqueInput
    AND?: permissionsWhereInput | permissionsWhereInput[]
    OR?: permissionsWhereInput[]
    NOT?: permissionsWhereInput | permissionsWhereInput[]
    name?: StringFilter<"permissions"> | string
    guard_name?: StringFilter<"permissions"> | string
    created_at?: DateTimeNullableFilter<"permissions"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"permissions"> | Date | string | null
    model_has_permissions?: Model_has_permissionsListRelationFilter
    role_has_permissions?: Role_has_permissionsListRelationFilter
  }, "id" | "name_guard_name">

  export type permissionsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    guard_name?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: permissionsCountOrderByAggregateInput
    _avg?: permissionsAvgOrderByAggregateInput
    _max?: permissionsMaxOrderByAggregateInput
    _min?: permissionsMinOrderByAggregateInput
    _sum?: permissionsSumOrderByAggregateInput
  }

  export type permissionsScalarWhereWithAggregatesInput = {
    AND?: permissionsScalarWhereWithAggregatesInput | permissionsScalarWhereWithAggregatesInput[]
    OR?: permissionsScalarWhereWithAggregatesInput[]
    NOT?: permissionsScalarWhereWithAggregatesInput | permissionsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"permissions"> | bigint | number
    name?: StringWithAggregatesFilter<"permissions"> | string
    guard_name?: StringWithAggregatesFilter<"permissions"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"permissions"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"permissions"> | Date | string | null
  }

  export type personal_access_tokensWhereInput = {
    AND?: personal_access_tokensWhereInput | personal_access_tokensWhereInput[]
    OR?: personal_access_tokensWhereInput[]
    NOT?: personal_access_tokensWhereInput | personal_access_tokensWhereInput[]
    id?: BigIntFilter<"personal_access_tokens"> | bigint | number
    tokenable_type?: StringFilter<"personal_access_tokens"> | string
    tokenable_id?: BigIntFilter<"personal_access_tokens"> | bigint | number
    name?: StringFilter<"personal_access_tokens"> | string
    token?: StringFilter<"personal_access_tokens"> | string
    abilities?: StringNullableFilter<"personal_access_tokens"> | string | null
    last_used_at?: DateTimeNullableFilter<"personal_access_tokens"> | Date | string | null
    expires_at?: DateTimeNullableFilter<"personal_access_tokens"> | Date | string | null
    created_at?: DateTimeNullableFilter<"personal_access_tokens"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"personal_access_tokens"> | Date | string | null
  }

  export type personal_access_tokensOrderByWithRelationInput = {
    id?: SortOrder
    tokenable_type?: SortOrder
    tokenable_id?: SortOrder
    name?: SortOrder
    token?: SortOrder
    abilities?: SortOrderInput | SortOrder
    last_used_at?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type personal_access_tokensWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    token?: string
    AND?: personal_access_tokensWhereInput | personal_access_tokensWhereInput[]
    OR?: personal_access_tokensWhereInput[]
    NOT?: personal_access_tokensWhereInput | personal_access_tokensWhereInput[]
    tokenable_type?: StringFilter<"personal_access_tokens"> | string
    tokenable_id?: BigIntFilter<"personal_access_tokens"> | bigint | number
    name?: StringFilter<"personal_access_tokens"> | string
    abilities?: StringNullableFilter<"personal_access_tokens"> | string | null
    last_used_at?: DateTimeNullableFilter<"personal_access_tokens"> | Date | string | null
    expires_at?: DateTimeNullableFilter<"personal_access_tokens"> | Date | string | null
    created_at?: DateTimeNullableFilter<"personal_access_tokens"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"personal_access_tokens"> | Date | string | null
  }, "id" | "token">

  export type personal_access_tokensOrderByWithAggregationInput = {
    id?: SortOrder
    tokenable_type?: SortOrder
    tokenable_id?: SortOrder
    name?: SortOrder
    token?: SortOrder
    abilities?: SortOrderInput | SortOrder
    last_used_at?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: personal_access_tokensCountOrderByAggregateInput
    _avg?: personal_access_tokensAvgOrderByAggregateInput
    _max?: personal_access_tokensMaxOrderByAggregateInput
    _min?: personal_access_tokensMinOrderByAggregateInput
    _sum?: personal_access_tokensSumOrderByAggregateInput
  }

  export type personal_access_tokensScalarWhereWithAggregatesInput = {
    AND?: personal_access_tokensScalarWhereWithAggregatesInput | personal_access_tokensScalarWhereWithAggregatesInput[]
    OR?: personal_access_tokensScalarWhereWithAggregatesInput[]
    NOT?: personal_access_tokensScalarWhereWithAggregatesInput | personal_access_tokensScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"personal_access_tokens"> | bigint | number
    tokenable_type?: StringWithAggregatesFilter<"personal_access_tokens"> | string
    tokenable_id?: BigIntWithAggregatesFilter<"personal_access_tokens"> | bigint | number
    name?: StringWithAggregatesFilter<"personal_access_tokens"> | string
    token?: StringWithAggregatesFilter<"personal_access_tokens"> | string
    abilities?: StringNullableWithAggregatesFilter<"personal_access_tokens"> | string | null
    last_used_at?: DateTimeNullableWithAggregatesFilter<"personal_access_tokens"> | Date | string | null
    expires_at?: DateTimeNullableWithAggregatesFilter<"personal_access_tokens"> | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"personal_access_tokens"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"personal_access_tokens"> | Date | string | null
  }

  export type role_has_permissionsWhereInput = {
    AND?: role_has_permissionsWhereInput | role_has_permissionsWhereInput[]
    OR?: role_has_permissionsWhereInput[]
    NOT?: role_has_permissionsWhereInput | role_has_permissionsWhereInput[]
    permission_id?: BigIntFilter<"role_has_permissions"> | bigint | number
    role_id?: BigIntFilter<"role_has_permissions"> | bigint | number
    permissions?: XOR<PermissionsScalarRelationFilter, permissionsWhereInput>
    roles?: XOR<RolesScalarRelationFilter, rolesWhereInput>
  }

  export type role_has_permissionsOrderByWithRelationInput = {
    permission_id?: SortOrder
    role_id?: SortOrder
    permissions?: permissionsOrderByWithRelationInput
    roles?: rolesOrderByWithRelationInput
  }

  export type role_has_permissionsWhereUniqueInput = Prisma.AtLeast<{
    permission_id_role_id?: role_has_permissionsPermission_idRole_idCompoundUniqueInput
    AND?: role_has_permissionsWhereInput | role_has_permissionsWhereInput[]
    OR?: role_has_permissionsWhereInput[]
    NOT?: role_has_permissionsWhereInput | role_has_permissionsWhereInput[]
    permission_id?: BigIntFilter<"role_has_permissions"> | bigint | number
    role_id?: BigIntFilter<"role_has_permissions"> | bigint | number
    permissions?: XOR<PermissionsScalarRelationFilter, permissionsWhereInput>
    roles?: XOR<RolesScalarRelationFilter, rolesWhereInput>
  }, "permission_id_role_id">

  export type role_has_permissionsOrderByWithAggregationInput = {
    permission_id?: SortOrder
    role_id?: SortOrder
    _count?: role_has_permissionsCountOrderByAggregateInput
    _avg?: role_has_permissionsAvgOrderByAggregateInput
    _max?: role_has_permissionsMaxOrderByAggregateInput
    _min?: role_has_permissionsMinOrderByAggregateInput
    _sum?: role_has_permissionsSumOrderByAggregateInput
  }

  export type role_has_permissionsScalarWhereWithAggregatesInput = {
    AND?: role_has_permissionsScalarWhereWithAggregatesInput | role_has_permissionsScalarWhereWithAggregatesInput[]
    OR?: role_has_permissionsScalarWhereWithAggregatesInput[]
    NOT?: role_has_permissionsScalarWhereWithAggregatesInput | role_has_permissionsScalarWhereWithAggregatesInput[]
    permission_id?: BigIntWithAggregatesFilter<"role_has_permissions"> | bigint | number
    role_id?: BigIntWithAggregatesFilter<"role_has_permissions"> | bigint | number
  }

  export type rolesWhereInput = {
    AND?: rolesWhereInput | rolesWhereInput[]
    OR?: rolesWhereInput[]
    NOT?: rolesWhereInput | rolesWhereInput[]
    id?: BigIntFilter<"roles"> | bigint | number
    name?: StringFilter<"roles"> | string
    guard_name?: StringFilter<"roles"> | string
    created_at?: DateTimeNullableFilter<"roles"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"roles"> | Date | string | null
    model_has_roles?: Model_has_rolesListRelationFilter
    role_has_permissions?: Role_has_permissionsListRelationFilter
  }

  export type rolesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    guard_name?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    model_has_roles?: model_has_rolesOrderByRelationAggregateInput
    role_has_permissions?: role_has_permissionsOrderByRelationAggregateInput
  }

  export type rolesWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    name_guard_name?: rolesNameGuard_nameCompoundUniqueInput
    AND?: rolesWhereInput | rolesWhereInput[]
    OR?: rolesWhereInput[]
    NOT?: rolesWhereInput | rolesWhereInput[]
    name?: StringFilter<"roles"> | string
    guard_name?: StringFilter<"roles"> | string
    created_at?: DateTimeNullableFilter<"roles"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"roles"> | Date | string | null
    model_has_roles?: Model_has_rolesListRelationFilter
    role_has_permissions?: Role_has_permissionsListRelationFilter
  }, "id" | "name_guard_name">

  export type rolesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    guard_name?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: rolesCountOrderByAggregateInput
    _avg?: rolesAvgOrderByAggregateInput
    _max?: rolesMaxOrderByAggregateInput
    _min?: rolesMinOrderByAggregateInput
    _sum?: rolesSumOrderByAggregateInput
  }

  export type rolesScalarWhereWithAggregatesInput = {
    AND?: rolesScalarWhereWithAggregatesInput | rolesScalarWhereWithAggregatesInput[]
    OR?: rolesScalarWhereWithAggregatesInput[]
    NOT?: rolesScalarWhereWithAggregatesInput | rolesScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"roles"> | bigint | number
    name?: StringWithAggregatesFilter<"roles"> | string
    guard_name?: StringWithAggregatesFilter<"roles"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"roles"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"roles"> | Date | string | null
  }

  export type socialite_usersWhereInput = {
    AND?: socialite_usersWhereInput | socialite_usersWhereInput[]
    OR?: socialite_usersWhereInput[]
    NOT?: socialite_usersWhereInput | socialite_usersWhereInput[]
    id?: BigIntFilter<"socialite_users"> | bigint | number
    user_id?: BigIntFilter<"socialite_users"> | bigint | number
    provider?: StringFilter<"socialite_users"> | string
    provider_id?: StringFilter<"socialite_users"> | string
    created_at?: DateTimeNullableFilter<"socialite_users"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"socialite_users"> | Date | string | null
  }

  export type socialite_usersOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    provider?: SortOrder
    provider_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type socialite_usersWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    provider_provider_id?: socialite_usersProviderProvider_idCompoundUniqueInput
    AND?: socialite_usersWhereInput | socialite_usersWhereInput[]
    OR?: socialite_usersWhereInput[]
    NOT?: socialite_usersWhereInput | socialite_usersWhereInput[]
    user_id?: BigIntFilter<"socialite_users"> | bigint | number
    provider?: StringFilter<"socialite_users"> | string
    provider_id?: StringFilter<"socialite_users"> | string
    created_at?: DateTimeNullableFilter<"socialite_users"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"socialite_users"> | Date | string | null
  }, "id" | "provider_provider_id">

  export type socialite_usersOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    provider?: SortOrder
    provider_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: socialite_usersCountOrderByAggregateInput
    _avg?: socialite_usersAvgOrderByAggregateInput
    _max?: socialite_usersMaxOrderByAggregateInput
    _min?: socialite_usersMinOrderByAggregateInput
    _sum?: socialite_usersSumOrderByAggregateInput
  }

  export type socialite_usersScalarWhereWithAggregatesInput = {
    AND?: socialite_usersScalarWhereWithAggregatesInput | socialite_usersScalarWhereWithAggregatesInput[]
    OR?: socialite_usersScalarWhereWithAggregatesInput[]
    NOT?: socialite_usersScalarWhereWithAggregatesInput | socialite_usersScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"socialite_users"> | bigint | number
    user_id?: BigIntWithAggregatesFilter<"socialite_users"> | bigint | number
    provider?: StringWithAggregatesFilter<"socialite_users"> | string
    provider_id?: StringWithAggregatesFilter<"socialite_users"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"socialite_users"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"socialite_users"> | Date | string | null
  }

  export type volunteersWhereInput = {
    AND?: volunteersWhereInput | volunteersWhereInput[]
    OR?: volunteersWhereInput[]
    NOT?: volunteersWhereInput | volunteersWhereInput[]
    id?: BigIntFilter<"volunteers"> | bigint | number
    volunteer_id?: StringFilter<"volunteers"> | string
    user_id?: BigIntNullableFilter<"volunteers"> | bigint | number | null
    project_id?: BigIntNullableFilter<"volunteers"> | bigint | number | null
    first_name?: StringFilter<"volunteers"> | string
    last_name?: StringFilter<"volunteers"> | string
    email?: StringFilter<"volunteers"> | string
    phone?: StringFilter<"volunteers"> | string
    interests?: JsonNullableFilter<"volunteers">
    availability?: JsonNullableFilter<"volunteers">
    experience?: StringNullableFilter<"volunteers"> | string | null
    motivation?: StringFilter<"volunteers"> | string
    location?: StringNullableFilter<"volunteers"> | string | null
    occupation?: StringNullableFilter<"volunteers"> | string | null
    status?: StringFilter<"volunteers"> | string
    approved_at?: DateTimeNullableFilter<"volunteers"> | Date | string | null
    notes?: StringNullableFilter<"volunteers"> | string | null
    skills?: JsonNullableFilter<"volunteers">
    created_at?: DateTimeNullableFilter<"volunteers"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"volunteers"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"volunteers"> | Date | string | null
    projects?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    users?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type volunteersOrderByWithRelationInput = {
    id?: SortOrder
    volunteer_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    project_id?: SortOrderInput | SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    interests?: SortOrderInput | SortOrder
    availability?: SortOrderInput | SortOrder
    experience?: SortOrderInput | SortOrder
    motivation?: SortOrder
    location?: SortOrderInput | SortOrder
    occupation?: SortOrderInput | SortOrder
    status?: SortOrder
    approved_at?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    skills?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    projects?: ProjectOrderByWithRelationInput
    users?: UserOrderByWithRelationInput
  }

  export type volunteersWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    volunteer_id?: string
    AND?: volunteersWhereInput | volunteersWhereInput[]
    OR?: volunteersWhereInput[]
    NOT?: volunteersWhereInput | volunteersWhereInput[]
    user_id?: BigIntNullableFilter<"volunteers"> | bigint | number | null
    project_id?: BigIntNullableFilter<"volunteers"> | bigint | number | null
    first_name?: StringFilter<"volunteers"> | string
    last_name?: StringFilter<"volunteers"> | string
    email?: StringFilter<"volunteers"> | string
    phone?: StringFilter<"volunteers"> | string
    interests?: JsonNullableFilter<"volunteers">
    availability?: JsonNullableFilter<"volunteers">
    experience?: StringNullableFilter<"volunteers"> | string | null
    motivation?: StringFilter<"volunteers"> | string
    location?: StringNullableFilter<"volunteers"> | string | null
    occupation?: StringNullableFilter<"volunteers"> | string | null
    status?: StringFilter<"volunteers"> | string
    approved_at?: DateTimeNullableFilter<"volunteers"> | Date | string | null
    notes?: StringNullableFilter<"volunteers"> | string | null
    skills?: JsonNullableFilter<"volunteers">
    created_at?: DateTimeNullableFilter<"volunteers"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"volunteers"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"volunteers"> | Date | string | null
    projects?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    users?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "volunteer_id">

  export type volunteersOrderByWithAggregationInput = {
    id?: SortOrder
    volunteer_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    project_id?: SortOrderInput | SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    interests?: SortOrderInput | SortOrder
    availability?: SortOrderInput | SortOrder
    experience?: SortOrderInput | SortOrder
    motivation?: SortOrder
    location?: SortOrderInput | SortOrder
    occupation?: SortOrderInput | SortOrder
    status?: SortOrder
    approved_at?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    skills?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: volunteersCountOrderByAggregateInput
    _avg?: volunteersAvgOrderByAggregateInput
    _max?: volunteersMaxOrderByAggregateInput
    _min?: volunteersMinOrderByAggregateInput
    _sum?: volunteersSumOrderByAggregateInput
  }

  export type volunteersScalarWhereWithAggregatesInput = {
    AND?: volunteersScalarWhereWithAggregatesInput | volunteersScalarWhereWithAggregatesInput[]
    OR?: volunteersScalarWhereWithAggregatesInput[]
    NOT?: volunteersScalarWhereWithAggregatesInput | volunteersScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"volunteers"> | bigint | number
    volunteer_id?: StringWithAggregatesFilter<"volunteers"> | string
    user_id?: BigIntNullableWithAggregatesFilter<"volunteers"> | bigint | number | null
    project_id?: BigIntNullableWithAggregatesFilter<"volunteers"> | bigint | number | null
    first_name?: StringWithAggregatesFilter<"volunteers"> | string
    last_name?: StringWithAggregatesFilter<"volunteers"> | string
    email?: StringWithAggregatesFilter<"volunteers"> | string
    phone?: StringWithAggregatesFilter<"volunteers"> | string
    interests?: JsonNullableWithAggregatesFilter<"volunteers">
    availability?: JsonNullableWithAggregatesFilter<"volunteers">
    experience?: StringNullableWithAggregatesFilter<"volunteers"> | string | null
    motivation?: StringWithAggregatesFilter<"volunteers"> | string
    location?: StringNullableWithAggregatesFilter<"volunteers"> | string | null
    occupation?: StringNullableWithAggregatesFilter<"volunteers"> | string | null
    status?: StringWithAggregatesFilter<"volunteers"> | string
    approved_at?: DateTimeNullableWithAggregatesFilter<"volunteers"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"volunteers"> | string | null
    skills?: JsonNullableWithAggregatesFilter<"volunteers">
    created_at?: DateTimeNullableWithAggregatesFilter<"volunteers"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"volunteers"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"volunteers"> | Date | string | null
  }

  export type UserCreateInput = {
    id?: bigint | number
    name: string
    email: string
    email_verified_at?: Date | string | null
    password: string
    remember_token?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    accesses?: NullableJsonNullValueInput | InputJsonValue
    must_change_password?: boolean
    blogs?: blogsCreateNestedManyWithoutUsersInput
    contacts?: contactsCreateNestedManyWithoutUsersInput
    donations?: donationsCreateNestedManyWithoutUsersInput
    volunteers?: volunteersCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateInput = {
    id?: bigint | number
    name: string
    email: string
    email_verified_at?: Date | string | null
    password: string
    remember_token?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    accesses?: NullableJsonNullValueInput | InputJsonValue
    must_change_password?: boolean
    blogs?: blogsUncheckedCreateNestedManyWithoutUsersInput
    contacts?: contactsUncheckedCreateNestedManyWithoutUsersInput
    donations?: donationsUncheckedCreateNestedManyWithoutUsersInput
    volunteers?: volunteersUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    remember_token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accesses?: NullableJsonNullValueInput | InputJsonValue
    must_change_password?: BoolFieldUpdateOperationsInput | boolean
    blogs?: blogsUpdateManyWithoutUsersNestedInput
    contacts?: contactsUpdateManyWithoutUsersNestedInput
    donations?: donationsUpdateManyWithoutUsersNestedInput
    volunteers?: volunteersUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    remember_token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accesses?: NullableJsonNullValueInput | InputJsonValue
    must_change_password?: BoolFieldUpdateOperationsInput | boolean
    blogs?: blogsUncheckedUpdateManyWithoutUsersNestedInput
    contacts?: contactsUncheckedUpdateManyWithoutUsersNestedInput
    donations?: donationsUncheckedUpdateManyWithoutUsersNestedInput
    volunteers?: volunteersUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserCreateManyInput = {
    id?: bigint | number
    name: string
    email: string
    email_verified_at?: Date | string | null
    password: string
    remember_token?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    accesses?: NullableJsonNullValueInput | InputJsonValue
    must_change_password?: boolean
  }

  export type UserUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    remember_token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accesses?: NullableJsonNullValueInput | InputJsonValue
    must_change_password?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    remember_token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accesses?: NullableJsonNullValueInput | InputJsonValue
    must_change_password?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SessionCreateInput = {
    id?: string
    userId?: bigint | number | null
    ip_address?: string | null
    user_agent?: string | null
    payload: string
    last_activity: number
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId?: bigint | number | null
    ip_address?: string | null
    user_agent?: string | null
    payload: string
    last_activity: number
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: StringFieldUpdateOperationsInput | string
    last_activity?: IntFieldUpdateOperationsInput | number
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: StringFieldUpdateOperationsInput | string
    last_activity?: IntFieldUpdateOperationsInput | number
  }

  export type SessionCreateManyInput = {
    id?: string
    userId?: bigint | number | null
    ip_address?: string | null
    user_agent?: string | null
    payload: string
    last_activity: number
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: StringFieldUpdateOperationsInput | string
    last_activity?: IntFieldUpdateOperationsInput | number
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: StringFieldUpdateOperationsInput | string
    last_activity?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectCreateInput = {
    id?: bigint | number
    projectId: string
    url: string
    titleId: string
    titleEn: string
    descriptionId: string
    descriptionEn: string
    location: string
    goalAmount: bigint | number
    raisedAmount?: bigint | number
    studentsImpacted: number
    image?: string | null
    status?: string
    featured?: boolean
    category: string
    startDate: Date | string
    endDate: Date | string
    school: JsonNullValueInput | InputJsonValue
    donorCount?: number
    volunteerCount?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    donations?: donationsCreateNestedManyWithoutProjectsInput
    volunteers?: volunteersCreateNestedManyWithoutProjectsInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: bigint | number
    projectId: string
    url: string
    titleId: string
    titleEn: string
    descriptionId: string
    descriptionEn: string
    location: string
    goalAmount: bigint | number
    raisedAmount?: bigint | number
    studentsImpacted: number
    image?: string | null
    status?: string
    featured?: boolean
    category: string
    startDate: Date | string
    endDate: Date | string
    school: JsonNullValueInput | InputJsonValue
    donorCount?: number
    volunteerCount?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    donations?: donationsUncheckedCreateNestedManyWithoutProjectsInput
    volunteers?: volunteersUncheckedCreateNestedManyWithoutProjectsInput
  }

  export type ProjectUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    projectId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    titleId?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionId?: StringFieldUpdateOperationsInput | string
    descriptionEn?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    goalAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    raisedAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    studentsImpacted?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    category?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: JsonNullValueInput | InputJsonValue
    donorCount?: IntFieldUpdateOperationsInput | number
    volunteerCount?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    donations?: donationsUpdateManyWithoutProjectsNestedInput
    volunteers?: volunteersUpdateManyWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    projectId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    titleId?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionId?: StringFieldUpdateOperationsInput | string
    descriptionEn?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    goalAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    raisedAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    studentsImpacted?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    category?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: JsonNullValueInput | InputJsonValue
    donorCount?: IntFieldUpdateOperationsInput | number
    volunteerCount?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    donations?: donationsUncheckedUpdateManyWithoutProjectsNestedInput
    volunteers?: volunteersUncheckedUpdateManyWithoutProjectsNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: bigint | number
    projectId: string
    url: string
    titleId: string
    titleEn: string
    descriptionId: string
    descriptionEn: string
    location: string
    goalAmount: bigint | number
    raisedAmount?: bigint | number
    studentsImpacted: number
    image?: string | null
    status?: string
    featured?: boolean
    category: string
    startDate: Date | string
    endDate: Date | string
    school: JsonNullValueInput | InputJsonValue
    donorCount?: number
    volunteerCount?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type ProjectUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    projectId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    titleId?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionId?: StringFieldUpdateOperationsInput | string
    descriptionEn?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    goalAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    raisedAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    studentsImpacted?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    category?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: JsonNullValueInput | InputJsonValue
    donorCount?: IntFieldUpdateOperationsInput | number
    volunteerCount?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    projectId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    titleId?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionId?: StringFieldUpdateOperationsInput | string
    descriptionEn?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    goalAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    raisedAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    studentsImpacted?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    category?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: JsonNullValueInput | InputJsonValue
    donorCount?: IntFieldUpdateOperationsInput | number
    volunteerCount?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type blogsCreateInput = {
    id?: bigint | number
    slug: string
    title_id: string
    excerpt_id: string
    content_id: string
    title_en: string
    excerpt_en: string
    content_en: string
    author_name: string
    author_role?: string | null
    author_avatar?: string | null
    category: string
    tags?: NullableJsonNullValueInput | InputJsonValue
    image?: string | null
    image_alt?: string | null
    meta_title_id?: string | null
    meta_description_id?: string | null
    meta_title_en?: string | null
    meta_description_en?: string | null
    read_time?: number
    views_count?: bigint | number
    status?: string
    featured?: boolean
    published_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    users?: UserCreateNestedOneWithoutBlogsInput
  }

  export type blogsUncheckedCreateInput = {
    id?: bigint | number
    slug: string
    user_id?: bigint | number | null
    title_id: string
    excerpt_id: string
    content_id: string
    title_en: string
    excerpt_en: string
    content_en: string
    author_name: string
    author_role?: string | null
    author_avatar?: string | null
    category: string
    tags?: NullableJsonNullValueInput | InputJsonValue
    image?: string | null
    image_alt?: string | null
    meta_title_id?: string | null
    meta_description_id?: string | null
    meta_title_en?: string | null
    meta_description_en?: string | null
    read_time?: number
    views_count?: bigint | number
    status?: string
    featured?: boolean
    published_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type blogsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    slug?: StringFieldUpdateOperationsInput | string
    title_id?: StringFieldUpdateOperationsInput | string
    excerpt_id?: StringFieldUpdateOperationsInput | string
    content_id?: StringFieldUpdateOperationsInput | string
    title_en?: StringFieldUpdateOperationsInput | string
    excerpt_en?: StringFieldUpdateOperationsInput | string
    content_en?: StringFieldUpdateOperationsInput | string
    author_name?: StringFieldUpdateOperationsInput | string
    author_role?: NullableStringFieldUpdateOperationsInput | string | null
    author_avatar?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: NullableJsonNullValueInput | InputJsonValue
    image?: NullableStringFieldUpdateOperationsInput | string | null
    image_alt?: NullableStringFieldUpdateOperationsInput | string | null
    meta_title_id?: NullableStringFieldUpdateOperationsInput | string | null
    meta_description_id?: NullableStringFieldUpdateOperationsInput | string | null
    meta_title_en?: NullableStringFieldUpdateOperationsInput | string | null
    meta_description_en?: NullableStringFieldUpdateOperationsInput | string | null
    read_time?: IntFieldUpdateOperationsInput | number
    views_count?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateOneWithoutBlogsNestedInput
  }

  export type blogsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    slug?: StringFieldUpdateOperationsInput | string
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title_id?: StringFieldUpdateOperationsInput | string
    excerpt_id?: StringFieldUpdateOperationsInput | string
    content_id?: StringFieldUpdateOperationsInput | string
    title_en?: StringFieldUpdateOperationsInput | string
    excerpt_en?: StringFieldUpdateOperationsInput | string
    content_en?: StringFieldUpdateOperationsInput | string
    author_name?: StringFieldUpdateOperationsInput | string
    author_role?: NullableStringFieldUpdateOperationsInput | string | null
    author_avatar?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: NullableJsonNullValueInput | InputJsonValue
    image?: NullableStringFieldUpdateOperationsInput | string | null
    image_alt?: NullableStringFieldUpdateOperationsInput | string | null
    meta_title_id?: NullableStringFieldUpdateOperationsInput | string | null
    meta_description_id?: NullableStringFieldUpdateOperationsInput | string | null
    meta_title_en?: NullableStringFieldUpdateOperationsInput | string | null
    meta_description_en?: NullableStringFieldUpdateOperationsInput | string | null
    read_time?: IntFieldUpdateOperationsInput | number
    views_count?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type blogsCreateManyInput = {
    id?: bigint | number
    slug: string
    user_id?: bigint | number | null
    title_id: string
    excerpt_id: string
    content_id: string
    title_en: string
    excerpt_en: string
    content_en: string
    author_name: string
    author_role?: string | null
    author_avatar?: string | null
    category: string
    tags?: NullableJsonNullValueInput | InputJsonValue
    image?: string | null
    image_alt?: string | null
    meta_title_id?: string | null
    meta_description_id?: string | null
    meta_title_en?: string | null
    meta_description_en?: string | null
    read_time?: number
    views_count?: bigint | number
    status?: string
    featured?: boolean
    published_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type blogsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    slug?: StringFieldUpdateOperationsInput | string
    title_id?: StringFieldUpdateOperationsInput | string
    excerpt_id?: StringFieldUpdateOperationsInput | string
    content_id?: StringFieldUpdateOperationsInput | string
    title_en?: StringFieldUpdateOperationsInput | string
    excerpt_en?: StringFieldUpdateOperationsInput | string
    content_en?: StringFieldUpdateOperationsInput | string
    author_name?: StringFieldUpdateOperationsInput | string
    author_role?: NullableStringFieldUpdateOperationsInput | string | null
    author_avatar?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: NullableJsonNullValueInput | InputJsonValue
    image?: NullableStringFieldUpdateOperationsInput | string | null
    image_alt?: NullableStringFieldUpdateOperationsInput | string | null
    meta_title_id?: NullableStringFieldUpdateOperationsInput | string | null
    meta_description_id?: NullableStringFieldUpdateOperationsInput | string | null
    meta_title_en?: NullableStringFieldUpdateOperationsInput | string | null
    meta_description_en?: NullableStringFieldUpdateOperationsInput | string | null
    read_time?: IntFieldUpdateOperationsInput | number
    views_count?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type blogsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    slug?: StringFieldUpdateOperationsInput | string
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title_id?: StringFieldUpdateOperationsInput | string
    excerpt_id?: StringFieldUpdateOperationsInput | string
    content_id?: StringFieldUpdateOperationsInput | string
    title_en?: StringFieldUpdateOperationsInput | string
    excerpt_en?: StringFieldUpdateOperationsInput | string
    content_en?: StringFieldUpdateOperationsInput | string
    author_name?: StringFieldUpdateOperationsInput | string
    author_role?: NullableStringFieldUpdateOperationsInput | string | null
    author_avatar?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: NullableJsonNullValueInput | InputJsonValue
    image?: NullableStringFieldUpdateOperationsInput | string | null
    image_alt?: NullableStringFieldUpdateOperationsInput | string | null
    meta_title_id?: NullableStringFieldUpdateOperationsInput | string | null
    meta_description_id?: NullableStringFieldUpdateOperationsInput | string | null
    meta_title_en?: NullableStringFieldUpdateOperationsInput | string | null
    meta_description_en?: NullableStringFieldUpdateOperationsInput | string | null
    read_time?: IntFieldUpdateOperationsInput | number
    views_count?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type cacheCreateInput = {
    key: string
    value: string
    expiration: number
  }

  export type cacheUncheckedCreateInput = {
    key: string
    value: string
    expiration: number
  }

  export type cacheUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiration?: IntFieldUpdateOperationsInput | number
  }

  export type cacheUncheckedUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiration?: IntFieldUpdateOperationsInput | number
  }

  export type cacheCreateManyInput = {
    key: string
    value: string
    expiration: number
  }

  export type cacheUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiration?: IntFieldUpdateOperationsInput | number
  }

  export type cacheUncheckedUpdateManyInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiration?: IntFieldUpdateOperationsInput | number
  }

  export type cache_locksCreateInput = {
    key: string
    owner: string
    expiration: number
  }

  export type cache_locksUncheckedCreateInput = {
    key: string
    owner: string
    expiration: number
  }

  export type cache_locksUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    expiration?: IntFieldUpdateOperationsInput | number
  }

  export type cache_locksUncheckedUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    expiration?: IntFieldUpdateOperationsInput | number
  }

  export type cache_locksCreateManyInput = {
    key: string
    owner: string
    expiration: number
  }

  export type cache_locksUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    expiration?: IntFieldUpdateOperationsInput | number
  }

  export type cache_locksUncheckedUpdateManyInput = {
    key?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    expiration?: IntFieldUpdateOperationsInput | number
  }

  export type contactsCreateInput = {
    id?: bigint | number
    contact_id: string
    name: string
    email: string
    phone?: string | null
    subject?: string
    message: string
    ip_address?: string | null
    user_agent?: string | null
    status?: string
    priority?: string
    responded_at?: Date | string | null
    response?: string | null
    internal_notes?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    users?: UserCreateNestedOneWithoutContactsInput
  }

  export type contactsUncheckedCreateInput = {
    id?: bigint | number
    contact_id: string
    name: string
    email: string
    phone?: string | null
    subject?: string
    message: string
    ip_address?: string | null
    user_agent?: string | null
    status?: string
    priority?: string
    assigned_to?: bigint | number | null
    responded_at?: Date | string | null
    response?: string | null
    internal_notes?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type contactsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    contact_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    responded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateOneWithoutContactsNestedInput
  }

  export type contactsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    contact_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    assigned_to?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    responded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type contactsCreateManyInput = {
    id?: bigint | number
    contact_id: string
    name: string
    email: string
    phone?: string | null
    subject?: string
    message: string
    ip_address?: string | null
    user_agent?: string | null
    status?: string
    priority?: string
    assigned_to?: bigint | number | null
    responded_at?: Date | string | null
    response?: string | null
    internal_notes?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type contactsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    contact_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    responded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type contactsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    contact_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    assigned_to?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    responded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type donationsCreateInput = {
    id?: bigint | number
    donation_id: string
    donor_name?: string | null
    donor_email?: string | null
    donor_phone?: string | null
    amount: bigint | number
    frequency?: string
    status?: string
    payment_method?: string | null
    payment_channel?: string | null
    transaction_id?: string | null
    paid_at?: Date | string | null
    message?: string | null
    is_anonymous?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    projects: ProjectCreateNestedOneWithoutDonationsInput
    users?: UserCreateNestedOneWithoutDonationsInput
  }

  export type donationsUncheckedCreateInput = {
    id?: bigint | number
    donation_id: string
    project_id: bigint | number
    user_id?: bigint | number | null
    donor_name?: string | null
    donor_email?: string | null
    donor_phone?: string | null
    amount: bigint | number
    frequency?: string
    status?: string
    payment_method?: string | null
    payment_channel?: string | null
    transaction_id?: string | null
    paid_at?: Date | string | null
    message?: string | null
    is_anonymous?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type donationsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    donation_id?: StringFieldUpdateOperationsInput | string
    donor_name?: NullableStringFieldUpdateOperationsInput | string | null
    donor_email?: NullableStringFieldUpdateOperationsInput | string | null
    donor_phone?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    frequency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    payment_channel?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    is_anonymous?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projects?: ProjectUpdateOneRequiredWithoutDonationsNestedInput
    users?: UserUpdateOneWithoutDonationsNestedInput
  }

  export type donationsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    donation_id?: StringFieldUpdateOperationsInput | string
    project_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    donor_name?: NullableStringFieldUpdateOperationsInput | string | null
    donor_email?: NullableStringFieldUpdateOperationsInput | string | null
    donor_phone?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    frequency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    payment_channel?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    is_anonymous?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type donationsCreateManyInput = {
    id?: bigint | number
    donation_id: string
    project_id: bigint | number
    user_id?: bigint | number | null
    donor_name?: string | null
    donor_email?: string | null
    donor_phone?: string | null
    amount: bigint | number
    frequency?: string
    status?: string
    payment_method?: string | null
    payment_channel?: string | null
    transaction_id?: string | null
    paid_at?: Date | string | null
    message?: string | null
    is_anonymous?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type donationsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    donation_id?: StringFieldUpdateOperationsInput | string
    donor_name?: NullableStringFieldUpdateOperationsInput | string | null
    donor_email?: NullableStringFieldUpdateOperationsInput | string | null
    donor_phone?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    frequency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    payment_channel?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    is_anonymous?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type donationsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    donation_id?: StringFieldUpdateOperationsInput | string
    project_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    donor_name?: NullableStringFieldUpdateOperationsInput | string | null
    donor_email?: NullableStringFieldUpdateOperationsInput | string | null
    donor_phone?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    frequency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    payment_channel?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    is_anonymous?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type migrationsCreateInput = {
    migration: string
    batch: number
  }

  export type migrationsUncheckedCreateInput = {
    id?: number
    migration: string
    batch: number
  }

  export type migrationsUpdateInput = {
    migration?: StringFieldUpdateOperationsInput | string
    batch?: IntFieldUpdateOperationsInput | number
  }

  export type migrationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    migration?: StringFieldUpdateOperationsInput | string
    batch?: IntFieldUpdateOperationsInput | number
  }

  export type migrationsCreateManyInput = {
    id?: number
    migration: string
    batch: number
  }

  export type migrationsUpdateManyMutationInput = {
    migration?: StringFieldUpdateOperationsInput | string
    batch?: IntFieldUpdateOperationsInput | number
  }

  export type migrationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    migration?: StringFieldUpdateOperationsInput | string
    batch?: IntFieldUpdateOperationsInput | number
  }

  export type model_has_permissionsCreateInput = {
    model_type: string
    model_id: bigint | number
    permissions: permissionsCreateNestedOneWithoutModel_has_permissionsInput
  }

  export type model_has_permissionsUncheckedCreateInput = {
    permission_id: bigint | number
    model_type: string
    model_id: bigint | number
  }

  export type model_has_permissionsUpdateInput = {
    model_type?: StringFieldUpdateOperationsInput | string
    model_id?: BigIntFieldUpdateOperationsInput | bigint | number
    permissions?: permissionsUpdateOneRequiredWithoutModel_has_permissionsNestedInput
  }

  export type model_has_permissionsUncheckedUpdateInput = {
    permission_id?: BigIntFieldUpdateOperationsInput | bigint | number
    model_type?: StringFieldUpdateOperationsInput | string
    model_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type model_has_permissionsCreateManyInput = {
    permission_id: bigint | number
    model_type: string
    model_id: bigint | number
  }

  export type model_has_permissionsUpdateManyMutationInput = {
    model_type?: StringFieldUpdateOperationsInput | string
    model_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type model_has_permissionsUncheckedUpdateManyInput = {
    permission_id?: BigIntFieldUpdateOperationsInput | bigint | number
    model_type?: StringFieldUpdateOperationsInput | string
    model_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type model_has_rolesCreateInput = {
    model_type: string
    model_id: bigint | number
    roles: rolesCreateNestedOneWithoutModel_has_rolesInput
  }

  export type model_has_rolesUncheckedCreateInput = {
    role_id: bigint | number
    model_type: string
    model_id: bigint | number
  }

  export type model_has_rolesUpdateInput = {
    model_type?: StringFieldUpdateOperationsInput | string
    model_id?: BigIntFieldUpdateOperationsInput | bigint | number
    roles?: rolesUpdateOneRequiredWithoutModel_has_rolesNestedInput
  }

  export type model_has_rolesUncheckedUpdateInput = {
    role_id?: BigIntFieldUpdateOperationsInput | bigint | number
    model_type?: StringFieldUpdateOperationsInput | string
    model_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type model_has_rolesCreateManyInput = {
    role_id: bigint | number
    model_type: string
    model_id: bigint | number
  }

  export type model_has_rolesUpdateManyMutationInput = {
    model_type?: StringFieldUpdateOperationsInput | string
    model_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type model_has_rolesUncheckedUpdateManyInput = {
    role_id?: BigIntFieldUpdateOperationsInput | bigint | number
    model_type?: StringFieldUpdateOperationsInput | string
    model_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type password_reset_tokensCreateInput = {
    email: string
    token: string
    created_at?: Date | string | null
  }

  export type password_reset_tokensUncheckedCreateInput = {
    email: string
    token: string
    created_at?: Date | string | null
  }

  export type password_reset_tokensUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type password_reset_tokensUncheckedUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type password_reset_tokensCreateManyInput = {
    email: string
    token: string
    created_at?: Date | string | null
  }

  export type password_reset_tokensUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type password_reset_tokensUncheckedUpdateManyInput = {
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type permissionsCreateInput = {
    id?: bigint | number
    name: string
    guard_name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    model_has_permissions?: model_has_permissionsCreateNestedManyWithoutPermissionsInput
    role_has_permissions?: role_has_permissionsCreateNestedManyWithoutPermissionsInput
  }

  export type permissionsUncheckedCreateInput = {
    id?: bigint | number
    name: string
    guard_name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    model_has_permissions?: model_has_permissionsUncheckedCreateNestedManyWithoutPermissionsInput
    role_has_permissions?: role_has_permissionsUncheckedCreateNestedManyWithoutPermissionsInput
  }

  export type permissionsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    guard_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    model_has_permissions?: model_has_permissionsUpdateManyWithoutPermissionsNestedInput
    role_has_permissions?: role_has_permissionsUpdateManyWithoutPermissionsNestedInput
  }

  export type permissionsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    guard_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    model_has_permissions?: model_has_permissionsUncheckedUpdateManyWithoutPermissionsNestedInput
    role_has_permissions?: role_has_permissionsUncheckedUpdateManyWithoutPermissionsNestedInput
  }

  export type permissionsCreateManyInput = {
    id?: bigint | number
    name: string
    guard_name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type permissionsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    guard_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type permissionsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    guard_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type personal_access_tokensCreateInput = {
    id?: bigint | number
    tokenable_type: string
    tokenable_id: bigint | number
    name: string
    token: string
    abilities?: string | null
    last_used_at?: Date | string | null
    expires_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type personal_access_tokensUncheckedCreateInput = {
    id?: bigint | number
    tokenable_type: string
    tokenable_id: bigint | number
    name: string
    token: string
    abilities?: string | null
    last_used_at?: Date | string | null
    expires_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type personal_access_tokensUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tokenable_type?: StringFieldUpdateOperationsInput | string
    tokenable_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    abilities?: NullableStringFieldUpdateOperationsInput | string | null
    last_used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type personal_access_tokensUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tokenable_type?: StringFieldUpdateOperationsInput | string
    tokenable_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    abilities?: NullableStringFieldUpdateOperationsInput | string | null
    last_used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type personal_access_tokensCreateManyInput = {
    id?: bigint | number
    tokenable_type: string
    tokenable_id: bigint | number
    name: string
    token: string
    abilities?: string | null
    last_used_at?: Date | string | null
    expires_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type personal_access_tokensUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tokenable_type?: StringFieldUpdateOperationsInput | string
    tokenable_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    abilities?: NullableStringFieldUpdateOperationsInput | string | null
    last_used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type personal_access_tokensUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tokenable_type?: StringFieldUpdateOperationsInput | string
    tokenable_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    abilities?: NullableStringFieldUpdateOperationsInput | string | null
    last_used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type role_has_permissionsCreateInput = {
    permissions: permissionsCreateNestedOneWithoutRole_has_permissionsInput
    roles: rolesCreateNestedOneWithoutRole_has_permissionsInput
  }

  export type role_has_permissionsUncheckedCreateInput = {
    permission_id: bigint | number
    role_id: bigint | number
  }

  export type role_has_permissionsUpdateInput = {
    permissions?: permissionsUpdateOneRequiredWithoutRole_has_permissionsNestedInput
    roles?: rolesUpdateOneRequiredWithoutRole_has_permissionsNestedInput
  }

  export type role_has_permissionsUncheckedUpdateInput = {
    permission_id?: BigIntFieldUpdateOperationsInput | bigint | number
    role_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type role_has_permissionsCreateManyInput = {
    permission_id: bigint | number
    role_id: bigint | number
  }

  export type role_has_permissionsUpdateManyMutationInput = {

  }

  export type role_has_permissionsUncheckedUpdateManyInput = {
    permission_id?: BigIntFieldUpdateOperationsInput | bigint | number
    role_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type rolesCreateInput = {
    id?: bigint | number
    name: string
    guard_name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    model_has_roles?: model_has_rolesCreateNestedManyWithoutRolesInput
    role_has_permissions?: role_has_permissionsCreateNestedManyWithoutRolesInput
  }

  export type rolesUncheckedCreateInput = {
    id?: bigint | number
    name: string
    guard_name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    model_has_roles?: model_has_rolesUncheckedCreateNestedManyWithoutRolesInput
    role_has_permissions?: role_has_permissionsUncheckedCreateNestedManyWithoutRolesInput
  }

  export type rolesUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    guard_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    model_has_roles?: model_has_rolesUpdateManyWithoutRolesNestedInput
    role_has_permissions?: role_has_permissionsUpdateManyWithoutRolesNestedInput
  }

  export type rolesUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    guard_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    model_has_roles?: model_has_rolesUncheckedUpdateManyWithoutRolesNestedInput
    role_has_permissions?: role_has_permissionsUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type rolesCreateManyInput = {
    id?: bigint | number
    name: string
    guard_name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type rolesUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    guard_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type rolesUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    guard_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type socialite_usersCreateInput = {
    id?: bigint | number
    user_id: bigint | number
    provider: string
    provider_id: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type socialite_usersUncheckedCreateInput = {
    id?: bigint | number
    user_id: bigint | number
    provider: string
    provider_id: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type socialite_usersUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    provider?: StringFieldUpdateOperationsInput | string
    provider_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type socialite_usersUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    provider?: StringFieldUpdateOperationsInput | string
    provider_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type socialite_usersCreateManyInput = {
    id?: bigint | number
    user_id: bigint | number
    provider: string
    provider_id: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type socialite_usersUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    provider?: StringFieldUpdateOperationsInput | string
    provider_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type socialite_usersUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    provider?: StringFieldUpdateOperationsInput | string
    provider_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type volunteersCreateInput = {
    id?: bigint | number
    volunteer_id: string
    first_name: string
    last_name: string
    email: string
    phone: string
    interests?: NullableJsonNullValueInput | InputJsonValue
    availability?: NullableJsonNullValueInput | InputJsonValue
    experience?: string | null
    motivation: string
    location?: string | null
    occupation?: string | null
    status?: string
    approved_at?: Date | string | null
    notes?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    projects?: ProjectCreateNestedOneWithoutVolunteersInput
    users?: UserCreateNestedOneWithoutVolunteersInput
  }

  export type volunteersUncheckedCreateInput = {
    id?: bigint | number
    volunteer_id: string
    user_id?: bigint | number | null
    project_id?: bigint | number | null
    first_name: string
    last_name: string
    email: string
    phone: string
    interests?: NullableJsonNullValueInput | InputJsonValue
    availability?: NullableJsonNullValueInput | InputJsonValue
    experience?: string | null
    motivation: string
    location?: string | null
    occupation?: string | null
    status?: string
    approved_at?: Date | string | null
    notes?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type volunteersUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    volunteer_id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    interests?: NullableJsonNullValueInput | InputJsonValue
    availability?: NullableJsonNullValueInput | InputJsonValue
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    motivation?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projects?: ProjectUpdateOneWithoutVolunteersNestedInput
    users?: UserUpdateOneWithoutVolunteersNestedInput
  }

  export type volunteersUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    volunteer_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    project_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    interests?: NullableJsonNullValueInput | InputJsonValue
    availability?: NullableJsonNullValueInput | InputJsonValue
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    motivation?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type volunteersCreateManyInput = {
    id?: bigint | number
    volunteer_id: string
    user_id?: bigint | number | null
    project_id?: bigint | number | null
    first_name: string
    last_name: string
    email: string
    phone: string
    interests?: NullableJsonNullValueInput | InputJsonValue
    availability?: NullableJsonNullValueInput | InputJsonValue
    experience?: string | null
    motivation: string
    location?: string | null
    occupation?: string | null
    status?: string
    approved_at?: Date | string | null
    notes?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type volunteersUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    volunteer_id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    interests?: NullableJsonNullValueInput | InputJsonValue
    availability?: NullableJsonNullValueInput | InputJsonValue
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    motivation?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type volunteersUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    volunteer_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    project_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    interests?: NullableJsonNullValueInput | InputJsonValue
    availability?: NullableJsonNullValueInput | InputJsonValue
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    motivation?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type BlogsListRelationFilter = {
    every?: blogsWhereInput
    some?: blogsWhereInput
    none?: blogsWhereInput
  }

  export type ContactsListRelationFilter = {
    every?: contactsWhereInput
    some?: contactsWhereInput
    none?: contactsWhereInput
  }

  export type DonationsListRelationFilter = {
    every?: donationsWhereInput
    some?: donationsWhereInput
    none?: donationsWhereInput
  }

  export type VolunteersListRelationFilter = {
    every?: volunteersWhereInput
    some?: volunteersWhereInput
    none?: volunteersWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type blogsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type contactsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type donationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type volunteersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    email_verified_at?: SortOrder
    password?: SortOrder
    remember_token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accesses?: SortOrder
    must_change_password?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    email_verified_at?: SortOrder
    password?: SortOrder
    remember_token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    must_change_password?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    email_verified_at?: SortOrder
    password?: SortOrder
    remember_token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    must_change_password?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    payload?: SortOrder
    last_activity?: SortOrder
  }

  export type SessionAvgOrderByAggregateInput = {
    userId?: SortOrder
    last_activity?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    payload?: SortOrder
    last_activity?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    payload?: SortOrder
    last_activity?: SortOrder
  }

  export type SessionSumOrderByAggregateInput = {
    userId?: SortOrder
    last_activity?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    url?: SortOrder
    titleId?: SortOrder
    titleEn?: SortOrder
    descriptionId?: SortOrder
    descriptionEn?: SortOrder
    location?: SortOrder
    goalAmount?: SortOrder
    raisedAmount?: SortOrder
    studentsImpacted?: SortOrder
    image?: SortOrder
    status?: SortOrder
    featured?: SortOrder
    category?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    school?: SortOrder
    donorCount?: SortOrder
    volunteerCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProjectAvgOrderByAggregateInput = {
    id?: SortOrder
    goalAmount?: SortOrder
    raisedAmount?: SortOrder
    studentsImpacted?: SortOrder
    donorCount?: SortOrder
    volunteerCount?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    url?: SortOrder
    titleId?: SortOrder
    titleEn?: SortOrder
    descriptionId?: SortOrder
    descriptionEn?: SortOrder
    location?: SortOrder
    goalAmount?: SortOrder
    raisedAmount?: SortOrder
    studentsImpacted?: SortOrder
    image?: SortOrder
    status?: SortOrder
    featured?: SortOrder
    category?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    donorCount?: SortOrder
    volunteerCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    url?: SortOrder
    titleId?: SortOrder
    titleEn?: SortOrder
    descriptionId?: SortOrder
    descriptionEn?: SortOrder
    location?: SortOrder
    goalAmount?: SortOrder
    raisedAmount?: SortOrder
    studentsImpacted?: SortOrder
    image?: SortOrder
    status?: SortOrder
    featured?: SortOrder
    category?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    donorCount?: SortOrder
    volunteerCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProjectSumOrderByAggregateInput = {
    id?: SortOrder
    goalAmount?: SortOrder
    raisedAmount?: SortOrder
    studentsImpacted?: SortOrder
    donorCount?: SortOrder
    volunteerCount?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type blogsCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    user_id?: SortOrder
    title_id?: SortOrder
    excerpt_id?: SortOrder
    content_id?: SortOrder
    title_en?: SortOrder
    excerpt_en?: SortOrder
    content_en?: SortOrder
    author_name?: SortOrder
    author_role?: SortOrder
    author_avatar?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    image?: SortOrder
    image_alt?: SortOrder
    meta_title_id?: SortOrder
    meta_description_id?: SortOrder
    meta_title_en?: SortOrder
    meta_description_en?: SortOrder
    read_time?: SortOrder
    views_count?: SortOrder
    status?: SortOrder
    featured?: SortOrder
    published_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type blogsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    read_time?: SortOrder
    views_count?: SortOrder
  }

  export type blogsMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    user_id?: SortOrder
    title_id?: SortOrder
    excerpt_id?: SortOrder
    content_id?: SortOrder
    title_en?: SortOrder
    excerpt_en?: SortOrder
    content_en?: SortOrder
    author_name?: SortOrder
    author_role?: SortOrder
    author_avatar?: SortOrder
    category?: SortOrder
    image?: SortOrder
    image_alt?: SortOrder
    meta_title_id?: SortOrder
    meta_description_id?: SortOrder
    meta_title_en?: SortOrder
    meta_description_en?: SortOrder
    read_time?: SortOrder
    views_count?: SortOrder
    status?: SortOrder
    featured?: SortOrder
    published_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type blogsMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    user_id?: SortOrder
    title_id?: SortOrder
    excerpt_id?: SortOrder
    content_id?: SortOrder
    title_en?: SortOrder
    excerpt_en?: SortOrder
    content_en?: SortOrder
    author_name?: SortOrder
    author_role?: SortOrder
    author_avatar?: SortOrder
    category?: SortOrder
    image?: SortOrder
    image_alt?: SortOrder
    meta_title_id?: SortOrder
    meta_description_id?: SortOrder
    meta_title_en?: SortOrder
    meta_description_en?: SortOrder
    read_time?: SortOrder
    views_count?: SortOrder
    status?: SortOrder
    featured?: SortOrder
    published_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type blogsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    read_time?: SortOrder
    views_count?: SortOrder
  }

  export type cacheCountOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    expiration?: SortOrder
  }

  export type cacheAvgOrderByAggregateInput = {
    expiration?: SortOrder
  }

  export type cacheMaxOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    expiration?: SortOrder
  }

  export type cacheMinOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    expiration?: SortOrder
  }

  export type cacheSumOrderByAggregateInput = {
    expiration?: SortOrder
  }

  export type cache_locksCountOrderByAggregateInput = {
    key?: SortOrder
    owner?: SortOrder
    expiration?: SortOrder
  }

  export type cache_locksAvgOrderByAggregateInput = {
    expiration?: SortOrder
  }

  export type cache_locksMaxOrderByAggregateInput = {
    key?: SortOrder
    owner?: SortOrder
    expiration?: SortOrder
  }

  export type cache_locksMinOrderByAggregateInput = {
    key?: SortOrder
    owner?: SortOrder
    expiration?: SortOrder
  }

  export type cache_locksSumOrderByAggregateInput = {
    expiration?: SortOrder
  }

  export type contactsCountOrderByAggregateInput = {
    id?: SortOrder
    contact_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    assigned_to?: SortOrder
    responded_at?: SortOrder
    response?: SortOrder
    internal_notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type contactsAvgOrderByAggregateInput = {
    id?: SortOrder
    assigned_to?: SortOrder
  }

  export type contactsMaxOrderByAggregateInput = {
    id?: SortOrder
    contact_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    assigned_to?: SortOrder
    responded_at?: SortOrder
    response?: SortOrder
    internal_notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type contactsMinOrderByAggregateInput = {
    id?: SortOrder
    contact_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    assigned_to?: SortOrder
    responded_at?: SortOrder
    response?: SortOrder
    internal_notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type contactsSumOrderByAggregateInput = {
    id?: SortOrder
    assigned_to?: SortOrder
  }

  export type ProjectScalarRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type donationsCountOrderByAggregateInput = {
    id?: SortOrder
    donation_id?: SortOrder
    project_id?: SortOrder
    user_id?: SortOrder
    donor_name?: SortOrder
    donor_email?: SortOrder
    donor_phone?: SortOrder
    amount?: SortOrder
    frequency?: SortOrder
    status?: SortOrder
    payment_method?: SortOrder
    payment_channel?: SortOrder
    transaction_id?: SortOrder
    paid_at?: SortOrder
    message?: SortOrder
    is_anonymous?: SortOrder
    metadata?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type donationsAvgOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
  }

  export type donationsMaxOrderByAggregateInput = {
    id?: SortOrder
    donation_id?: SortOrder
    project_id?: SortOrder
    user_id?: SortOrder
    donor_name?: SortOrder
    donor_email?: SortOrder
    donor_phone?: SortOrder
    amount?: SortOrder
    frequency?: SortOrder
    status?: SortOrder
    payment_method?: SortOrder
    payment_channel?: SortOrder
    transaction_id?: SortOrder
    paid_at?: SortOrder
    message?: SortOrder
    is_anonymous?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type donationsMinOrderByAggregateInput = {
    id?: SortOrder
    donation_id?: SortOrder
    project_id?: SortOrder
    user_id?: SortOrder
    donor_name?: SortOrder
    donor_email?: SortOrder
    donor_phone?: SortOrder
    amount?: SortOrder
    frequency?: SortOrder
    status?: SortOrder
    payment_method?: SortOrder
    payment_channel?: SortOrder
    transaction_id?: SortOrder
    paid_at?: SortOrder
    message?: SortOrder
    is_anonymous?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type donationsSumOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
  }

  export type migrationsCountOrderByAggregateInput = {
    id?: SortOrder
    migration?: SortOrder
    batch?: SortOrder
  }

  export type migrationsAvgOrderByAggregateInput = {
    id?: SortOrder
    batch?: SortOrder
  }

  export type migrationsMaxOrderByAggregateInput = {
    id?: SortOrder
    migration?: SortOrder
    batch?: SortOrder
  }

  export type migrationsMinOrderByAggregateInput = {
    id?: SortOrder
    migration?: SortOrder
    batch?: SortOrder
  }

  export type migrationsSumOrderByAggregateInput = {
    id?: SortOrder
    batch?: SortOrder
  }

  export type PermissionsScalarRelationFilter = {
    is?: permissionsWhereInput
    isNot?: permissionsWhereInput
  }

  export type model_has_permissionsPermission_idModel_idModel_typeCompoundUniqueInput = {
    permission_id: bigint | number
    model_id: bigint | number
    model_type: string
  }

  export type model_has_permissionsCountOrderByAggregateInput = {
    permission_id?: SortOrder
    model_type?: SortOrder
    model_id?: SortOrder
  }

  export type model_has_permissionsAvgOrderByAggregateInput = {
    permission_id?: SortOrder
    model_id?: SortOrder
  }

  export type model_has_permissionsMaxOrderByAggregateInput = {
    permission_id?: SortOrder
    model_type?: SortOrder
    model_id?: SortOrder
  }

  export type model_has_permissionsMinOrderByAggregateInput = {
    permission_id?: SortOrder
    model_type?: SortOrder
    model_id?: SortOrder
  }

  export type model_has_permissionsSumOrderByAggregateInput = {
    permission_id?: SortOrder
    model_id?: SortOrder
  }

  export type RolesScalarRelationFilter = {
    is?: rolesWhereInput
    isNot?: rolesWhereInput
  }

  export type model_has_rolesRole_idModel_idModel_typeCompoundUniqueInput = {
    role_id: bigint | number
    model_id: bigint | number
    model_type: string
  }

  export type model_has_rolesCountOrderByAggregateInput = {
    role_id?: SortOrder
    model_type?: SortOrder
    model_id?: SortOrder
  }

  export type model_has_rolesAvgOrderByAggregateInput = {
    role_id?: SortOrder
    model_id?: SortOrder
  }

  export type model_has_rolesMaxOrderByAggregateInput = {
    role_id?: SortOrder
    model_type?: SortOrder
    model_id?: SortOrder
  }

  export type model_has_rolesMinOrderByAggregateInput = {
    role_id?: SortOrder
    model_type?: SortOrder
    model_id?: SortOrder
  }

  export type model_has_rolesSumOrderByAggregateInput = {
    role_id?: SortOrder
    model_id?: SortOrder
  }

  export type password_reset_tokensCountOrderByAggregateInput = {
    email?: SortOrder
    token?: SortOrder
    created_at?: SortOrder
  }

  export type password_reset_tokensMaxOrderByAggregateInput = {
    email?: SortOrder
    token?: SortOrder
    created_at?: SortOrder
  }

  export type password_reset_tokensMinOrderByAggregateInput = {
    email?: SortOrder
    token?: SortOrder
    created_at?: SortOrder
  }

  export type Model_has_permissionsListRelationFilter = {
    every?: model_has_permissionsWhereInput
    some?: model_has_permissionsWhereInput
    none?: model_has_permissionsWhereInput
  }

  export type Role_has_permissionsListRelationFilter = {
    every?: role_has_permissionsWhereInput
    some?: role_has_permissionsWhereInput
    none?: role_has_permissionsWhereInput
  }

  export type model_has_permissionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type role_has_permissionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type permissionsNameGuard_nameCompoundUniqueInput = {
    name: string
    guard_name: string
  }

  export type permissionsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    guard_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type permissionsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type permissionsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    guard_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type permissionsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    guard_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type permissionsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type personal_access_tokensCountOrderByAggregateInput = {
    id?: SortOrder
    tokenable_type?: SortOrder
    tokenable_id?: SortOrder
    name?: SortOrder
    token?: SortOrder
    abilities?: SortOrder
    last_used_at?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type personal_access_tokensAvgOrderByAggregateInput = {
    id?: SortOrder
    tokenable_id?: SortOrder
  }

  export type personal_access_tokensMaxOrderByAggregateInput = {
    id?: SortOrder
    tokenable_type?: SortOrder
    tokenable_id?: SortOrder
    name?: SortOrder
    token?: SortOrder
    abilities?: SortOrder
    last_used_at?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type personal_access_tokensMinOrderByAggregateInput = {
    id?: SortOrder
    tokenable_type?: SortOrder
    tokenable_id?: SortOrder
    name?: SortOrder
    token?: SortOrder
    abilities?: SortOrder
    last_used_at?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type personal_access_tokensSumOrderByAggregateInput = {
    id?: SortOrder
    tokenable_id?: SortOrder
  }

  export type role_has_permissionsPermission_idRole_idCompoundUniqueInput = {
    permission_id: bigint | number
    role_id: bigint | number
  }

  export type role_has_permissionsCountOrderByAggregateInput = {
    permission_id?: SortOrder
    role_id?: SortOrder
  }

  export type role_has_permissionsAvgOrderByAggregateInput = {
    permission_id?: SortOrder
    role_id?: SortOrder
  }

  export type role_has_permissionsMaxOrderByAggregateInput = {
    permission_id?: SortOrder
    role_id?: SortOrder
  }

  export type role_has_permissionsMinOrderByAggregateInput = {
    permission_id?: SortOrder
    role_id?: SortOrder
  }

  export type role_has_permissionsSumOrderByAggregateInput = {
    permission_id?: SortOrder
    role_id?: SortOrder
  }

  export type Model_has_rolesListRelationFilter = {
    every?: model_has_rolesWhereInput
    some?: model_has_rolesWhereInput
    none?: model_has_rolesWhereInput
  }

  export type model_has_rolesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type rolesNameGuard_nameCompoundUniqueInput = {
    name: string
    guard_name: string
  }

  export type rolesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    guard_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type rolesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type rolesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    guard_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type rolesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    guard_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type rolesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type socialite_usersProviderProvider_idCompoundUniqueInput = {
    provider: string
    provider_id: string
  }

  export type socialite_usersCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    provider?: SortOrder
    provider_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type socialite_usersAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type socialite_usersMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    provider?: SortOrder
    provider_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type socialite_usersMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    provider?: SortOrder
    provider_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type socialite_usersSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type ProjectNullableScalarRelationFilter = {
    is?: ProjectWhereInput | null
    isNot?: ProjectWhereInput | null
  }

  export type volunteersCountOrderByAggregateInput = {
    id?: SortOrder
    volunteer_id?: SortOrder
    user_id?: SortOrder
    project_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    interests?: SortOrder
    availability?: SortOrder
    experience?: SortOrder
    motivation?: SortOrder
    location?: SortOrder
    occupation?: SortOrder
    status?: SortOrder
    approved_at?: SortOrder
    notes?: SortOrder
    skills?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type volunteersAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    project_id?: SortOrder
  }

  export type volunteersMaxOrderByAggregateInput = {
    id?: SortOrder
    volunteer_id?: SortOrder
    user_id?: SortOrder
    project_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    experience?: SortOrder
    motivation?: SortOrder
    location?: SortOrder
    occupation?: SortOrder
    status?: SortOrder
    approved_at?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type volunteersMinOrderByAggregateInput = {
    id?: SortOrder
    volunteer_id?: SortOrder
    user_id?: SortOrder
    project_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    experience?: SortOrder
    motivation?: SortOrder
    location?: SortOrder
    occupation?: SortOrder
    status?: SortOrder
    approved_at?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type volunteersSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    project_id?: SortOrder
  }

  export type blogsCreateNestedManyWithoutUsersInput = {
    create?: XOR<blogsCreateWithoutUsersInput, blogsUncheckedCreateWithoutUsersInput> | blogsCreateWithoutUsersInput[] | blogsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: blogsCreateOrConnectWithoutUsersInput | blogsCreateOrConnectWithoutUsersInput[]
    createMany?: blogsCreateManyUsersInputEnvelope
    connect?: blogsWhereUniqueInput | blogsWhereUniqueInput[]
  }

  export type contactsCreateNestedManyWithoutUsersInput = {
    create?: XOR<contactsCreateWithoutUsersInput, contactsUncheckedCreateWithoutUsersInput> | contactsCreateWithoutUsersInput[] | contactsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: contactsCreateOrConnectWithoutUsersInput | contactsCreateOrConnectWithoutUsersInput[]
    createMany?: contactsCreateManyUsersInputEnvelope
    connect?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
  }

  export type donationsCreateNestedManyWithoutUsersInput = {
    create?: XOR<donationsCreateWithoutUsersInput, donationsUncheckedCreateWithoutUsersInput> | donationsCreateWithoutUsersInput[] | donationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: donationsCreateOrConnectWithoutUsersInput | donationsCreateOrConnectWithoutUsersInput[]
    createMany?: donationsCreateManyUsersInputEnvelope
    connect?: donationsWhereUniqueInput | donationsWhereUniqueInput[]
  }

  export type volunteersCreateNestedManyWithoutUsersInput = {
    create?: XOR<volunteersCreateWithoutUsersInput, volunteersUncheckedCreateWithoutUsersInput> | volunteersCreateWithoutUsersInput[] | volunteersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: volunteersCreateOrConnectWithoutUsersInput | volunteersCreateOrConnectWithoutUsersInput[]
    createMany?: volunteersCreateManyUsersInputEnvelope
    connect?: volunteersWhereUniqueInput | volunteersWhereUniqueInput[]
  }

  export type blogsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<blogsCreateWithoutUsersInput, blogsUncheckedCreateWithoutUsersInput> | blogsCreateWithoutUsersInput[] | blogsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: blogsCreateOrConnectWithoutUsersInput | blogsCreateOrConnectWithoutUsersInput[]
    createMany?: blogsCreateManyUsersInputEnvelope
    connect?: blogsWhereUniqueInput | blogsWhereUniqueInput[]
  }

  export type contactsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<contactsCreateWithoutUsersInput, contactsUncheckedCreateWithoutUsersInput> | contactsCreateWithoutUsersInput[] | contactsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: contactsCreateOrConnectWithoutUsersInput | contactsCreateOrConnectWithoutUsersInput[]
    createMany?: contactsCreateManyUsersInputEnvelope
    connect?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
  }

  export type donationsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<donationsCreateWithoutUsersInput, donationsUncheckedCreateWithoutUsersInput> | donationsCreateWithoutUsersInput[] | donationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: donationsCreateOrConnectWithoutUsersInput | donationsCreateOrConnectWithoutUsersInput[]
    createMany?: donationsCreateManyUsersInputEnvelope
    connect?: donationsWhereUniqueInput | donationsWhereUniqueInput[]
  }

  export type volunteersUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<volunteersCreateWithoutUsersInput, volunteersUncheckedCreateWithoutUsersInput> | volunteersCreateWithoutUsersInput[] | volunteersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: volunteersCreateOrConnectWithoutUsersInput | volunteersCreateOrConnectWithoutUsersInput[]
    createMany?: volunteersCreateManyUsersInputEnvelope
    connect?: volunteersWhereUniqueInput | volunteersWhereUniqueInput[]
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type blogsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<blogsCreateWithoutUsersInput, blogsUncheckedCreateWithoutUsersInput> | blogsCreateWithoutUsersInput[] | blogsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: blogsCreateOrConnectWithoutUsersInput | blogsCreateOrConnectWithoutUsersInput[]
    upsert?: blogsUpsertWithWhereUniqueWithoutUsersInput | blogsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: blogsCreateManyUsersInputEnvelope
    set?: blogsWhereUniqueInput | blogsWhereUniqueInput[]
    disconnect?: blogsWhereUniqueInput | blogsWhereUniqueInput[]
    delete?: blogsWhereUniqueInput | blogsWhereUniqueInput[]
    connect?: blogsWhereUniqueInput | blogsWhereUniqueInput[]
    update?: blogsUpdateWithWhereUniqueWithoutUsersInput | blogsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: blogsUpdateManyWithWhereWithoutUsersInput | blogsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: blogsScalarWhereInput | blogsScalarWhereInput[]
  }

  export type contactsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<contactsCreateWithoutUsersInput, contactsUncheckedCreateWithoutUsersInput> | contactsCreateWithoutUsersInput[] | contactsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: contactsCreateOrConnectWithoutUsersInput | contactsCreateOrConnectWithoutUsersInput[]
    upsert?: contactsUpsertWithWhereUniqueWithoutUsersInput | contactsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: contactsCreateManyUsersInputEnvelope
    set?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    disconnect?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    delete?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    connect?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    update?: contactsUpdateWithWhereUniqueWithoutUsersInput | contactsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: contactsUpdateManyWithWhereWithoutUsersInput | contactsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: contactsScalarWhereInput | contactsScalarWhereInput[]
  }

  export type donationsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<donationsCreateWithoutUsersInput, donationsUncheckedCreateWithoutUsersInput> | donationsCreateWithoutUsersInput[] | donationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: donationsCreateOrConnectWithoutUsersInput | donationsCreateOrConnectWithoutUsersInput[]
    upsert?: donationsUpsertWithWhereUniqueWithoutUsersInput | donationsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: donationsCreateManyUsersInputEnvelope
    set?: donationsWhereUniqueInput | donationsWhereUniqueInput[]
    disconnect?: donationsWhereUniqueInput | donationsWhereUniqueInput[]
    delete?: donationsWhereUniqueInput | donationsWhereUniqueInput[]
    connect?: donationsWhereUniqueInput | donationsWhereUniqueInput[]
    update?: donationsUpdateWithWhereUniqueWithoutUsersInput | donationsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: donationsUpdateManyWithWhereWithoutUsersInput | donationsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: donationsScalarWhereInput | donationsScalarWhereInput[]
  }

  export type volunteersUpdateManyWithoutUsersNestedInput = {
    create?: XOR<volunteersCreateWithoutUsersInput, volunteersUncheckedCreateWithoutUsersInput> | volunteersCreateWithoutUsersInput[] | volunteersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: volunteersCreateOrConnectWithoutUsersInput | volunteersCreateOrConnectWithoutUsersInput[]
    upsert?: volunteersUpsertWithWhereUniqueWithoutUsersInput | volunteersUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: volunteersCreateManyUsersInputEnvelope
    set?: volunteersWhereUniqueInput | volunteersWhereUniqueInput[]
    disconnect?: volunteersWhereUniqueInput | volunteersWhereUniqueInput[]
    delete?: volunteersWhereUniqueInput | volunteersWhereUniqueInput[]
    connect?: volunteersWhereUniqueInput | volunteersWhereUniqueInput[]
    update?: volunteersUpdateWithWhereUniqueWithoutUsersInput | volunteersUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: volunteersUpdateManyWithWhereWithoutUsersInput | volunteersUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: volunteersScalarWhereInput | volunteersScalarWhereInput[]
  }

  export type blogsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<blogsCreateWithoutUsersInput, blogsUncheckedCreateWithoutUsersInput> | blogsCreateWithoutUsersInput[] | blogsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: blogsCreateOrConnectWithoutUsersInput | blogsCreateOrConnectWithoutUsersInput[]
    upsert?: blogsUpsertWithWhereUniqueWithoutUsersInput | blogsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: blogsCreateManyUsersInputEnvelope
    set?: blogsWhereUniqueInput | blogsWhereUniqueInput[]
    disconnect?: blogsWhereUniqueInput | blogsWhereUniqueInput[]
    delete?: blogsWhereUniqueInput | blogsWhereUniqueInput[]
    connect?: blogsWhereUniqueInput | blogsWhereUniqueInput[]
    update?: blogsUpdateWithWhereUniqueWithoutUsersInput | blogsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: blogsUpdateManyWithWhereWithoutUsersInput | blogsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: blogsScalarWhereInput | blogsScalarWhereInput[]
  }

  export type contactsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<contactsCreateWithoutUsersInput, contactsUncheckedCreateWithoutUsersInput> | contactsCreateWithoutUsersInput[] | contactsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: contactsCreateOrConnectWithoutUsersInput | contactsCreateOrConnectWithoutUsersInput[]
    upsert?: contactsUpsertWithWhereUniqueWithoutUsersInput | contactsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: contactsCreateManyUsersInputEnvelope
    set?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    disconnect?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    delete?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    connect?: contactsWhereUniqueInput | contactsWhereUniqueInput[]
    update?: contactsUpdateWithWhereUniqueWithoutUsersInput | contactsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: contactsUpdateManyWithWhereWithoutUsersInput | contactsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: contactsScalarWhereInput | contactsScalarWhereInput[]
  }

  export type donationsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<donationsCreateWithoutUsersInput, donationsUncheckedCreateWithoutUsersInput> | donationsCreateWithoutUsersInput[] | donationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: donationsCreateOrConnectWithoutUsersInput | donationsCreateOrConnectWithoutUsersInput[]
    upsert?: donationsUpsertWithWhereUniqueWithoutUsersInput | donationsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: donationsCreateManyUsersInputEnvelope
    set?: donationsWhereUniqueInput | donationsWhereUniqueInput[]
    disconnect?: donationsWhereUniqueInput | donationsWhereUniqueInput[]
    delete?: donationsWhereUniqueInput | donationsWhereUniqueInput[]
    connect?: donationsWhereUniqueInput | donationsWhereUniqueInput[]
    update?: donationsUpdateWithWhereUniqueWithoutUsersInput | donationsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: donationsUpdateManyWithWhereWithoutUsersInput | donationsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: donationsScalarWhereInput | donationsScalarWhereInput[]
  }

  export type volunteersUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<volunteersCreateWithoutUsersInput, volunteersUncheckedCreateWithoutUsersInput> | volunteersCreateWithoutUsersInput[] | volunteersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: volunteersCreateOrConnectWithoutUsersInput | volunteersCreateOrConnectWithoutUsersInput[]
    upsert?: volunteersUpsertWithWhereUniqueWithoutUsersInput | volunteersUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: volunteersCreateManyUsersInputEnvelope
    set?: volunteersWhereUniqueInput | volunteersWhereUniqueInput[]
    disconnect?: volunteersWhereUniqueInput | volunteersWhereUniqueInput[]
    delete?: volunteersWhereUniqueInput | volunteersWhereUniqueInput[]
    connect?: volunteersWhereUniqueInput | volunteersWhereUniqueInput[]
    update?: volunteersUpdateWithWhereUniqueWithoutUsersInput | volunteersUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: volunteersUpdateManyWithWhereWithoutUsersInput | volunteersUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: volunteersScalarWhereInput | volunteersScalarWhereInput[]
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type donationsCreateNestedManyWithoutProjectsInput = {
    create?: XOR<donationsCreateWithoutProjectsInput, donationsUncheckedCreateWithoutProjectsInput> | donationsCreateWithoutProjectsInput[] | donationsUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: donationsCreateOrConnectWithoutProjectsInput | donationsCreateOrConnectWithoutProjectsInput[]
    createMany?: donationsCreateManyProjectsInputEnvelope
    connect?: donationsWhereUniqueInput | donationsWhereUniqueInput[]
  }

  export type volunteersCreateNestedManyWithoutProjectsInput = {
    create?: XOR<volunteersCreateWithoutProjectsInput, volunteersUncheckedCreateWithoutProjectsInput> | volunteersCreateWithoutProjectsInput[] | volunteersUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: volunteersCreateOrConnectWithoutProjectsInput | volunteersCreateOrConnectWithoutProjectsInput[]
    createMany?: volunteersCreateManyProjectsInputEnvelope
    connect?: volunteersWhereUniqueInput | volunteersWhereUniqueInput[]
  }

  export type donationsUncheckedCreateNestedManyWithoutProjectsInput = {
    create?: XOR<donationsCreateWithoutProjectsInput, donationsUncheckedCreateWithoutProjectsInput> | donationsCreateWithoutProjectsInput[] | donationsUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: donationsCreateOrConnectWithoutProjectsInput | donationsCreateOrConnectWithoutProjectsInput[]
    createMany?: donationsCreateManyProjectsInputEnvelope
    connect?: donationsWhereUniqueInput | donationsWhereUniqueInput[]
  }

  export type volunteersUncheckedCreateNestedManyWithoutProjectsInput = {
    create?: XOR<volunteersCreateWithoutProjectsInput, volunteersUncheckedCreateWithoutProjectsInput> | volunteersCreateWithoutProjectsInput[] | volunteersUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: volunteersCreateOrConnectWithoutProjectsInput | volunteersCreateOrConnectWithoutProjectsInput[]
    createMany?: volunteersCreateManyProjectsInputEnvelope
    connect?: volunteersWhereUniqueInput | volunteersWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type donationsUpdateManyWithoutProjectsNestedInput = {
    create?: XOR<donationsCreateWithoutProjectsInput, donationsUncheckedCreateWithoutProjectsInput> | donationsCreateWithoutProjectsInput[] | donationsUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: donationsCreateOrConnectWithoutProjectsInput | donationsCreateOrConnectWithoutProjectsInput[]
    upsert?: donationsUpsertWithWhereUniqueWithoutProjectsInput | donationsUpsertWithWhereUniqueWithoutProjectsInput[]
    createMany?: donationsCreateManyProjectsInputEnvelope
    set?: donationsWhereUniqueInput | donationsWhereUniqueInput[]
    disconnect?: donationsWhereUniqueInput | donationsWhereUniqueInput[]
    delete?: donationsWhereUniqueInput | donationsWhereUniqueInput[]
    connect?: donationsWhereUniqueInput | donationsWhereUniqueInput[]
    update?: donationsUpdateWithWhereUniqueWithoutProjectsInput | donationsUpdateWithWhereUniqueWithoutProjectsInput[]
    updateMany?: donationsUpdateManyWithWhereWithoutProjectsInput | donationsUpdateManyWithWhereWithoutProjectsInput[]
    deleteMany?: donationsScalarWhereInput | donationsScalarWhereInput[]
  }

  export type volunteersUpdateManyWithoutProjectsNestedInput = {
    create?: XOR<volunteersCreateWithoutProjectsInput, volunteersUncheckedCreateWithoutProjectsInput> | volunteersCreateWithoutProjectsInput[] | volunteersUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: volunteersCreateOrConnectWithoutProjectsInput | volunteersCreateOrConnectWithoutProjectsInput[]
    upsert?: volunteersUpsertWithWhereUniqueWithoutProjectsInput | volunteersUpsertWithWhereUniqueWithoutProjectsInput[]
    createMany?: volunteersCreateManyProjectsInputEnvelope
    set?: volunteersWhereUniqueInput | volunteersWhereUniqueInput[]
    disconnect?: volunteersWhereUniqueInput | volunteersWhereUniqueInput[]
    delete?: volunteersWhereUniqueInput | volunteersWhereUniqueInput[]
    connect?: volunteersWhereUniqueInput | volunteersWhereUniqueInput[]
    update?: volunteersUpdateWithWhereUniqueWithoutProjectsInput | volunteersUpdateWithWhereUniqueWithoutProjectsInput[]
    updateMany?: volunteersUpdateManyWithWhereWithoutProjectsInput | volunteersUpdateManyWithWhereWithoutProjectsInput[]
    deleteMany?: volunteersScalarWhereInput | volunteersScalarWhereInput[]
  }

  export type donationsUncheckedUpdateManyWithoutProjectsNestedInput = {
    create?: XOR<donationsCreateWithoutProjectsInput, donationsUncheckedCreateWithoutProjectsInput> | donationsCreateWithoutProjectsInput[] | donationsUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: donationsCreateOrConnectWithoutProjectsInput | donationsCreateOrConnectWithoutProjectsInput[]
    upsert?: donationsUpsertWithWhereUniqueWithoutProjectsInput | donationsUpsertWithWhereUniqueWithoutProjectsInput[]
    createMany?: donationsCreateManyProjectsInputEnvelope
    set?: donationsWhereUniqueInput | donationsWhereUniqueInput[]
    disconnect?: donationsWhereUniqueInput | donationsWhereUniqueInput[]
    delete?: donationsWhereUniqueInput | donationsWhereUniqueInput[]
    connect?: donationsWhereUniqueInput | donationsWhereUniqueInput[]
    update?: donationsUpdateWithWhereUniqueWithoutProjectsInput | donationsUpdateWithWhereUniqueWithoutProjectsInput[]
    updateMany?: donationsUpdateManyWithWhereWithoutProjectsInput | donationsUpdateManyWithWhereWithoutProjectsInput[]
    deleteMany?: donationsScalarWhereInput | donationsScalarWhereInput[]
  }

  export type volunteersUncheckedUpdateManyWithoutProjectsNestedInput = {
    create?: XOR<volunteersCreateWithoutProjectsInput, volunteersUncheckedCreateWithoutProjectsInput> | volunteersCreateWithoutProjectsInput[] | volunteersUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: volunteersCreateOrConnectWithoutProjectsInput | volunteersCreateOrConnectWithoutProjectsInput[]
    upsert?: volunteersUpsertWithWhereUniqueWithoutProjectsInput | volunteersUpsertWithWhereUniqueWithoutProjectsInput[]
    createMany?: volunteersCreateManyProjectsInputEnvelope
    set?: volunteersWhereUniqueInput | volunteersWhereUniqueInput[]
    disconnect?: volunteersWhereUniqueInput | volunteersWhereUniqueInput[]
    delete?: volunteersWhereUniqueInput | volunteersWhereUniqueInput[]
    connect?: volunteersWhereUniqueInput | volunteersWhereUniqueInput[]
    update?: volunteersUpdateWithWhereUniqueWithoutProjectsInput | volunteersUpdateWithWhereUniqueWithoutProjectsInput[]
    updateMany?: volunteersUpdateManyWithWhereWithoutProjectsInput | volunteersUpdateManyWithWhereWithoutProjectsInput[]
    deleteMany?: volunteersScalarWhereInput | volunteersScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBlogsInput = {
    create?: XOR<UserCreateWithoutBlogsInput, UserUncheckedCreateWithoutBlogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutBlogsNestedInput = {
    create?: XOR<UserCreateWithoutBlogsInput, UserUncheckedCreateWithoutBlogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogsInput
    upsert?: UserUpsertWithoutBlogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBlogsInput, UserUpdateWithoutBlogsInput>, UserUncheckedUpdateWithoutBlogsInput>
  }

  export type UserCreateNestedOneWithoutContactsInput = {
    create?: XOR<UserCreateWithoutContactsInput, UserUncheckedCreateWithoutContactsInput>
    connectOrCreate?: UserCreateOrConnectWithoutContactsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutContactsNestedInput = {
    create?: XOR<UserCreateWithoutContactsInput, UserUncheckedCreateWithoutContactsInput>
    connectOrCreate?: UserCreateOrConnectWithoutContactsInput
    upsert?: UserUpsertWithoutContactsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutContactsInput, UserUpdateWithoutContactsInput>, UserUncheckedUpdateWithoutContactsInput>
  }

  export type ProjectCreateNestedOneWithoutDonationsInput = {
    create?: XOR<ProjectCreateWithoutDonationsInput, ProjectUncheckedCreateWithoutDonationsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDonationsInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDonationsInput = {
    create?: XOR<UserCreateWithoutDonationsInput, UserUncheckedCreateWithoutDonationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDonationsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutDonationsNestedInput = {
    create?: XOR<ProjectCreateWithoutDonationsInput, ProjectUncheckedCreateWithoutDonationsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDonationsInput
    upsert?: ProjectUpsertWithoutDonationsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutDonationsInput, ProjectUpdateWithoutDonationsInput>, ProjectUncheckedUpdateWithoutDonationsInput>
  }

  export type UserUpdateOneWithoutDonationsNestedInput = {
    create?: XOR<UserCreateWithoutDonationsInput, UserUncheckedCreateWithoutDonationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDonationsInput
    upsert?: UserUpsertWithoutDonationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDonationsInput, UserUpdateWithoutDonationsInput>, UserUncheckedUpdateWithoutDonationsInput>
  }

  export type permissionsCreateNestedOneWithoutModel_has_permissionsInput = {
    create?: XOR<permissionsCreateWithoutModel_has_permissionsInput, permissionsUncheckedCreateWithoutModel_has_permissionsInput>
    connectOrCreate?: permissionsCreateOrConnectWithoutModel_has_permissionsInput
    connect?: permissionsWhereUniqueInput
  }

  export type permissionsUpdateOneRequiredWithoutModel_has_permissionsNestedInput = {
    create?: XOR<permissionsCreateWithoutModel_has_permissionsInput, permissionsUncheckedCreateWithoutModel_has_permissionsInput>
    connectOrCreate?: permissionsCreateOrConnectWithoutModel_has_permissionsInput
    upsert?: permissionsUpsertWithoutModel_has_permissionsInput
    connect?: permissionsWhereUniqueInput
    update?: XOR<XOR<permissionsUpdateToOneWithWhereWithoutModel_has_permissionsInput, permissionsUpdateWithoutModel_has_permissionsInput>, permissionsUncheckedUpdateWithoutModel_has_permissionsInput>
  }

  export type rolesCreateNestedOneWithoutModel_has_rolesInput = {
    create?: XOR<rolesCreateWithoutModel_has_rolesInput, rolesUncheckedCreateWithoutModel_has_rolesInput>
    connectOrCreate?: rolesCreateOrConnectWithoutModel_has_rolesInput
    connect?: rolesWhereUniqueInput
  }

  export type rolesUpdateOneRequiredWithoutModel_has_rolesNestedInput = {
    create?: XOR<rolesCreateWithoutModel_has_rolesInput, rolesUncheckedCreateWithoutModel_has_rolesInput>
    connectOrCreate?: rolesCreateOrConnectWithoutModel_has_rolesInput
    upsert?: rolesUpsertWithoutModel_has_rolesInput
    connect?: rolesWhereUniqueInput
    update?: XOR<XOR<rolesUpdateToOneWithWhereWithoutModel_has_rolesInput, rolesUpdateWithoutModel_has_rolesInput>, rolesUncheckedUpdateWithoutModel_has_rolesInput>
  }

  export type model_has_permissionsCreateNestedManyWithoutPermissionsInput = {
    create?: XOR<model_has_permissionsCreateWithoutPermissionsInput, model_has_permissionsUncheckedCreateWithoutPermissionsInput> | model_has_permissionsCreateWithoutPermissionsInput[] | model_has_permissionsUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: model_has_permissionsCreateOrConnectWithoutPermissionsInput | model_has_permissionsCreateOrConnectWithoutPermissionsInput[]
    createMany?: model_has_permissionsCreateManyPermissionsInputEnvelope
    connect?: model_has_permissionsWhereUniqueInput | model_has_permissionsWhereUniqueInput[]
  }

  export type role_has_permissionsCreateNestedManyWithoutPermissionsInput = {
    create?: XOR<role_has_permissionsCreateWithoutPermissionsInput, role_has_permissionsUncheckedCreateWithoutPermissionsInput> | role_has_permissionsCreateWithoutPermissionsInput[] | role_has_permissionsUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: role_has_permissionsCreateOrConnectWithoutPermissionsInput | role_has_permissionsCreateOrConnectWithoutPermissionsInput[]
    createMany?: role_has_permissionsCreateManyPermissionsInputEnvelope
    connect?: role_has_permissionsWhereUniqueInput | role_has_permissionsWhereUniqueInput[]
  }

  export type model_has_permissionsUncheckedCreateNestedManyWithoutPermissionsInput = {
    create?: XOR<model_has_permissionsCreateWithoutPermissionsInput, model_has_permissionsUncheckedCreateWithoutPermissionsInput> | model_has_permissionsCreateWithoutPermissionsInput[] | model_has_permissionsUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: model_has_permissionsCreateOrConnectWithoutPermissionsInput | model_has_permissionsCreateOrConnectWithoutPermissionsInput[]
    createMany?: model_has_permissionsCreateManyPermissionsInputEnvelope
    connect?: model_has_permissionsWhereUniqueInput | model_has_permissionsWhereUniqueInput[]
  }

  export type role_has_permissionsUncheckedCreateNestedManyWithoutPermissionsInput = {
    create?: XOR<role_has_permissionsCreateWithoutPermissionsInput, role_has_permissionsUncheckedCreateWithoutPermissionsInput> | role_has_permissionsCreateWithoutPermissionsInput[] | role_has_permissionsUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: role_has_permissionsCreateOrConnectWithoutPermissionsInput | role_has_permissionsCreateOrConnectWithoutPermissionsInput[]
    createMany?: role_has_permissionsCreateManyPermissionsInputEnvelope
    connect?: role_has_permissionsWhereUniqueInput | role_has_permissionsWhereUniqueInput[]
  }

  export type model_has_permissionsUpdateManyWithoutPermissionsNestedInput = {
    create?: XOR<model_has_permissionsCreateWithoutPermissionsInput, model_has_permissionsUncheckedCreateWithoutPermissionsInput> | model_has_permissionsCreateWithoutPermissionsInput[] | model_has_permissionsUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: model_has_permissionsCreateOrConnectWithoutPermissionsInput | model_has_permissionsCreateOrConnectWithoutPermissionsInput[]
    upsert?: model_has_permissionsUpsertWithWhereUniqueWithoutPermissionsInput | model_has_permissionsUpsertWithWhereUniqueWithoutPermissionsInput[]
    createMany?: model_has_permissionsCreateManyPermissionsInputEnvelope
    set?: model_has_permissionsWhereUniqueInput | model_has_permissionsWhereUniqueInput[]
    disconnect?: model_has_permissionsWhereUniqueInput | model_has_permissionsWhereUniqueInput[]
    delete?: model_has_permissionsWhereUniqueInput | model_has_permissionsWhereUniqueInput[]
    connect?: model_has_permissionsWhereUniqueInput | model_has_permissionsWhereUniqueInput[]
    update?: model_has_permissionsUpdateWithWhereUniqueWithoutPermissionsInput | model_has_permissionsUpdateWithWhereUniqueWithoutPermissionsInput[]
    updateMany?: model_has_permissionsUpdateManyWithWhereWithoutPermissionsInput | model_has_permissionsUpdateManyWithWhereWithoutPermissionsInput[]
    deleteMany?: model_has_permissionsScalarWhereInput | model_has_permissionsScalarWhereInput[]
  }

  export type role_has_permissionsUpdateManyWithoutPermissionsNestedInput = {
    create?: XOR<role_has_permissionsCreateWithoutPermissionsInput, role_has_permissionsUncheckedCreateWithoutPermissionsInput> | role_has_permissionsCreateWithoutPermissionsInput[] | role_has_permissionsUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: role_has_permissionsCreateOrConnectWithoutPermissionsInput | role_has_permissionsCreateOrConnectWithoutPermissionsInput[]
    upsert?: role_has_permissionsUpsertWithWhereUniqueWithoutPermissionsInput | role_has_permissionsUpsertWithWhereUniqueWithoutPermissionsInput[]
    createMany?: role_has_permissionsCreateManyPermissionsInputEnvelope
    set?: role_has_permissionsWhereUniqueInput | role_has_permissionsWhereUniqueInput[]
    disconnect?: role_has_permissionsWhereUniqueInput | role_has_permissionsWhereUniqueInput[]
    delete?: role_has_permissionsWhereUniqueInput | role_has_permissionsWhereUniqueInput[]
    connect?: role_has_permissionsWhereUniqueInput | role_has_permissionsWhereUniqueInput[]
    update?: role_has_permissionsUpdateWithWhereUniqueWithoutPermissionsInput | role_has_permissionsUpdateWithWhereUniqueWithoutPermissionsInput[]
    updateMany?: role_has_permissionsUpdateManyWithWhereWithoutPermissionsInput | role_has_permissionsUpdateManyWithWhereWithoutPermissionsInput[]
    deleteMany?: role_has_permissionsScalarWhereInput | role_has_permissionsScalarWhereInput[]
  }

  export type model_has_permissionsUncheckedUpdateManyWithoutPermissionsNestedInput = {
    create?: XOR<model_has_permissionsCreateWithoutPermissionsInput, model_has_permissionsUncheckedCreateWithoutPermissionsInput> | model_has_permissionsCreateWithoutPermissionsInput[] | model_has_permissionsUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: model_has_permissionsCreateOrConnectWithoutPermissionsInput | model_has_permissionsCreateOrConnectWithoutPermissionsInput[]
    upsert?: model_has_permissionsUpsertWithWhereUniqueWithoutPermissionsInput | model_has_permissionsUpsertWithWhereUniqueWithoutPermissionsInput[]
    createMany?: model_has_permissionsCreateManyPermissionsInputEnvelope
    set?: model_has_permissionsWhereUniqueInput | model_has_permissionsWhereUniqueInput[]
    disconnect?: model_has_permissionsWhereUniqueInput | model_has_permissionsWhereUniqueInput[]
    delete?: model_has_permissionsWhereUniqueInput | model_has_permissionsWhereUniqueInput[]
    connect?: model_has_permissionsWhereUniqueInput | model_has_permissionsWhereUniqueInput[]
    update?: model_has_permissionsUpdateWithWhereUniqueWithoutPermissionsInput | model_has_permissionsUpdateWithWhereUniqueWithoutPermissionsInput[]
    updateMany?: model_has_permissionsUpdateManyWithWhereWithoutPermissionsInput | model_has_permissionsUpdateManyWithWhereWithoutPermissionsInput[]
    deleteMany?: model_has_permissionsScalarWhereInput | model_has_permissionsScalarWhereInput[]
  }

  export type role_has_permissionsUncheckedUpdateManyWithoutPermissionsNestedInput = {
    create?: XOR<role_has_permissionsCreateWithoutPermissionsInput, role_has_permissionsUncheckedCreateWithoutPermissionsInput> | role_has_permissionsCreateWithoutPermissionsInput[] | role_has_permissionsUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: role_has_permissionsCreateOrConnectWithoutPermissionsInput | role_has_permissionsCreateOrConnectWithoutPermissionsInput[]
    upsert?: role_has_permissionsUpsertWithWhereUniqueWithoutPermissionsInput | role_has_permissionsUpsertWithWhereUniqueWithoutPermissionsInput[]
    createMany?: role_has_permissionsCreateManyPermissionsInputEnvelope
    set?: role_has_permissionsWhereUniqueInput | role_has_permissionsWhereUniqueInput[]
    disconnect?: role_has_permissionsWhereUniqueInput | role_has_permissionsWhereUniqueInput[]
    delete?: role_has_permissionsWhereUniqueInput | role_has_permissionsWhereUniqueInput[]
    connect?: role_has_permissionsWhereUniqueInput | role_has_permissionsWhereUniqueInput[]
    update?: role_has_permissionsUpdateWithWhereUniqueWithoutPermissionsInput | role_has_permissionsUpdateWithWhereUniqueWithoutPermissionsInput[]
    updateMany?: role_has_permissionsUpdateManyWithWhereWithoutPermissionsInput | role_has_permissionsUpdateManyWithWhereWithoutPermissionsInput[]
    deleteMany?: role_has_permissionsScalarWhereInput | role_has_permissionsScalarWhereInput[]
  }

  export type permissionsCreateNestedOneWithoutRole_has_permissionsInput = {
    create?: XOR<permissionsCreateWithoutRole_has_permissionsInput, permissionsUncheckedCreateWithoutRole_has_permissionsInput>
    connectOrCreate?: permissionsCreateOrConnectWithoutRole_has_permissionsInput
    connect?: permissionsWhereUniqueInput
  }

  export type rolesCreateNestedOneWithoutRole_has_permissionsInput = {
    create?: XOR<rolesCreateWithoutRole_has_permissionsInput, rolesUncheckedCreateWithoutRole_has_permissionsInput>
    connectOrCreate?: rolesCreateOrConnectWithoutRole_has_permissionsInput
    connect?: rolesWhereUniqueInput
  }

  export type permissionsUpdateOneRequiredWithoutRole_has_permissionsNestedInput = {
    create?: XOR<permissionsCreateWithoutRole_has_permissionsInput, permissionsUncheckedCreateWithoutRole_has_permissionsInput>
    connectOrCreate?: permissionsCreateOrConnectWithoutRole_has_permissionsInput
    upsert?: permissionsUpsertWithoutRole_has_permissionsInput
    connect?: permissionsWhereUniqueInput
    update?: XOR<XOR<permissionsUpdateToOneWithWhereWithoutRole_has_permissionsInput, permissionsUpdateWithoutRole_has_permissionsInput>, permissionsUncheckedUpdateWithoutRole_has_permissionsInput>
  }

  export type rolesUpdateOneRequiredWithoutRole_has_permissionsNestedInput = {
    create?: XOR<rolesCreateWithoutRole_has_permissionsInput, rolesUncheckedCreateWithoutRole_has_permissionsInput>
    connectOrCreate?: rolesCreateOrConnectWithoutRole_has_permissionsInput
    upsert?: rolesUpsertWithoutRole_has_permissionsInput
    connect?: rolesWhereUniqueInput
    update?: XOR<XOR<rolesUpdateToOneWithWhereWithoutRole_has_permissionsInput, rolesUpdateWithoutRole_has_permissionsInput>, rolesUncheckedUpdateWithoutRole_has_permissionsInput>
  }

  export type model_has_rolesCreateNestedManyWithoutRolesInput = {
    create?: XOR<model_has_rolesCreateWithoutRolesInput, model_has_rolesUncheckedCreateWithoutRolesInput> | model_has_rolesCreateWithoutRolesInput[] | model_has_rolesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: model_has_rolesCreateOrConnectWithoutRolesInput | model_has_rolesCreateOrConnectWithoutRolesInput[]
    createMany?: model_has_rolesCreateManyRolesInputEnvelope
    connect?: model_has_rolesWhereUniqueInput | model_has_rolesWhereUniqueInput[]
  }

  export type role_has_permissionsCreateNestedManyWithoutRolesInput = {
    create?: XOR<role_has_permissionsCreateWithoutRolesInput, role_has_permissionsUncheckedCreateWithoutRolesInput> | role_has_permissionsCreateWithoutRolesInput[] | role_has_permissionsUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: role_has_permissionsCreateOrConnectWithoutRolesInput | role_has_permissionsCreateOrConnectWithoutRolesInput[]
    createMany?: role_has_permissionsCreateManyRolesInputEnvelope
    connect?: role_has_permissionsWhereUniqueInput | role_has_permissionsWhereUniqueInput[]
  }

  export type model_has_rolesUncheckedCreateNestedManyWithoutRolesInput = {
    create?: XOR<model_has_rolesCreateWithoutRolesInput, model_has_rolesUncheckedCreateWithoutRolesInput> | model_has_rolesCreateWithoutRolesInput[] | model_has_rolesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: model_has_rolesCreateOrConnectWithoutRolesInput | model_has_rolesCreateOrConnectWithoutRolesInput[]
    createMany?: model_has_rolesCreateManyRolesInputEnvelope
    connect?: model_has_rolesWhereUniqueInput | model_has_rolesWhereUniqueInput[]
  }

  export type role_has_permissionsUncheckedCreateNestedManyWithoutRolesInput = {
    create?: XOR<role_has_permissionsCreateWithoutRolesInput, role_has_permissionsUncheckedCreateWithoutRolesInput> | role_has_permissionsCreateWithoutRolesInput[] | role_has_permissionsUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: role_has_permissionsCreateOrConnectWithoutRolesInput | role_has_permissionsCreateOrConnectWithoutRolesInput[]
    createMany?: role_has_permissionsCreateManyRolesInputEnvelope
    connect?: role_has_permissionsWhereUniqueInput | role_has_permissionsWhereUniqueInput[]
  }

  export type model_has_rolesUpdateManyWithoutRolesNestedInput = {
    create?: XOR<model_has_rolesCreateWithoutRolesInput, model_has_rolesUncheckedCreateWithoutRolesInput> | model_has_rolesCreateWithoutRolesInput[] | model_has_rolesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: model_has_rolesCreateOrConnectWithoutRolesInput | model_has_rolesCreateOrConnectWithoutRolesInput[]
    upsert?: model_has_rolesUpsertWithWhereUniqueWithoutRolesInput | model_has_rolesUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: model_has_rolesCreateManyRolesInputEnvelope
    set?: model_has_rolesWhereUniqueInput | model_has_rolesWhereUniqueInput[]
    disconnect?: model_has_rolesWhereUniqueInput | model_has_rolesWhereUniqueInput[]
    delete?: model_has_rolesWhereUniqueInput | model_has_rolesWhereUniqueInput[]
    connect?: model_has_rolesWhereUniqueInput | model_has_rolesWhereUniqueInput[]
    update?: model_has_rolesUpdateWithWhereUniqueWithoutRolesInput | model_has_rolesUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: model_has_rolesUpdateManyWithWhereWithoutRolesInput | model_has_rolesUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: model_has_rolesScalarWhereInput | model_has_rolesScalarWhereInput[]
  }

  export type role_has_permissionsUpdateManyWithoutRolesNestedInput = {
    create?: XOR<role_has_permissionsCreateWithoutRolesInput, role_has_permissionsUncheckedCreateWithoutRolesInput> | role_has_permissionsCreateWithoutRolesInput[] | role_has_permissionsUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: role_has_permissionsCreateOrConnectWithoutRolesInput | role_has_permissionsCreateOrConnectWithoutRolesInput[]
    upsert?: role_has_permissionsUpsertWithWhereUniqueWithoutRolesInput | role_has_permissionsUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: role_has_permissionsCreateManyRolesInputEnvelope
    set?: role_has_permissionsWhereUniqueInput | role_has_permissionsWhereUniqueInput[]
    disconnect?: role_has_permissionsWhereUniqueInput | role_has_permissionsWhereUniqueInput[]
    delete?: role_has_permissionsWhereUniqueInput | role_has_permissionsWhereUniqueInput[]
    connect?: role_has_permissionsWhereUniqueInput | role_has_permissionsWhereUniqueInput[]
    update?: role_has_permissionsUpdateWithWhereUniqueWithoutRolesInput | role_has_permissionsUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: role_has_permissionsUpdateManyWithWhereWithoutRolesInput | role_has_permissionsUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: role_has_permissionsScalarWhereInput | role_has_permissionsScalarWhereInput[]
  }

  export type model_has_rolesUncheckedUpdateManyWithoutRolesNestedInput = {
    create?: XOR<model_has_rolesCreateWithoutRolesInput, model_has_rolesUncheckedCreateWithoutRolesInput> | model_has_rolesCreateWithoutRolesInput[] | model_has_rolesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: model_has_rolesCreateOrConnectWithoutRolesInput | model_has_rolesCreateOrConnectWithoutRolesInput[]
    upsert?: model_has_rolesUpsertWithWhereUniqueWithoutRolesInput | model_has_rolesUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: model_has_rolesCreateManyRolesInputEnvelope
    set?: model_has_rolesWhereUniqueInput | model_has_rolesWhereUniqueInput[]
    disconnect?: model_has_rolesWhereUniqueInput | model_has_rolesWhereUniqueInput[]
    delete?: model_has_rolesWhereUniqueInput | model_has_rolesWhereUniqueInput[]
    connect?: model_has_rolesWhereUniqueInput | model_has_rolesWhereUniqueInput[]
    update?: model_has_rolesUpdateWithWhereUniqueWithoutRolesInput | model_has_rolesUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: model_has_rolesUpdateManyWithWhereWithoutRolesInput | model_has_rolesUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: model_has_rolesScalarWhereInput | model_has_rolesScalarWhereInput[]
  }

  export type role_has_permissionsUncheckedUpdateManyWithoutRolesNestedInput = {
    create?: XOR<role_has_permissionsCreateWithoutRolesInput, role_has_permissionsUncheckedCreateWithoutRolesInput> | role_has_permissionsCreateWithoutRolesInput[] | role_has_permissionsUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: role_has_permissionsCreateOrConnectWithoutRolesInput | role_has_permissionsCreateOrConnectWithoutRolesInput[]
    upsert?: role_has_permissionsUpsertWithWhereUniqueWithoutRolesInput | role_has_permissionsUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: role_has_permissionsCreateManyRolesInputEnvelope
    set?: role_has_permissionsWhereUniqueInput | role_has_permissionsWhereUniqueInput[]
    disconnect?: role_has_permissionsWhereUniqueInput | role_has_permissionsWhereUniqueInput[]
    delete?: role_has_permissionsWhereUniqueInput | role_has_permissionsWhereUniqueInput[]
    connect?: role_has_permissionsWhereUniqueInput | role_has_permissionsWhereUniqueInput[]
    update?: role_has_permissionsUpdateWithWhereUniqueWithoutRolesInput | role_has_permissionsUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: role_has_permissionsUpdateManyWithWhereWithoutRolesInput | role_has_permissionsUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: role_has_permissionsScalarWhereInput | role_has_permissionsScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutVolunteersInput = {
    create?: XOR<ProjectCreateWithoutVolunteersInput, ProjectUncheckedCreateWithoutVolunteersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutVolunteersInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutVolunteersInput = {
    create?: XOR<UserCreateWithoutVolunteersInput, UserUncheckedCreateWithoutVolunteersInput>
    connectOrCreate?: UserCreateOrConnectWithoutVolunteersInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectUpdateOneWithoutVolunteersNestedInput = {
    create?: XOR<ProjectCreateWithoutVolunteersInput, ProjectUncheckedCreateWithoutVolunteersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutVolunteersInput
    upsert?: ProjectUpsertWithoutVolunteersInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutVolunteersInput, ProjectUpdateWithoutVolunteersInput>, ProjectUncheckedUpdateWithoutVolunteersInput>
  }

  export type UserUpdateOneWithoutVolunteersNestedInput = {
    create?: XOR<UserCreateWithoutVolunteersInput, UserUncheckedCreateWithoutVolunteersInput>
    connectOrCreate?: UserCreateOrConnectWithoutVolunteersInput
    upsert?: UserUpsertWithoutVolunteersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVolunteersInput, UserUpdateWithoutVolunteersInput>, UserUncheckedUpdateWithoutVolunteersInput>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type blogsCreateWithoutUsersInput = {
    id?: bigint | number
    slug: string
    title_id: string
    excerpt_id: string
    content_id: string
    title_en: string
    excerpt_en: string
    content_en: string
    author_name: string
    author_role?: string | null
    author_avatar?: string | null
    category: string
    tags?: NullableJsonNullValueInput | InputJsonValue
    image?: string | null
    image_alt?: string | null
    meta_title_id?: string | null
    meta_description_id?: string | null
    meta_title_en?: string | null
    meta_description_en?: string | null
    read_time?: number
    views_count?: bigint | number
    status?: string
    featured?: boolean
    published_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type blogsUncheckedCreateWithoutUsersInput = {
    id?: bigint | number
    slug: string
    title_id: string
    excerpt_id: string
    content_id: string
    title_en: string
    excerpt_en: string
    content_en: string
    author_name: string
    author_role?: string | null
    author_avatar?: string | null
    category: string
    tags?: NullableJsonNullValueInput | InputJsonValue
    image?: string | null
    image_alt?: string | null
    meta_title_id?: string | null
    meta_description_id?: string | null
    meta_title_en?: string | null
    meta_description_en?: string | null
    read_time?: number
    views_count?: bigint | number
    status?: string
    featured?: boolean
    published_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type blogsCreateOrConnectWithoutUsersInput = {
    where: blogsWhereUniqueInput
    create: XOR<blogsCreateWithoutUsersInput, blogsUncheckedCreateWithoutUsersInput>
  }

  export type blogsCreateManyUsersInputEnvelope = {
    data: blogsCreateManyUsersInput | blogsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type contactsCreateWithoutUsersInput = {
    id?: bigint | number
    contact_id: string
    name: string
    email: string
    phone?: string | null
    subject?: string
    message: string
    ip_address?: string | null
    user_agent?: string | null
    status?: string
    priority?: string
    responded_at?: Date | string | null
    response?: string | null
    internal_notes?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type contactsUncheckedCreateWithoutUsersInput = {
    id?: bigint | number
    contact_id: string
    name: string
    email: string
    phone?: string | null
    subject?: string
    message: string
    ip_address?: string | null
    user_agent?: string | null
    status?: string
    priority?: string
    responded_at?: Date | string | null
    response?: string | null
    internal_notes?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type contactsCreateOrConnectWithoutUsersInput = {
    where: contactsWhereUniqueInput
    create: XOR<contactsCreateWithoutUsersInput, contactsUncheckedCreateWithoutUsersInput>
  }

  export type contactsCreateManyUsersInputEnvelope = {
    data: contactsCreateManyUsersInput | contactsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type donationsCreateWithoutUsersInput = {
    id?: bigint | number
    donation_id: string
    donor_name?: string | null
    donor_email?: string | null
    donor_phone?: string | null
    amount: bigint | number
    frequency?: string
    status?: string
    payment_method?: string | null
    payment_channel?: string | null
    transaction_id?: string | null
    paid_at?: Date | string | null
    message?: string | null
    is_anonymous?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    projects: ProjectCreateNestedOneWithoutDonationsInput
  }

  export type donationsUncheckedCreateWithoutUsersInput = {
    id?: bigint | number
    donation_id: string
    project_id: bigint | number
    donor_name?: string | null
    donor_email?: string | null
    donor_phone?: string | null
    amount: bigint | number
    frequency?: string
    status?: string
    payment_method?: string | null
    payment_channel?: string | null
    transaction_id?: string | null
    paid_at?: Date | string | null
    message?: string | null
    is_anonymous?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type donationsCreateOrConnectWithoutUsersInput = {
    where: donationsWhereUniqueInput
    create: XOR<donationsCreateWithoutUsersInput, donationsUncheckedCreateWithoutUsersInput>
  }

  export type donationsCreateManyUsersInputEnvelope = {
    data: donationsCreateManyUsersInput | donationsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type volunteersCreateWithoutUsersInput = {
    id?: bigint | number
    volunteer_id: string
    first_name: string
    last_name: string
    email: string
    phone: string
    interests?: NullableJsonNullValueInput | InputJsonValue
    availability?: NullableJsonNullValueInput | InputJsonValue
    experience?: string | null
    motivation: string
    location?: string | null
    occupation?: string | null
    status?: string
    approved_at?: Date | string | null
    notes?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    projects?: ProjectCreateNestedOneWithoutVolunteersInput
  }

  export type volunteersUncheckedCreateWithoutUsersInput = {
    id?: bigint | number
    volunteer_id: string
    project_id?: bigint | number | null
    first_name: string
    last_name: string
    email: string
    phone: string
    interests?: NullableJsonNullValueInput | InputJsonValue
    availability?: NullableJsonNullValueInput | InputJsonValue
    experience?: string | null
    motivation: string
    location?: string | null
    occupation?: string | null
    status?: string
    approved_at?: Date | string | null
    notes?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type volunteersCreateOrConnectWithoutUsersInput = {
    where: volunteersWhereUniqueInput
    create: XOR<volunteersCreateWithoutUsersInput, volunteersUncheckedCreateWithoutUsersInput>
  }

  export type volunteersCreateManyUsersInputEnvelope = {
    data: volunteersCreateManyUsersInput | volunteersCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type blogsUpsertWithWhereUniqueWithoutUsersInput = {
    where: blogsWhereUniqueInput
    update: XOR<blogsUpdateWithoutUsersInput, blogsUncheckedUpdateWithoutUsersInput>
    create: XOR<blogsCreateWithoutUsersInput, blogsUncheckedCreateWithoutUsersInput>
  }

  export type blogsUpdateWithWhereUniqueWithoutUsersInput = {
    where: blogsWhereUniqueInput
    data: XOR<blogsUpdateWithoutUsersInput, blogsUncheckedUpdateWithoutUsersInput>
  }

  export type blogsUpdateManyWithWhereWithoutUsersInput = {
    where: blogsScalarWhereInput
    data: XOR<blogsUpdateManyMutationInput, blogsUncheckedUpdateManyWithoutUsersInput>
  }

  export type blogsScalarWhereInput = {
    AND?: blogsScalarWhereInput | blogsScalarWhereInput[]
    OR?: blogsScalarWhereInput[]
    NOT?: blogsScalarWhereInput | blogsScalarWhereInput[]
    id?: BigIntFilter<"blogs"> | bigint | number
    slug?: StringFilter<"blogs"> | string
    user_id?: BigIntNullableFilter<"blogs"> | bigint | number | null
    title_id?: StringFilter<"blogs"> | string
    excerpt_id?: StringFilter<"blogs"> | string
    content_id?: StringFilter<"blogs"> | string
    title_en?: StringFilter<"blogs"> | string
    excerpt_en?: StringFilter<"blogs"> | string
    content_en?: StringFilter<"blogs"> | string
    author_name?: StringFilter<"blogs"> | string
    author_role?: StringNullableFilter<"blogs"> | string | null
    author_avatar?: StringNullableFilter<"blogs"> | string | null
    category?: StringFilter<"blogs"> | string
    tags?: JsonNullableFilter<"blogs">
    image?: StringNullableFilter<"blogs"> | string | null
    image_alt?: StringNullableFilter<"blogs"> | string | null
    meta_title_id?: StringNullableFilter<"blogs"> | string | null
    meta_description_id?: StringNullableFilter<"blogs"> | string | null
    meta_title_en?: StringNullableFilter<"blogs"> | string | null
    meta_description_en?: StringNullableFilter<"blogs"> | string | null
    read_time?: IntFilter<"blogs"> | number
    views_count?: BigIntFilter<"blogs"> | bigint | number
    status?: StringFilter<"blogs"> | string
    featured?: BoolFilter<"blogs"> | boolean
    published_at?: DateTimeNullableFilter<"blogs"> | Date | string | null
    created_at?: DateTimeNullableFilter<"blogs"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"blogs"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"blogs"> | Date | string | null
  }

  export type contactsUpsertWithWhereUniqueWithoutUsersInput = {
    where: contactsWhereUniqueInput
    update: XOR<contactsUpdateWithoutUsersInput, contactsUncheckedUpdateWithoutUsersInput>
    create: XOR<contactsCreateWithoutUsersInput, contactsUncheckedCreateWithoutUsersInput>
  }

  export type contactsUpdateWithWhereUniqueWithoutUsersInput = {
    where: contactsWhereUniqueInput
    data: XOR<contactsUpdateWithoutUsersInput, contactsUncheckedUpdateWithoutUsersInput>
  }

  export type contactsUpdateManyWithWhereWithoutUsersInput = {
    where: contactsScalarWhereInput
    data: XOR<contactsUpdateManyMutationInput, contactsUncheckedUpdateManyWithoutUsersInput>
  }

  export type contactsScalarWhereInput = {
    AND?: contactsScalarWhereInput | contactsScalarWhereInput[]
    OR?: contactsScalarWhereInput[]
    NOT?: contactsScalarWhereInput | contactsScalarWhereInput[]
    id?: BigIntFilter<"contacts"> | bigint | number
    contact_id?: StringFilter<"contacts"> | string
    name?: StringFilter<"contacts"> | string
    email?: StringFilter<"contacts"> | string
    phone?: StringNullableFilter<"contacts"> | string | null
    subject?: StringFilter<"contacts"> | string
    message?: StringFilter<"contacts"> | string
    ip_address?: StringNullableFilter<"contacts"> | string | null
    user_agent?: StringNullableFilter<"contacts"> | string | null
    status?: StringFilter<"contacts"> | string
    priority?: StringFilter<"contacts"> | string
    assigned_to?: BigIntNullableFilter<"contacts"> | bigint | number | null
    responded_at?: DateTimeNullableFilter<"contacts"> | Date | string | null
    response?: StringNullableFilter<"contacts"> | string | null
    internal_notes?: StringNullableFilter<"contacts"> | string | null
    created_at?: DateTimeNullableFilter<"contacts"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"contacts"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"contacts"> | Date | string | null
  }

  export type donationsUpsertWithWhereUniqueWithoutUsersInput = {
    where: donationsWhereUniqueInput
    update: XOR<donationsUpdateWithoutUsersInput, donationsUncheckedUpdateWithoutUsersInput>
    create: XOR<donationsCreateWithoutUsersInput, donationsUncheckedCreateWithoutUsersInput>
  }

  export type donationsUpdateWithWhereUniqueWithoutUsersInput = {
    where: donationsWhereUniqueInput
    data: XOR<donationsUpdateWithoutUsersInput, donationsUncheckedUpdateWithoutUsersInput>
  }

  export type donationsUpdateManyWithWhereWithoutUsersInput = {
    where: donationsScalarWhereInput
    data: XOR<donationsUpdateManyMutationInput, donationsUncheckedUpdateManyWithoutUsersInput>
  }

  export type donationsScalarWhereInput = {
    AND?: donationsScalarWhereInput | donationsScalarWhereInput[]
    OR?: donationsScalarWhereInput[]
    NOT?: donationsScalarWhereInput | donationsScalarWhereInput[]
    id?: BigIntFilter<"donations"> | bigint | number
    donation_id?: StringFilter<"donations"> | string
    project_id?: BigIntFilter<"donations"> | bigint | number
    user_id?: BigIntNullableFilter<"donations"> | bigint | number | null
    donor_name?: StringNullableFilter<"donations"> | string | null
    donor_email?: StringNullableFilter<"donations"> | string | null
    donor_phone?: StringNullableFilter<"donations"> | string | null
    amount?: BigIntFilter<"donations"> | bigint | number
    frequency?: StringFilter<"donations"> | string
    status?: StringFilter<"donations"> | string
    payment_method?: StringNullableFilter<"donations"> | string | null
    payment_channel?: StringNullableFilter<"donations"> | string | null
    transaction_id?: StringNullableFilter<"donations"> | string | null
    paid_at?: DateTimeNullableFilter<"donations"> | Date | string | null
    message?: StringNullableFilter<"donations"> | string | null
    is_anonymous?: BoolFilter<"donations"> | boolean
    metadata?: JsonNullableFilter<"donations">
    created_at?: DateTimeNullableFilter<"donations"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"donations"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"donations"> | Date | string | null
  }

  export type volunteersUpsertWithWhereUniqueWithoutUsersInput = {
    where: volunteersWhereUniqueInput
    update: XOR<volunteersUpdateWithoutUsersInput, volunteersUncheckedUpdateWithoutUsersInput>
    create: XOR<volunteersCreateWithoutUsersInput, volunteersUncheckedCreateWithoutUsersInput>
  }

  export type volunteersUpdateWithWhereUniqueWithoutUsersInput = {
    where: volunteersWhereUniqueInput
    data: XOR<volunteersUpdateWithoutUsersInput, volunteersUncheckedUpdateWithoutUsersInput>
  }

  export type volunteersUpdateManyWithWhereWithoutUsersInput = {
    where: volunteersScalarWhereInput
    data: XOR<volunteersUpdateManyMutationInput, volunteersUncheckedUpdateManyWithoutUsersInput>
  }

  export type volunteersScalarWhereInput = {
    AND?: volunteersScalarWhereInput | volunteersScalarWhereInput[]
    OR?: volunteersScalarWhereInput[]
    NOT?: volunteersScalarWhereInput | volunteersScalarWhereInput[]
    id?: BigIntFilter<"volunteers"> | bigint | number
    volunteer_id?: StringFilter<"volunteers"> | string
    user_id?: BigIntNullableFilter<"volunteers"> | bigint | number | null
    project_id?: BigIntNullableFilter<"volunteers"> | bigint | number | null
    first_name?: StringFilter<"volunteers"> | string
    last_name?: StringFilter<"volunteers"> | string
    email?: StringFilter<"volunteers"> | string
    phone?: StringFilter<"volunteers"> | string
    interests?: JsonNullableFilter<"volunteers">
    availability?: JsonNullableFilter<"volunteers">
    experience?: StringNullableFilter<"volunteers"> | string | null
    motivation?: StringFilter<"volunteers"> | string
    location?: StringNullableFilter<"volunteers"> | string | null
    occupation?: StringNullableFilter<"volunteers"> | string | null
    status?: StringFilter<"volunteers"> | string
    approved_at?: DateTimeNullableFilter<"volunteers"> | Date | string | null
    notes?: StringNullableFilter<"volunteers"> | string | null
    skills?: JsonNullableFilter<"volunteers">
    created_at?: DateTimeNullableFilter<"volunteers"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"volunteers"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"volunteers"> | Date | string | null
  }

  export type donationsCreateWithoutProjectsInput = {
    id?: bigint | number
    donation_id: string
    donor_name?: string | null
    donor_email?: string | null
    donor_phone?: string | null
    amount: bigint | number
    frequency?: string
    status?: string
    payment_method?: string | null
    payment_channel?: string | null
    transaction_id?: string | null
    paid_at?: Date | string | null
    message?: string | null
    is_anonymous?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    users?: UserCreateNestedOneWithoutDonationsInput
  }

  export type donationsUncheckedCreateWithoutProjectsInput = {
    id?: bigint | number
    donation_id: string
    user_id?: bigint | number | null
    donor_name?: string | null
    donor_email?: string | null
    donor_phone?: string | null
    amount: bigint | number
    frequency?: string
    status?: string
    payment_method?: string | null
    payment_channel?: string | null
    transaction_id?: string | null
    paid_at?: Date | string | null
    message?: string | null
    is_anonymous?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type donationsCreateOrConnectWithoutProjectsInput = {
    where: donationsWhereUniqueInput
    create: XOR<donationsCreateWithoutProjectsInput, donationsUncheckedCreateWithoutProjectsInput>
  }

  export type donationsCreateManyProjectsInputEnvelope = {
    data: donationsCreateManyProjectsInput | donationsCreateManyProjectsInput[]
    skipDuplicates?: boolean
  }

  export type volunteersCreateWithoutProjectsInput = {
    id?: bigint | number
    volunteer_id: string
    first_name: string
    last_name: string
    email: string
    phone: string
    interests?: NullableJsonNullValueInput | InputJsonValue
    availability?: NullableJsonNullValueInput | InputJsonValue
    experience?: string | null
    motivation: string
    location?: string | null
    occupation?: string | null
    status?: string
    approved_at?: Date | string | null
    notes?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    users?: UserCreateNestedOneWithoutVolunteersInput
  }

  export type volunteersUncheckedCreateWithoutProjectsInput = {
    id?: bigint | number
    volunteer_id: string
    user_id?: bigint | number | null
    first_name: string
    last_name: string
    email: string
    phone: string
    interests?: NullableJsonNullValueInput | InputJsonValue
    availability?: NullableJsonNullValueInput | InputJsonValue
    experience?: string | null
    motivation: string
    location?: string | null
    occupation?: string | null
    status?: string
    approved_at?: Date | string | null
    notes?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type volunteersCreateOrConnectWithoutProjectsInput = {
    where: volunteersWhereUniqueInput
    create: XOR<volunteersCreateWithoutProjectsInput, volunteersUncheckedCreateWithoutProjectsInput>
  }

  export type volunteersCreateManyProjectsInputEnvelope = {
    data: volunteersCreateManyProjectsInput | volunteersCreateManyProjectsInput[]
    skipDuplicates?: boolean
  }

  export type donationsUpsertWithWhereUniqueWithoutProjectsInput = {
    where: donationsWhereUniqueInput
    update: XOR<donationsUpdateWithoutProjectsInput, donationsUncheckedUpdateWithoutProjectsInput>
    create: XOR<donationsCreateWithoutProjectsInput, donationsUncheckedCreateWithoutProjectsInput>
  }

  export type donationsUpdateWithWhereUniqueWithoutProjectsInput = {
    where: donationsWhereUniqueInput
    data: XOR<donationsUpdateWithoutProjectsInput, donationsUncheckedUpdateWithoutProjectsInput>
  }

  export type donationsUpdateManyWithWhereWithoutProjectsInput = {
    where: donationsScalarWhereInput
    data: XOR<donationsUpdateManyMutationInput, donationsUncheckedUpdateManyWithoutProjectsInput>
  }

  export type volunteersUpsertWithWhereUniqueWithoutProjectsInput = {
    where: volunteersWhereUniqueInput
    update: XOR<volunteersUpdateWithoutProjectsInput, volunteersUncheckedUpdateWithoutProjectsInput>
    create: XOR<volunteersCreateWithoutProjectsInput, volunteersUncheckedCreateWithoutProjectsInput>
  }

  export type volunteersUpdateWithWhereUniqueWithoutProjectsInput = {
    where: volunteersWhereUniqueInput
    data: XOR<volunteersUpdateWithoutProjectsInput, volunteersUncheckedUpdateWithoutProjectsInput>
  }

  export type volunteersUpdateManyWithWhereWithoutProjectsInput = {
    where: volunteersScalarWhereInput
    data: XOR<volunteersUpdateManyMutationInput, volunteersUncheckedUpdateManyWithoutProjectsInput>
  }

  export type UserCreateWithoutBlogsInput = {
    id?: bigint | number
    name: string
    email: string
    email_verified_at?: Date | string | null
    password: string
    remember_token?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    accesses?: NullableJsonNullValueInput | InputJsonValue
    must_change_password?: boolean
    contacts?: contactsCreateNestedManyWithoutUsersInput
    donations?: donationsCreateNestedManyWithoutUsersInput
    volunteers?: volunteersCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutBlogsInput = {
    id?: bigint | number
    name: string
    email: string
    email_verified_at?: Date | string | null
    password: string
    remember_token?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    accesses?: NullableJsonNullValueInput | InputJsonValue
    must_change_password?: boolean
    contacts?: contactsUncheckedCreateNestedManyWithoutUsersInput
    donations?: donationsUncheckedCreateNestedManyWithoutUsersInput
    volunteers?: volunteersUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutBlogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlogsInput, UserUncheckedCreateWithoutBlogsInput>
  }

  export type UserUpsertWithoutBlogsInput = {
    update: XOR<UserUpdateWithoutBlogsInput, UserUncheckedUpdateWithoutBlogsInput>
    create: XOR<UserCreateWithoutBlogsInput, UserUncheckedCreateWithoutBlogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBlogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBlogsInput, UserUncheckedUpdateWithoutBlogsInput>
  }

  export type UserUpdateWithoutBlogsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    remember_token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accesses?: NullableJsonNullValueInput | InputJsonValue
    must_change_password?: BoolFieldUpdateOperationsInput | boolean
    contacts?: contactsUpdateManyWithoutUsersNestedInput
    donations?: donationsUpdateManyWithoutUsersNestedInput
    volunteers?: volunteersUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutBlogsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    remember_token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accesses?: NullableJsonNullValueInput | InputJsonValue
    must_change_password?: BoolFieldUpdateOperationsInput | boolean
    contacts?: contactsUncheckedUpdateManyWithoutUsersNestedInput
    donations?: donationsUncheckedUpdateManyWithoutUsersNestedInput
    volunteers?: volunteersUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserCreateWithoutContactsInput = {
    id?: bigint | number
    name: string
    email: string
    email_verified_at?: Date | string | null
    password: string
    remember_token?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    accesses?: NullableJsonNullValueInput | InputJsonValue
    must_change_password?: boolean
    blogs?: blogsCreateNestedManyWithoutUsersInput
    donations?: donationsCreateNestedManyWithoutUsersInput
    volunteers?: volunteersCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutContactsInput = {
    id?: bigint | number
    name: string
    email: string
    email_verified_at?: Date | string | null
    password: string
    remember_token?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    accesses?: NullableJsonNullValueInput | InputJsonValue
    must_change_password?: boolean
    blogs?: blogsUncheckedCreateNestedManyWithoutUsersInput
    donations?: donationsUncheckedCreateNestedManyWithoutUsersInput
    volunteers?: volunteersUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutContactsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutContactsInput, UserUncheckedCreateWithoutContactsInput>
  }

  export type UserUpsertWithoutContactsInput = {
    update: XOR<UserUpdateWithoutContactsInput, UserUncheckedUpdateWithoutContactsInput>
    create: XOR<UserCreateWithoutContactsInput, UserUncheckedCreateWithoutContactsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutContactsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutContactsInput, UserUncheckedUpdateWithoutContactsInput>
  }

  export type UserUpdateWithoutContactsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    remember_token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accesses?: NullableJsonNullValueInput | InputJsonValue
    must_change_password?: BoolFieldUpdateOperationsInput | boolean
    blogs?: blogsUpdateManyWithoutUsersNestedInput
    donations?: donationsUpdateManyWithoutUsersNestedInput
    volunteers?: volunteersUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutContactsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    remember_token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accesses?: NullableJsonNullValueInput | InputJsonValue
    must_change_password?: BoolFieldUpdateOperationsInput | boolean
    blogs?: blogsUncheckedUpdateManyWithoutUsersNestedInput
    donations?: donationsUncheckedUpdateManyWithoutUsersNestedInput
    volunteers?: volunteersUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type ProjectCreateWithoutDonationsInput = {
    id?: bigint | number
    projectId: string
    url: string
    titleId: string
    titleEn: string
    descriptionId: string
    descriptionEn: string
    location: string
    goalAmount: bigint | number
    raisedAmount?: bigint | number
    studentsImpacted: number
    image?: string | null
    status?: string
    featured?: boolean
    category: string
    startDate: Date | string
    endDate: Date | string
    school: JsonNullValueInput | InputJsonValue
    donorCount?: number
    volunteerCount?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    volunteers?: volunteersCreateNestedManyWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutDonationsInput = {
    id?: bigint | number
    projectId: string
    url: string
    titleId: string
    titleEn: string
    descriptionId: string
    descriptionEn: string
    location: string
    goalAmount: bigint | number
    raisedAmount?: bigint | number
    studentsImpacted: number
    image?: string | null
    status?: string
    featured?: boolean
    category: string
    startDate: Date | string
    endDate: Date | string
    school: JsonNullValueInput | InputJsonValue
    donorCount?: number
    volunteerCount?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    volunteers?: volunteersUncheckedCreateNestedManyWithoutProjectsInput
  }

  export type ProjectCreateOrConnectWithoutDonationsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutDonationsInput, ProjectUncheckedCreateWithoutDonationsInput>
  }

  export type UserCreateWithoutDonationsInput = {
    id?: bigint | number
    name: string
    email: string
    email_verified_at?: Date | string | null
    password: string
    remember_token?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    accesses?: NullableJsonNullValueInput | InputJsonValue
    must_change_password?: boolean
    blogs?: blogsCreateNestedManyWithoutUsersInput
    contacts?: contactsCreateNestedManyWithoutUsersInput
    volunteers?: volunteersCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutDonationsInput = {
    id?: bigint | number
    name: string
    email: string
    email_verified_at?: Date | string | null
    password: string
    remember_token?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    accesses?: NullableJsonNullValueInput | InputJsonValue
    must_change_password?: boolean
    blogs?: blogsUncheckedCreateNestedManyWithoutUsersInput
    contacts?: contactsUncheckedCreateNestedManyWithoutUsersInput
    volunteers?: volunteersUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutDonationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDonationsInput, UserUncheckedCreateWithoutDonationsInput>
  }

  export type ProjectUpsertWithoutDonationsInput = {
    update: XOR<ProjectUpdateWithoutDonationsInput, ProjectUncheckedUpdateWithoutDonationsInput>
    create: XOR<ProjectCreateWithoutDonationsInput, ProjectUncheckedCreateWithoutDonationsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutDonationsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutDonationsInput, ProjectUncheckedUpdateWithoutDonationsInput>
  }

  export type ProjectUpdateWithoutDonationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    projectId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    titleId?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionId?: StringFieldUpdateOperationsInput | string
    descriptionEn?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    goalAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    raisedAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    studentsImpacted?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    category?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: JsonNullValueInput | InputJsonValue
    donorCount?: IntFieldUpdateOperationsInput | number
    volunteerCount?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    volunteers?: volunteersUpdateManyWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutDonationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    projectId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    titleId?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionId?: StringFieldUpdateOperationsInput | string
    descriptionEn?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    goalAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    raisedAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    studentsImpacted?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    category?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: JsonNullValueInput | InputJsonValue
    donorCount?: IntFieldUpdateOperationsInput | number
    volunteerCount?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    volunteers?: volunteersUncheckedUpdateManyWithoutProjectsNestedInput
  }

  export type UserUpsertWithoutDonationsInput = {
    update: XOR<UserUpdateWithoutDonationsInput, UserUncheckedUpdateWithoutDonationsInput>
    create: XOR<UserCreateWithoutDonationsInput, UserUncheckedCreateWithoutDonationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDonationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDonationsInput, UserUncheckedUpdateWithoutDonationsInput>
  }

  export type UserUpdateWithoutDonationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    remember_token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accesses?: NullableJsonNullValueInput | InputJsonValue
    must_change_password?: BoolFieldUpdateOperationsInput | boolean
    blogs?: blogsUpdateManyWithoutUsersNestedInput
    contacts?: contactsUpdateManyWithoutUsersNestedInput
    volunteers?: volunteersUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutDonationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    remember_token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accesses?: NullableJsonNullValueInput | InputJsonValue
    must_change_password?: BoolFieldUpdateOperationsInput | boolean
    blogs?: blogsUncheckedUpdateManyWithoutUsersNestedInput
    contacts?: contactsUncheckedUpdateManyWithoutUsersNestedInput
    volunteers?: volunteersUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type permissionsCreateWithoutModel_has_permissionsInput = {
    id?: bigint | number
    name: string
    guard_name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    role_has_permissions?: role_has_permissionsCreateNestedManyWithoutPermissionsInput
  }

  export type permissionsUncheckedCreateWithoutModel_has_permissionsInput = {
    id?: bigint | number
    name: string
    guard_name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    role_has_permissions?: role_has_permissionsUncheckedCreateNestedManyWithoutPermissionsInput
  }

  export type permissionsCreateOrConnectWithoutModel_has_permissionsInput = {
    where: permissionsWhereUniqueInput
    create: XOR<permissionsCreateWithoutModel_has_permissionsInput, permissionsUncheckedCreateWithoutModel_has_permissionsInput>
  }

  export type permissionsUpsertWithoutModel_has_permissionsInput = {
    update: XOR<permissionsUpdateWithoutModel_has_permissionsInput, permissionsUncheckedUpdateWithoutModel_has_permissionsInput>
    create: XOR<permissionsCreateWithoutModel_has_permissionsInput, permissionsUncheckedCreateWithoutModel_has_permissionsInput>
    where?: permissionsWhereInput
  }

  export type permissionsUpdateToOneWithWhereWithoutModel_has_permissionsInput = {
    where?: permissionsWhereInput
    data: XOR<permissionsUpdateWithoutModel_has_permissionsInput, permissionsUncheckedUpdateWithoutModel_has_permissionsInput>
  }

  export type permissionsUpdateWithoutModel_has_permissionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    guard_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role_has_permissions?: role_has_permissionsUpdateManyWithoutPermissionsNestedInput
  }

  export type permissionsUncheckedUpdateWithoutModel_has_permissionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    guard_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role_has_permissions?: role_has_permissionsUncheckedUpdateManyWithoutPermissionsNestedInput
  }

  export type rolesCreateWithoutModel_has_rolesInput = {
    id?: bigint | number
    name: string
    guard_name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    role_has_permissions?: role_has_permissionsCreateNestedManyWithoutRolesInput
  }

  export type rolesUncheckedCreateWithoutModel_has_rolesInput = {
    id?: bigint | number
    name: string
    guard_name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    role_has_permissions?: role_has_permissionsUncheckedCreateNestedManyWithoutRolesInput
  }

  export type rolesCreateOrConnectWithoutModel_has_rolesInput = {
    where: rolesWhereUniqueInput
    create: XOR<rolesCreateWithoutModel_has_rolesInput, rolesUncheckedCreateWithoutModel_has_rolesInput>
  }

  export type rolesUpsertWithoutModel_has_rolesInput = {
    update: XOR<rolesUpdateWithoutModel_has_rolesInput, rolesUncheckedUpdateWithoutModel_has_rolesInput>
    create: XOR<rolesCreateWithoutModel_has_rolesInput, rolesUncheckedCreateWithoutModel_has_rolesInput>
    where?: rolesWhereInput
  }

  export type rolesUpdateToOneWithWhereWithoutModel_has_rolesInput = {
    where?: rolesWhereInput
    data: XOR<rolesUpdateWithoutModel_has_rolesInput, rolesUncheckedUpdateWithoutModel_has_rolesInput>
  }

  export type rolesUpdateWithoutModel_has_rolesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    guard_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role_has_permissions?: role_has_permissionsUpdateManyWithoutRolesNestedInput
  }

  export type rolesUncheckedUpdateWithoutModel_has_rolesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    guard_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role_has_permissions?: role_has_permissionsUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type model_has_permissionsCreateWithoutPermissionsInput = {
    model_type: string
    model_id: bigint | number
  }

  export type model_has_permissionsUncheckedCreateWithoutPermissionsInput = {
    model_type: string
    model_id: bigint | number
  }

  export type model_has_permissionsCreateOrConnectWithoutPermissionsInput = {
    where: model_has_permissionsWhereUniqueInput
    create: XOR<model_has_permissionsCreateWithoutPermissionsInput, model_has_permissionsUncheckedCreateWithoutPermissionsInput>
  }

  export type model_has_permissionsCreateManyPermissionsInputEnvelope = {
    data: model_has_permissionsCreateManyPermissionsInput | model_has_permissionsCreateManyPermissionsInput[]
    skipDuplicates?: boolean
  }

  export type role_has_permissionsCreateWithoutPermissionsInput = {
    roles: rolesCreateNestedOneWithoutRole_has_permissionsInput
  }

  export type role_has_permissionsUncheckedCreateWithoutPermissionsInput = {
    role_id: bigint | number
  }

  export type role_has_permissionsCreateOrConnectWithoutPermissionsInput = {
    where: role_has_permissionsWhereUniqueInput
    create: XOR<role_has_permissionsCreateWithoutPermissionsInput, role_has_permissionsUncheckedCreateWithoutPermissionsInput>
  }

  export type role_has_permissionsCreateManyPermissionsInputEnvelope = {
    data: role_has_permissionsCreateManyPermissionsInput | role_has_permissionsCreateManyPermissionsInput[]
    skipDuplicates?: boolean
  }

  export type model_has_permissionsUpsertWithWhereUniqueWithoutPermissionsInput = {
    where: model_has_permissionsWhereUniqueInput
    update: XOR<model_has_permissionsUpdateWithoutPermissionsInput, model_has_permissionsUncheckedUpdateWithoutPermissionsInput>
    create: XOR<model_has_permissionsCreateWithoutPermissionsInput, model_has_permissionsUncheckedCreateWithoutPermissionsInput>
  }

  export type model_has_permissionsUpdateWithWhereUniqueWithoutPermissionsInput = {
    where: model_has_permissionsWhereUniqueInput
    data: XOR<model_has_permissionsUpdateWithoutPermissionsInput, model_has_permissionsUncheckedUpdateWithoutPermissionsInput>
  }

  export type model_has_permissionsUpdateManyWithWhereWithoutPermissionsInput = {
    where: model_has_permissionsScalarWhereInput
    data: XOR<model_has_permissionsUpdateManyMutationInput, model_has_permissionsUncheckedUpdateManyWithoutPermissionsInput>
  }

  export type model_has_permissionsScalarWhereInput = {
    AND?: model_has_permissionsScalarWhereInput | model_has_permissionsScalarWhereInput[]
    OR?: model_has_permissionsScalarWhereInput[]
    NOT?: model_has_permissionsScalarWhereInput | model_has_permissionsScalarWhereInput[]
    permission_id?: BigIntFilter<"model_has_permissions"> | bigint | number
    model_type?: StringFilter<"model_has_permissions"> | string
    model_id?: BigIntFilter<"model_has_permissions"> | bigint | number
  }

  export type role_has_permissionsUpsertWithWhereUniqueWithoutPermissionsInput = {
    where: role_has_permissionsWhereUniqueInput
    update: XOR<role_has_permissionsUpdateWithoutPermissionsInput, role_has_permissionsUncheckedUpdateWithoutPermissionsInput>
    create: XOR<role_has_permissionsCreateWithoutPermissionsInput, role_has_permissionsUncheckedCreateWithoutPermissionsInput>
  }

  export type role_has_permissionsUpdateWithWhereUniqueWithoutPermissionsInput = {
    where: role_has_permissionsWhereUniqueInput
    data: XOR<role_has_permissionsUpdateWithoutPermissionsInput, role_has_permissionsUncheckedUpdateWithoutPermissionsInput>
  }

  export type role_has_permissionsUpdateManyWithWhereWithoutPermissionsInput = {
    where: role_has_permissionsScalarWhereInput
    data: XOR<role_has_permissionsUpdateManyMutationInput, role_has_permissionsUncheckedUpdateManyWithoutPermissionsInput>
  }

  export type role_has_permissionsScalarWhereInput = {
    AND?: role_has_permissionsScalarWhereInput | role_has_permissionsScalarWhereInput[]
    OR?: role_has_permissionsScalarWhereInput[]
    NOT?: role_has_permissionsScalarWhereInput | role_has_permissionsScalarWhereInput[]
    permission_id?: BigIntFilter<"role_has_permissions"> | bigint | number
    role_id?: BigIntFilter<"role_has_permissions"> | bigint | number
  }

  export type permissionsCreateWithoutRole_has_permissionsInput = {
    id?: bigint | number
    name: string
    guard_name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    model_has_permissions?: model_has_permissionsCreateNestedManyWithoutPermissionsInput
  }

  export type permissionsUncheckedCreateWithoutRole_has_permissionsInput = {
    id?: bigint | number
    name: string
    guard_name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    model_has_permissions?: model_has_permissionsUncheckedCreateNestedManyWithoutPermissionsInput
  }

  export type permissionsCreateOrConnectWithoutRole_has_permissionsInput = {
    where: permissionsWhereUniqueInput
    create: XOR<permissionsCreateWithoutRole_has_permissionsInput, permissionsUncheckedCreateWithoutRole_has_permissionsInput>
  }

  export type rolesCreateWithoutRole_has_permissionsInput = {
    id?: bigint | number
    name: string
    guard_name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    model_has_roles?: model_has_rolesCreateNestedManyWithoutRolesInput
  }

  export type rolesUncheckedCreateWithoutRole_has_permissionsInput = {
    id?: bigint | number
    name: string
    guard_name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    model_has_roles?: model_has_rolesUncheckedCreateNestedManyWithoutRolesInput
  }

  export type rolesCreateOrConnectWithoutRole_has_permissionsInput = {
    where: rolesWhereUniqueInput
    create: XOR<rolesCreateWithoutRole_has_permissionsInput, rolesUncheckedCreateWithoutRole_has_permissionsInput>
  }

  export type permissionsUpsertWithoutRole_has_permissionsInput = {
    update: XOR<permissionsUpdateWithoutRole_has_permissionsInput, permissionsUncheckedUpdateWithoutRole_has_permissionsInput>
    create: XOR<permissionsCreateWithoutRole_has_permissionsInput, permissionsUncheckedCreateWithoutRole_has_permissionsInput>
    where?: permissionsWhereInput
  }

  export type permissionsUpdateToOneWithWhereWithoutRole_has_permissionsInput = {
    where?: permissionsWhereInput
    data: XOR<permissionsUpdateWithoutRole_has_permissionsInput, permissionsUncheckedUpdateWithoutRole_has_permissionsInput>
  }

  export type permissionsUpdateWithoutRole_has_permissionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    guard_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    model_has_permissions?: model_has_permissionsUpdateManyWithoutPermissionsNestedInput
  }

  export type permissionsUncheckedUpdateWithoutRole_has_permissionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    guard_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    model_has_permissions?: model_has_permissionsUncheckedUpdateManyWithoutPermissionsNestedInput
  }

  export type rolesUpsertWithoutRole_has_permissionsInput = {
    update: XOR<rolesUpdateWithoutRole_has_permissionsInput, rolesUncheckedUpdateWithoutRole_has_permissionsInput>
    create: XOR<rolesCreateWithoutRole_has_permissionsInput, rolesUncheckedCreateWithoutRole_has_permissionsInput>
    where?: rolesWhereInput
  }

  export type rolesUpdateToOneWithWhereWithoutRole_has_permissionsInput = {
    where?: rolesWhereInput
    data: XOR<rolesUpdateWithoutRole_has_permissionsInput, rolesUncheckedUpdateWithoutRole_has_permissionsInput>
  }

  export type rolesUpdateWithoutRole_has_permissionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    guard_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    model_has_roles?: model_has_rolesUpdateManyWithoutRolesNestedInput
  }

  export type rolesUncheckedUpdateWithoutRole_has_permissionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    guard_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    model_has_roles?: model_has_rolesUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type model_has_rolesCreateWithoutRolesInput = {
    model_type: string
    model_id: bigint | number
  }

  export type model_has_rolesUncheckedCreateWithoutRolesInput = {
    model_type: string
    model_id: bigint | number
  }

  export type model_has_rolesCreateOrConnectWithoutRolesInput = {
    where: model_has_rolesWhereUniqueInput
    create: XOR<model_has_rolesCreateWithoutRolesInput, model_has_rolesUncheckedCreateWithoutRolesInput>
  }

  export type model_has_rolesCreateManyRolesInputEnvelope = {
    data: model_has_rolesCreateManyRolesInput | model_has_rolesCreateManyRolesInput[]
    skipDuplicates?: boolean
  }

  export type role_has_permissionsCreateWithoutRolesInput = {
    permissions: permissionsCreateNestedOneWithoutRole_has_permissionsInput
  }

  export type role_has_permissionsUncheckedCreateWithoutRolesInput = {
    permission_id: bigint | number
  }

  export type role_has_permissionsCreateOrConnectWithoutRolesInput = {
    where: role_has_permissionsWhereUniqueInput
    create: XOR<role_has_permissionsCreateWithoutRolesInput, role_has_permissionsUncheckedCreateWithoutRolesInput>
  }

  export type role_has_permissionsCreateManyRolesInputEnvelope = {
    data: role_has_permissionsCreateManyRolesInput | role_has_permissionsCreateManyRolesInput[]
    skipDuplicates?: boolean
  }

  export type model_has_rolesUpsertWithWhereUniqueWithoutRolesInput = {
    where: model_has_rolesWhereUniqueInput
    update: XOR<model_has_rolesUpdateWithoutRolesInput, model_has_rolesUncheckedUpdateWithoutRolesInput>
    create: XOR<model_has_rolesCreateWithoutRolesInput, model_has_rolesUncheckedCreateWithoutRolesInput>
  }

  export type model_has_rolesUpdateWithWhereUniqueWithoutRolesInput = {
    where: model_has_rolesWhereUniqueInput
    data: XOR<model_has_rolesUpdateWithoutRolesInput, model_has_rolesUncheckedUpdateWithoutRolesInput>
  }

  export type model_has_rolesUpdateManyWithWhereWithoutRolesInput = {
    where: model_has_rolesScalarWhereInput
    data: XOR<model_has_rolesUpdateManyMutationInput, model_has_rolesUncheckedUpdateManyWithoutRolesInput>
  }

  export type model_has_rolesScalarWhereInput = {
    AND?: model_has_rolesScalarWhereInput | model_has_rolesScalarWhereInput[]
    OR?: model_has_rolesScalarWhereInput[]
    NOT?: model_has_rolesScalarWhereInput | model_has_rolesScalarWhereInput[]
    role_id?: BigIntFilter<"model_has_roles"> | bigint | number
    model_type?: StringFilter<"model_has_roles"> | string
    model_id?: BigIntFilter<"model_has_roles"> | bigint | number
  }

  export type role_has_permissionsUpsertWithWhereUniqueWithoutRolesInput = {
    where: role_has_permissionsWhereUniqueInput
    update: XOR<role_has_permissionsUpdateWithoutRolesInput, role_has_permissionsUncheckedUpdateWithoutRolesInput>
    create: XOR<role_has_permissionsCreateWithoutRolesInput, role_has_permissionsUncheckedCreateWithoutRolesInput>
  }

  export type role_has_permissionsUpdateWithWhereUniqueWithoutRolesInput = {
    where: role_has_permissionsWhereUniqueInput
    data: XOR<role_has_permissionsUpdateWithoutRolesInput, role_has_permissionsUncheckedUpdateWithoutRolesInput>
  }

  export type role_has_permissionsUpdateManyWithWhereWithoutRolesInput = {
    where: role_has_permissionsScalarWhereInput
    data: XOR<role_has_permissionsUpdateManyMutationInput, role_has_permissionsUncheckedUpdateManyWithoutRolesInput>
  }

  export type ProjectCreateWithoutVolunteersInput = {
    id?: bigint | number
    projectId: string
    url: string
    titleId: string
    titleEn: string
    descriptionId: string
    descriptionEn: string
    location: string
    goalAmount: bigint | number
    raisedAmount?: bigint | number
    studentsImpacted: number
    image?: string | null
    status?: string
    featured?: boolean
    category: string
    startDate: Date | string
    endDate: Date | string
    school: JsonNullValueInput | InputJsonValue
    donorCount?: number
    volunteerCount?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    donations?: donationsCreateNestedManyWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutVolunteersInput = {
    id?: bigint | number
    projectId: string
    url: string
    titleId: string
    titleEn: string
    descriptionId: string
    descriptionEn: string
    location: string
    goalAmount: bigint | number
    raisedAmount?: bigint | number
    studentsImpacted: number
    image?: string | null
    status?: string
    featured?: boolean
    category: string
    startDate: Date | string
    endDate: Date | string
    school: JsonNullValueInput | InputJsonValue
    donorCount?: number
    volunteerCount?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    donations?: donationsUncheckedCreateNestedManyWithoutProjectsInput
  }

  export type ProjectCreateOrConnectWithoutVolunteersInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutVolunteersInput, ProjectUncheckedCreateWithoutVolunteersInput>
  }

  export type UserCreateWithoutVolunteersInput = {
    id?: bigint | number
    name: string
    email: string
    email_verified_at?: Date | string | null
    password: string
    remember_token?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    accesses?: NullableJsonNullValueInput | InputJsonValue
    must_change_password?: boolean
    blogs?: blogsCreateNestedManyWithoutUsersInput
    contacts?: contactsCreateNestedManyWithoutUsersInput
    donations?: donationsCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutVolunteersInput = {
    id?: bigint | number
    name: string
    email: string
    email_verified_at?: Date | string | null
    password: string
    remember_token?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    accesses?: NullableJsonNullValueInput | InputJsonValue
    must_change_password?: boolean
    blogs?: blogsUncheckedCreateNestedManyWithoutUsersInput
    contacts?: contactsUncheckedCreateNestedManyWithoutUsersInput
    donations?: donationsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutVolunteersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVolunteersInput, UserUncheckedCreateWithoutVolunteersInput>
  }

  export type ProjectUpsertWithoutVolunteersInput = {
    update: XOR<ProjectUpdateWithoutVolunteersInput, ProjectUncheckedUpdateWithoutVolunteersInput>
    create: XOR<ProjectCreateWithoutVolunteersInput, ProjectUncheckedCreateWithoutVolunteersInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutVolunteersInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutVolunteersInput, ProjectUncheckedUpdateWithoutVolunteersInput>
  }

  export type ProjectUpdateWithoutVolunteersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    projectId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    titleId?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionId?: StringFieldUpdateOperationsInput | string
    descriptionEn?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    goalAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    raisedAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    studentsImpacted?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    category?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: JsonNullValueInput | InputJsonValue
    donorCount?: IntFieldUpdateOperationsInput | number
    volunteerCount?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    donations?: donationsUpdateManyWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutVolunteersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    projectId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    titleId?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionId?: StringFieldUpdateOperationsInput | string
    descriptionEn?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    goalAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    raisedAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    studentsImpacted?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    category?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: JsonNullValueInput | InputJsonValue
    donorCount?: IntFieldUpdateOperationsInput | number
    volunteerCount?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    donations?: donationsUncheckedUpdateManyWithoutProjectsNestedInput
  }

  export type UserUpsertWithoutVolunteersInput = {
    update: XOR<UserUpdateWithoutVolunteersInput, UserUncheckedUpdateWithoutVolunteersInput>
    create: XOR<UserCreateWithoutVolunteersInput, UserUncheckedCreateWithoutVolunteersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVolunteersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVolunteersInput, UserUncheckedUpdateWithoutVolunteersInput>
  }

  export type UserUpdateWithoutVolunteersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    remember_token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accesses?: NullableJsonNullValueInput | InputJsonValue
    must_change_password?: BoolFieldUpdateOperationsInput | boolean
    blogs?: blogsUpdateManyWithoutUsersNestedInput
    contacts?: contactsUpdateManyWithoutUsersNestedInput
    donations?: donationsUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutVolunteersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    remember_token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accesses?: NullableJsonNullValueInput | InputJsonValue
    must_change_password?: BoolFieldUpdateOperationsInput | boolean
    blogs?: blogsUncheckedUpdateManyWithoutUsersNestedInput
    contacts?: contactsUncheckedUpdateManyWithoutUsersNestedInput
    donations?: donationsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type blogsCreateManyUsersInput = {
    id?: bigint | number
    slug: string
    title_id: string
    excerpt_id: string
    content_id: string
    title_en: string
    excerpt_en: string
    content_en: string
    author_name: string
    author_role?: string | null
    author_avatar?: string | null
    category: string
    tags?: NullableJsonNullValueInput | InputJsonValue
    image?: string | null
    image_alt?: string | null
    meta_title_id?: string | null
    meta_description_id?: string | null
    meta_title_en?: string | null
    meta_description_en?: string | null
    read_time?: number
    views_count?: bigint | number
    status?: string
    featured?: boolean
    published_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type contactsCreateManyUsersInput = {
    id?: bigint | number
    contact_id: string
    name: string
    email: string
    phone?: string | null
    subject?: string
    message: string
    ip_address?: string | null
    user_agent?: string | null
    status?: string
    priority?: string
    responded_at?: Date | string | null
    response?: string | null
    internal_notes?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type donationsCreateManyUsersInput = {
    id?: bigint | number
    donation_id: string
    project_id: bigint | number
    donor_name?: string | null
    donor_email?: string | null
    donor_phone?: string | null
    amount: bigint | number
    frequency?: string
    status?: string
    payment_method?: string | null
    payment_channel?: string | null
    transaction_id?: string | null
    paid_at?: Date | string | null
    message?: string | null
    is_anonymous?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type volunteersCreateManyUsersInput = {
    id?: bigint | number
    volunteer_id: string
    project_id?: bigint | number | null
    first_name: string
    last_name: string
    email: string
    phone: string
    interests?: NullableJsonNullValueInput | InputJsonValue
    availability?: NullableJsonNullValueInput | InputJsonValue
    experience?: string | null
    motivation: string
    location?: string | null
    occupation?: string | null
    status?: string
    approved_at?: Date | string | null
    notes?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type blogsUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    slug?: StringFieldUpdateOperationsInput | string
    title_id?: StringFieldUpdateOperationsInput | string
    excerpt_id?: StringFieldUpdateOperationsInput | string
    content_id?: StringFieldUpdateOperationsInput | string
    title_en?: StringFieldUpdateOperationsInput | string
    excerpt_en?: StringFieldUpdateOperationsInput | string
    content_en?: StringFieldUpdateOperationsInput | string
    author_name?: StringFieldUpdateOperationsInput | string
    author_role?: NullableStringFieldUpdateOperationsInput | string | null
    author_avatar?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: NullableJsonNullValueInput | InputJsonValue
    image?: NullableStringFieldUpdateOperationsInput | string | null
    image_alt?: NullableStringFieldUpdateOperationsInput | string | null
    meta_title_id?: NullableStringFieldUpdateOperationsInput | string | null
    meta_description_id?: NullableStringFieldUpdateOperationsInput | string | null
    meta_title_en?: NullableStringFieldUpdateOperationsInput | string | null
    meta_description_en?: NullableStringFieldUpdateOperationsInput | string | null
    read_time?: IntFieldUpdateOperationsInput | number
    views_count?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type blogsUncheckedUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    slug?: StringFieldUpdateOperationsInput | string
    title_id?: StringFieldUpdateOperationsInput | string
    excerpt_id?: StringFieldUpdateOperationsInput | string
    content_id?: StringFieldUpdateOperationsInput | string
    title_en?: StringFieldUpdateOperationsInput | string
    excerpt_en?: StringFieldUpdateOperationsInput | string
    content_en?: StringFieldUpdateOperationsInput | string
    author_name?: StringFieldUpdateOperationsInput | string
    author_role?: NullableStringFieldUpdateOperationsInput | string | null
    author_avatar?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: NullableJsonNullValueInput | InputJsonValue
    image?: NullableStringFieldUpdateOperationsInput | string | null
    image_alt?: NullableStringFieldUpdateOperationsInput | string | null
    meta_title_id?: NullableStringFieldUpdateOperationsInput | string | null
    meta_description_id?: NullableStringFieldUpdateOperationsInput | string | null
    meta_title_en?: NullableStringFieldUpdateOperationsInput | string | null
    meta_description_en?: NullableStringFieldUpdateOperationsInput | string | null
    read_time?: IntFieldUpdateOperationsInput | number
    views_count?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type blogsUncheckedUpdateManyWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    slug?: StringFieldUpdateOperationsInput | string
    title_id?: StringFieldUpdateOperationsInput | string
    excerpt_id?: StringFieldUpdateOperationsInput | string
    content_id?: StringFieldUpdateOperationsInput | string
    title_en?: StringFieldUpdateOperationsInput | string
    excerpt_en?: StringFieldUpdateOperationsInput | string
    content_en?: StringFieldUpdateOperationsInput | string
    author_name?: StringFieldUpdateOperationsInput | string
    author_role?: NullableStringFieldUpdateOperationsInput | string | null
    author_avatar?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: NullableJsonNullValueInput | InputJsonValue
    image?: NullableStringFieldUpdateOperationsInput | string | null
    image_alt?: NullableStringFieldUpdateOperationsInput | string | null
    meta_title_id?: NullableStringFieldUpdateOperationsInput | string | null
    meta_description_id?: NullableStringFieldUpdateOperationsInput | string | null
    meta_title_en?: NullableStringFieldUpdateOperationsInput | string | null
    meta_description_en?: NullableStringFieldUpdateOperationsInput | string | null
    read_time?: IntFieldUpdateOperationsInput | number
    views_count?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type contactsUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    contact_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    responded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type contactsUncheckedUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    contact_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    responded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type contactsUncheckedUpdateManyWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    contact_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    responded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type donationsUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    donation_id?: StringFieldUpdateOperationsInput | string
    donor_name?: NullableStringFieldUpdateOperationsInput | string | null
    donor_email?: NullableStringFieldUpdateOperationsInput | string | null
    donor_phone?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    frequency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    payment_channel?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    is_anonymous?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projects?: ProjectUpdateOneRequiredWithoutDonationsNestedInput
  }

  export type donationsUncheckedUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    donation_id?: StringFieldUpdateOperationsInput | string
    project_id?: BigIntFieldUpdateOperationsInput | bigint | number
    donor_name?: NullableStringFieldUpdateOperationsInput | string | null
    donor_email?: NullableStringFieldUpdateOperationsInput | string | null
    donor_phone?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    frequency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    payment_channel?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    is_anonymous?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type donationsUncheckedUpdateManyWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    donation_id?: StringFieldUpdateOperationsInput | string
    project_id?: BigIntFieldUpdateOperationsInput | bigint | number
    donor_name?: NullableStringFieldUpdateOperationsInput | string | null
    donor_email?: NullableStringFieldUpdateOperationsInput | string | null
    donor_phone?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    frequency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    payment_channel?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    is_anonymous?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type volunteersUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    volunteer_id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    interests?: NullableJsonNullValueInput | InputJsonValue
    availability?: NullableJsonNullValueInput | InputJsonValue
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    motivation?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projects?: ProjectUpdateOneWithoutVolunteersNestedInput
  }

  export type volunteersUncheckedUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    volunteer_id?: StringFieldUpdateOperationsInput | string
    project_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    interests?: NullableJsonNullValueInput | InputJsonValue
    availability?: NullableJsonNullValueInput | InputJsonValue
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    motivation?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type volunteersUncheckedUpdateManyWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    volunteer_id?: StringFieldUpdateOperationsInput | string
    project_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    interests?: NullableJsonNullValueInput | InputJsonValue
    availability?: NullableJsonNullValueInput | InputJsonValue
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    motivation?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type donationsCreateManyProjectsInput = {
    id?: bigint | number
    donation_id: string
    user_id?: bigint | number | null
    donor_name?: string | null
    donor_email?: string | null
    donor_phone?: string | null
    amount: bigint | number
    frequency?: string
    status?: string
    payment_method?: string | null
    payment_channel?: string | null
    transaction_id?: string | null
    paid_at?: Date | string | null
    message?: string | null
    is_anonymous?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type volunteersCreateManyProjectsInput = {
    id?: bigint | number
    volunteer_id: string
    user_id?: bigint | number | null
    first_name: string
    last_name: string
    email: string
    phone: string
    interests?: NullableJsonNullValueInput | InputJsonValue
    availability?: NullableJsonNullValueInput | InputJsonValue
    experience?: string | null
    motivation: string
    location?: string | null
    occupation?: string | null
    status?: string
    approved_at?: Date | string | null
    notes?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type donationsUpdateWithoutProjectsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    donation_id?: StringFieldUpdateOperationsInput | string
    donor_name?: NullableStringFieldUpdateOperationsInput | string | null
    donor_email?: NullableStringFieldUpdateOperationsInput | string | null
    donor_phone?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    frequency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    payment_channel?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    is_anonymous?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateOneWithoutDonationsNestedInput
  }

  export type donationsUncheckedUpdateWithoutProjectsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    donation_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    donor_name?: NullableStringFieldUpdateOperationsInput | string | null
    donor_email?: NullableStringFieldUpdateOperationsInput | string | null
    donor_phone?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    frequency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    payment_channel?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    is_anonymous?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type donationsUncheckedUpdateManyWithoutProjectsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    donation_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    donor_name?: NullableStringFieldUpdateOperationsInput | string | null
    donor_email?: NullableStringFieldUpdateOperationsInput | string | null
    donor_phone?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    frequency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    payment_channel?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    is_anonymous?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type volunteersUpdateWithoutProjectsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    volunteer_id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    interests?: NullableJsonNullValueInput | InputJsonValue
    availability?: NullableJsonNullValueInput | InputJsonValue
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    motivation?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateOneWithoutVolunteersNestedInput
  }

  export type volunteersUncheckedUpdateWithoutProjectsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    volunteer_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    interests?: NullableJsonNullValueInput | InputJsonValue
    availability?: NullableJsonNullValueInput | InputJsonValue
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    motivation?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type volunteersUncheckedUpdateManyWithoutProjectsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    volunteer_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    interests?: NullableJsonNullValueInput | InputJsonValue
    availability?: NullableJsonNullValueInput | InputJsonValue
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    motivation?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type model_has_permissionsCreateManyPermissionsInput = {
    model_type: string
    model_id: bigint | number
  }

  export type role_has_permissionsCreateManyPermissionsInput = {
    role_id: bigint | number
  }

  export type model_has_permissionsUpdateWithoutPermissionsInput = {
    model_type?: StringFieldUpdateOperationsInput | string
    model_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type model_has_permissionsUncheckedUpdateWithoutPermissionsInput = {
    model_type?: StringFieldUpdateOperationsInput | string
    model_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type model_has_permissionsUncheckedUpdateManyWithoutPermissionsInput = {
    model_type?: StringFieldUpdateOperationsInput | string
    model_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type role_has_permissionsUpdateWithoutPermissionsInput = {
    roles?: rolesUpdateOneRequiredWithoutRole_has_permissionsNestedInput
  }

  export type role_has_permissionsUncheckedUpdateWithoutPermissionsInput = {
    role_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type role_has_permissionsUncheckedUpdateManyWithoutPermissionsInput = {
    role_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type model_has_rolesCreateManyRolesInput = {
    model_type: string
    model_id: bigint | number
  }

  export type role_has_permissionsCreateManyRolesInput = {
    permission_id: bigint | number
  }

  export type model_has_rolesUpdateWithoutRolesInput = {
    model_type?: StringFieldUpdateOperationsInput | string
    model_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type model_has_rolesUncheckedUpdateWithoutRolesInput = {
    model_type?: StringFieldUpdateOperationsInput | string
    model_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type model_has_rolesUncheckedUpdateManyWithoutRolesInput = {
    model_type?: StringFieldUpdateOperationsInput | string
    model_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type role_has_permissionsUpdateWithoutRolesInput = {
    permissions?: permissionsUpdateOneRequiredWithoutRole_has_permissionsNestedInput
  }

  export type role_has_permissionsUncheckedUpdateWithoutRolesInput = {
    permission_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type role_has_permissionsUncheckedUpdateManyWithoutRolesInput = {
    permission_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}